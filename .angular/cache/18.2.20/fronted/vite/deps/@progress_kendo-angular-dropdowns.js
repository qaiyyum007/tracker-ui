import {
  DialogComponent,
  DialogContainerService,
  DialogService,
  WindowContainerService,
  WindowService
} from "./chunk-WALR6YJV.js";
import {
  ActionSheetComponent,
  ActionSheetTemplateDirective,
  IntlService,
  MultiPath,
  Path,
  color_default,
  drawing_exports,
  exportImage,
  geometry_exports,
  group_default,
  image_default,
  named_colors_default,
  parseColor,
  surface_default
} from "./chunk-V2NPQMAJ.js";
import {
  DefaultValueAccessor,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgModel,
  RadioControlValueAccessor,
  ReactiveFormsModule
} from "./chunk-NXPF7HPN.js";
import {
  ButtonComponent,
  ComponentMessages,
  IconComponent,
  IconWrapperComponent,
  IconsService,
  L10N_PREFIX,
  LocalizationService,
  MessageService,
  RTL,
  cancelIcon,
  caretAltDownIcon,
  caretAltExpandIcon,
  caretAltLeftIcon,
  caretAltRightIcon,
  caretAltUpIcon,
  checkIcon,
  dropletSlashIcon,
  dropletSliderIcon,
  exclamationCircleIcon,
  hyperlinkOpenIcon,
  insertBottomIcon,
  insertMiddleIcon,
  insertTopIcon,
  paletteIcon,
  plusIcon,
  searchIcon,
  starIcon,
  starOutlineIcon,
  xCircleIcon,
  xIcon
} from "./chunk-RFPOWLAR.js";
import {
  Draggable,
  DraggableDirective,
  EventsOutsideAngularDirective,
  KENDO_ADORNMENTS,
  KENDO_TOGGLEBUTTONTABSTOP,
  KendoInput,
  Keys,
  MultiTabStop,
  PopupService,
  PrefixTemplateDirective,
  PreventableEvent,
  ResizeBatchService,
  ResizeSensorComponent,
  SeparatorComponent,
  SuffixTemplateDirective,
  TemplateContextDirective,
  ToggleButtonTabStopDirective,
  anyChanged,
  areObjectsEqual,
  closest,
  contains,
  findFocusableChild,
  getter,
  guid,
  hasObservers,
  isChanged,
  isControlRequired,
  isDocumentAvailable,
  isObjectPresent,
  isPresent,
  isSafari,
  mobileOS,
  parseAttributes,
  parseCSSClassNames,
  pointers,
  removeHTMLAttributes,
  setHTMLAttributes,
  setter,
  touchEnabled,
  validatePackage
} from "./chunk-THOT5VRV.js";
import {
  animate,
  style,
  transition,
  trigger
} from "./chunk-TP5GELBR.js";
import "./chunk-UZ6RDM67.js";
import "./chunk-XAZTX2QX.js";
import {
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-XCCWPIQ4.js";
import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  KeyValueDiffers,
  NgModule,
  NgZone,
  Optional,
  Output,
  Renderer2,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  forwardRef,
  isDevMode,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵi18nApply,
  ɵɵi18nAttributes,
  ɵɵi18nExp,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction7,
  ɵɵpureFunctionV,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-B5AFSGLI.js";
import {
  fromEvent,
  merge
} from "./chunk-YAPLD6I3.js";
import {
  partition
} from "./chunk-AH4SJNYT.js";
import {
  BehaviorSubject,
  EMPTY,
  Subject,
  Subscription,
  __async,
  __spreadProps,
  __spreadValues,
  auditTime,
  catchError,
  concatMap,
  debounceTime,
  delay,
  filter,
  finalize,
  interval,
  map,
  of,
  skip,
  skipWhile,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  throttleTime
} from "./chunk-6R3LY43K.js";

// node_modules/@progress/kendo-draggable-common/dist/es/algorithms/intersect.js
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect = function(element, candidates) {
  var max = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};

// node_modules/@progress/kendo-draggable-common/dist/es/utils/index.js
var detectBrowser = function() {
  var ua = window && window.navigator.userAgent;
  if (!ua) {
    return false;
  }
  var browser = false;
  var match2 = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match2 = ua.match(browserRxs[agent]);
      if (match2) {
        browser = {};
        browser[agent] = true;
        browser[match2[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser.version = parseInt(document.DOCUMENT_NODE || match2[2], 10);
        break;
      }
    }
  }
  return browser;
};
var getDocument = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow = function(element) {
  var document2 = getDocument(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support = {
    browser: detectBrowser()
  };
  var document2 = getDocument(element);
  return support.browser.edge || support.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el) {
  if (el && el.className && typeof el.className === "string" && el.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el) {
  var root = scrollableRoot(el);
  if (!el || el === document.body || el === document.documentElement) {
    return root;
  }
  var parent = el;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = {
    x: 0,
    y: 0
  };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el, window2) {
  var root = scrollableRoot(el);
  if (el === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x, y, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y && rect.left <= x && y <= rect.bottom && x <= rect.right;
};

// node_modules/@progress/kendo-draggable-common/dist/es/drag-n-drop.js
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event) {
  return /^touch/.test(event.type);
};
var isScrollEvent = function(event) {
  return /^(scroll)/.test(event.type);
};
var normalizeEvent = function(event, state) {
  return isTouchEvent(event) ? {
    pageX: event.changedTouches[0].pageX,
    pageY: event.changedTouches[0].pageY,
    clientX: event.changedTouches[0].clientX,
    clientY: event.changedTouches[0].clientY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event) ? {
    pageX: state.pageOffset.x,
    pageY: state.pageOffset.y,
    clientX: state.clientOffset.x,
    clientY: state.clientOffset.y,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event.pageX,
    pageY: event.pageY,
    clientX: event.clientX,
    clientY: event.clientY,
    offsetX: event.offsetX,
    offsetY: event.offsetY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    type: event.type,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    originalEvent: event
  };
};
var noop = function() {
};
var dispatchDragAndDrop = function(state, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a2 = callbacks.onIsPressedChange, onIsPressedChange = _a2 === void 0 ? noop : _a2, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop : _d, _e = callbacks.onPageOffsetChange, onPageOffsetChange = _e === void 0 ? noop : _e, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state.autoScrollDirection;
  var overrideScrollableParent = state.scrollableParent;
  var event = normalizeEvent(action.event, state);
  switch (event.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event.originalEvent.which && event.originalEvent.which > 1 || state.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? {
        x: scrollableParent_1.scrollX,
        y: scrollableParent_1.scrollY
      } : {
        x: scrollableParent_1.scrollLeft,
        y: scrollableParent_1.scrollTop
      });
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      onOffsetChange({
        x: event.offsetX,
        y: event.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? {
        x: scrollableParent.scrollX,
        y: scrollableParent.scrollY
      } : {
        x: scrollableParent.scrollLeft,
        y: scrollableParent.scrollTop
      };
      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;
      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event.scrollX,
        y: event.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state.pressed) {
        if (state.autoScroll && event.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));
            var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state.drag && drag.onDragStart) {
          drag.onDragStart(event);
        }
        if (drag.onDrag) {
          drag.onDrag(event);
        }
        var dropElement_1 = intersect(hint || element, state.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d) {
          return d !== (hint || element);
        }));
        var drop = state.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state.drop && state.drop.element) !== dropElement_1) {
            if (state.drop && state.drop.onDragLeave) {
              state.drop.onDragLeave(event);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event);
            }
          }
        } else if (state.drop && state.drop.onDragLeave) {
          state.drop.onDragLeave(event);
        }
      }
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onRelease) {
        drag.onRelease(event);
      }
      if (state.drop && state.drop.onDrop) {
        state.drop.onDrop(event);
      }
      if (state.drag && drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({
        x: 0,
        y: 0
      });
      if (drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      if (state.drop && state.drop.onDragLeave) {
        state.drop.onDragLeave(event);
      }
      break;
    }
    default:
      break;
  }
};

// node_modules/@progress/kendo-draggable-common/dist/es/auto-scroll.js
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};

// node_modules/@progress/kendo-angular-utils/fesm2022/progress-kendo-angular-utils.mjs
var _c0 = (a0, a1, a2) => ({
  $implicit: a0,
  index: a1,
  data: a2
});
var DragHandleDirective = class _DragHandleDirective {
  element;
  touchActionStyle = "none";
  /**
   * Sets the cursor style of the drag handle. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function DragHandleDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragHandleDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragHandleDirective,
    selectors: [["", "kendoDragHandle", ""]],
    hostVars: 4,
    hostBindings: function DragHandleDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("touch-action", ctx.touchActionStyle)("cursor", ctx.cursorStyle);
      }
    },
    inputs: {
      cursorStyle: "cursorStyle"
    },
    exportAs: ["kendoDragHandle"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragHandleDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragHandle]",
      exportAs: "kendoDragHandle",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    touchActionStyle: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    cursorStyle: [{
      type: HostBinding,
      args: ["style.cursor"]
    }, {
      type: Input
    }]
  });
})();
var packageMetadata = {
  name: "@progress/kendo-angular-utils",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1751462971,
  version: "19.2.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
function isDocumentNode(container) {
  return container.nodeType === 9;
}
var getAction = (event, draggable) => {
  return {
    event,
    payload: draggable
  };
};
var dragTargetTransition = "transform .3s ease-in-out";
var isPresent2 = (value) => value !== null && value !== void 0;
function closestBySelector(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  const matches2 = Element.prototype.matches ? (el, sel) => el.matches(sel) : (el, sel) => el.msMatchesSelector(sel);
  let node = element;
  while (node && !isDocumentNode(node)) {
    if (matches2(node, selector)) {
      return node;
    }
    node = node.parentNode;
  }
}
var intersect2 = (element, candidates) => {
  let max = 0;
  let result = null;
  candidates.forEach((candidate) => {
    if (candidate && element) {
      const ration = getRatio2(element, candidate);
      if (ration > max) {
        max = ration;
        result = candidate;
      }
    }
  });
  return result;
};
var getRatio2 = (element, target) => {
  const elementRect = element.getBoundingClientRect();
  const targetRect = target.getBoundingClientRect();
  const top = Math.max(targetRect.top, elementRect.top);
  const left = Math.max(targetRect.left, elementRect.left);
  const right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  const bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = targetRect.width * targetRect.height;
    const entryArea = elementRect.width * elementRect.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var setElementStyles = (renderer, elem, styles) => {
  const props = Object.keys(styles);
  props.forEach((p) => {
    renderer.setStyle(elem, p, styles[p]);
  });
};
var noop2 = () => {
};
var DragStateService = class _DragStateService {
  constructor() {
    this.setCallbacks();
  }
  dragTarget = null;
  dropTarget = null;
  dragTargets = [];
  dropTargets = [];
  pressed = false;
  ignoreMouse = false;
  autoScroll = true;
  isScrolling = false;
  scrollableParent = null;
  autoScrollDirection = {
    horizontal: true,
    vertical: true
  };
  initialClientOffset = {
    x: 0,
    y: 0
  };
  clientOffset = {
    x: 0,
    y: 0
  };
  initialScrollOffset = {
    x: 0,
    y: 0
  };
  scrollOffset = {
    x: 0,
    y: 0
  };
  offset = {
    x: 0,
    y: 0
  };
  pageOffset = {
    x: 0,
    y: 0
  };
  velocity = {
    x: 0,
    y: 0
  };
  dragTargetDirective;
  state;
  dragIndex = null;
  dropIndex = null;
  dragData;
  dragTargetId;
  callbacks = {};
  scrollInterval = null;
  handleDragAndDrop(action) {
    this.updateState();
    dispatchDragAndDrop(this.state, action, this.callbacks);
  }
  setPressed(pressed) {
    this.pressed = pressed;
  }
  setScrolling(isScrolling) {
    this.isScrolling = isScrolling;
    if (isScrolling) {
      const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = window.setInterval(() => {
        autoScroll(scrollableParent, {
          x: this.velocity.x,
          y: this.velocity.y
        });
      }, 50);
    } else {
      if (this.scrollInterval) {
        window.clearInterval(this.scrollInterval);
        this.scrollInterval = null;
      }
    }
  }
  setVelocity(velocity) {
    this.velocity = velocity;
  }
  setOffset(offset) {
    this.offset = offset;
  }
  setClientOffset(clientOffset) {
    this.clientOffset = clientOffset;
  }
  setPageOffset(pageOffset) {
    this.pageOffset = pageOffset;
  }
  setInitialClientOffset(initialClientOffset) {
    this.initialClientOffset = initialClientOffset;
  }
  setScrollOffset(scrollOffset) {
    this.scrollOffset = scrollOffset;
  }
  setInitialScrollOffset(initialScrollOffset) {
    this.initialScrollOffset = initialScrollOffset;
  }
  get dragTargetPresent() {
    return isPresent2(this.dragTarget?.element);
  }
  get dropTargetPresent() {
    return isPresent2(this.dropTarget?.element);
  }
  updateState() {
    this.state = {
      drag: this.dragTarget,
      drop: this.dropTarget,
      drags: this.dragTargets,
      drops: this.dropTargets,
      pressed: this.pressed,
      ignoreMouse: this.ignoreMouse,
      autoScroll: this.autoScroll,
      isScrolling: this.isScrolling,
      scrollableParent: this.scrollableParent,
      autoScrollDirection: this.autoScrollDirection,
      initialClientOffset: this.initialClientOffset,
      clientOffset: this.clientOffset,
      initialScrollOffset: this.initialScrollOffset,
      scrollOffset: this.scrollOffset,
      offset: this.offset,
      pageOffset: this.pageOffset,
      velocity: this.velocity
    };
  }
  setCallbacks() {
    this.callbacks = {
      onVelocityChange: this.setVelocity.bind(this),
      onOffsetChange: this.setOffset.bind(this),
      onClientOffsetChange: this.setClientOffset.bind(this),
      onPageOffsetChange: this.setPageOffset.bind(this),
      onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),
      onScrollOffsetChange: this.setScrollOffset.bind(this),
      onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),
      onIsPressedChange: this.setPressed.bind(this),
      onIsScrollingChange: this.setScrolling.bind(this)
    };
  }
  ngOnDestroy() {
    if (this.scrollInterval) {
      window.clearInterval(this.scrollInterval);
      this.scrollInterval = null;
    }
  }
  static ɵfac = function DragStateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragStateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragStateService,
    factory: _DragStateService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragStateService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var HintComponent = class _HintComponent {
  element;
  template;
  directive;
  targetIndex;
  contextData;
  customContext;
  pointerEvents = "none";
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function HintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HintComponent)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HintComponent,
    selectors: [["kendo-draghint"]],
    hostVars: 2,
    hostBindings: function HintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("pointer-events", ctx.pointerEvents);
      }
    },
    inputs: {
      template: "template",
      directive: "directive",
      targetIndex: "targetIndex",
      contextData: "contextData",
      customContext: "customContext"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 1,
    vars: 6,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function HintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngTemplateOutlet", ctx.template)("ngTemplateOutletContext", ctx.customContext || ɵɵpureFunction3(2, _c0, ctx.directive, ctx.targetIndex, ctx.contextData));
      }
    },
    dependencies: [NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintComponent, [{
    type: Component,
    args: [{
      selector: "kendo-draghint",
      template: `
        <ng-container
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="customContext || { $implicit: this.directive, index: this.targetIndex, data: this.contextData }">
        </ng-container>
    `,
      standalone: true,
      imports: [NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    template: [{
      type: Input
    }],
    directive: [{
      type: Input
    }],
    targetIndex: [{
      type: Input
    }],
    contextData: [{
      type: Input
    }],
    customContext: [{
      type: Input
    }],
    pointerEvents: [{
      type: HostBinding,
      args: ["style.pointer-events"]
    }]
  });
})();
var DragTargetPressEvent = class {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragReadyEvent = class {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragStartEvent = class extends PreventableEvent {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DragTargetDragEndEvent = class {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DragTargetDragEvent = class extends PreventableEvent {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The hint element of the `DragTarget`.
   */
  hintElement;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    super();
    Object.assign(this, args);
  }
};
var DragTargetReleaseEvent = class {
  /**
   * The information related to the current drag event.
   * This is the normalized drag event that contains details about the drag operation.
   */
  dragEvent;
  /**
   * The DOM element being dragged.
   */
  dragTarget;
  /**
   * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragTargetId;
  /**
   * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
   */
  dragTargetIndex;
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DragTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dragTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var isDragStartPrevented$1 = false;
var isDragPrevented$1 = false;
var DragTargetContainerDirective = class _DragTargetContainerDirective {
  wrapper;
  ngZone;
  renderer;
  service;
  viewContainer;
  cdr;
  /**
   * Defines whether a hint will be used for dragging. By default, the hint is a copy of the current drag target. [See example]({% slug drag_hint %}).
   *
   * @default false
   */
  hint = false;
  /**
   * Sets a selector for elements in the container to make them draggable. The possible values include any
   * DOM `selector`. [See example]({% slug drag_target_container %}).
   */
  set dragTargetFilter(value) {
    this._dragTargetFilter = value;
    if (!this.dragDisabled) {
      this.initializeDragTargets();
    }
  }
  get dragTargetFilter() {
    return this._dragTargetFilter;
  }
  /**
   * Sets a selector for elements inside each drag target to use as drag handles.
   */
  dragHandle;
  /**
   * Sets the delay in milliseconds before dragging begins. [See example](slug:drag_target_container#toc-events).
   *
   * @default 0
   */
  dragDelay = 0;
  /**
   * Sets the number of pixels the pointer must move before dragging starts. [See example]({% slug minimum_distance %}).
   *
   * @default 0
   */
  threshold = 0;
  /**
   * Sets a unique identifier for each drag target.
   * It exposes the current drag target HTML element and its index in the collection of drag targets as arguments.
   */
  set dragTargetId(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragTargetId must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragTargetId = fn;
  }
  get dragTargetId() {
    return this._dragTargetId;
  }
  /**
   * Sets a callback function to return custom data for `DropTarget` events.
   * It exposes the current `DragTarget` HTML element, its `dragTargetId`, and its index in the collection of drag targets as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  /**
   * Disables dragging of drag targets in the container when set to `true`.
   *
   * @default false
   */
  set dragDisabled(value) {
    this._dragDisabled = value;
    if (value) {
      this.clearPreviousTargets();
      this.removeListeners();
      if (isPresent2(this.hintElem)) {
        this.destroyHint();
      }
    } else {
      if (isPresent2(this.wrapper) || isPresent2(this.currentDragTarget)) {
        this.subscribe();
      }
      this.initializeDragTargets();
    }
  }
  get dragDisabled() {
    return this._dragDisabled;
  }
  /**
   * Sets whether to use the default dragging behavior or handle it manually.
   *
   * @default 'auto'
   */
  mode = "auto";
  /**
   * Sets the cursor style of the drag targets. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  /**
   * @hidden
   */
  hintContext;
  /**
   * Fires when a drag target's `dragDelay` has passed and the user can drag the element.
   */
  onDragReady = new EventEmitter();
  /**
   * Fires when the user presses a drag target element.
   */
  onPress = new EventEmitter();
  /**
   * Fires when dragging of a drag target element begins.
   */
  onDragStart = new EventEmitter();
  /**
   * Fires while the user drags a drag target element.
   */
  onDrag = new EventEmitter();
  /**
   * Fires when the user releases a drag target element after pressing it.
   */
  onRelease = new EventEmitter();
  /**
   * Fires when dragging of a drag target ends and the element is released.
   */
  onDragEnd = new EventEmitter();
  /**
   * Notifies the `DragTargetContainer` that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDragTargets();
  }
  currentDragTarget = null;
  dragTimeout = null;
  pressed = false;
  dragStarted = false;
  hintComponent = null;
  defaultHint = null;
  currentDragTargetElement = null;
  scrollableParent = null;
  previousDragTargets = [];
  initialPosition = {
    x: 0,
    y: 0
  };
  position = {
    x: 0,
    y: 0
  };
  positionsMap = /* @__PURE__ */ new Map();
  _dragTargetFilter = null;
  _dragDisabled = false;
  _dragData = () => null;
  _dragTargetId = () => null;
  prevUserSelect;
  get allDragTargets() {
    return this.queryHost(this.dragTargetFilter);
  }
  get dragHandles() {
    return this.isHandleSelectorValid ? this.queryHost(this.dragHandle) : null;
  }
  get hintTemplate() {
    return isPresent2(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  constructor(wrapper, ngZone, renderer, service, viewContainer, cdr) {
    this.wrapper = wrapper;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.service = service;
    this.viewContainer = viewContainer;
    this.cdr = cdr;
    validatePackage(packageMetadata);
  }
  ngAfterViewInit() {
    const isTargetPresent = isPresent2(this.wrapper) || isPresent2(this.currentDragTarget);
    if (!this.dragDisabled && isTargetPresent) {
      this.subscribe();
    }
    !this.dragDisabled && this.initializeDragTargets();
  }
  ngOnDestroy() {
    this.removeListeners();
  }
  onPointerDown(event) {
    const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
    if (this.dragTargetFilter === "" || !isPresent2(filterElement)) {
      return;
    }
    if (isPresent2(this.dragHandles) && !this.isDragHandle(event.target)) {
      return;
    }
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onTouchStart(event) {
    const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
    if (this.dragTargetFilter === "" || !isPresent2(filterElement)) {
      return;
    }
    if (isPresent2(this.dragHandles) && !this.isDragHandle(event.target)) {
      return;
    }
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onPointerMove(event) {
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
  }
  onTouchMove(event) {
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event) {
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  onContextMenu(event) {
    event.preventDefault();
    const action = getAction(event, this.currentDragTarget);
    this.service.handleDragAndDrop(action);
    this.subscribe();
  }
  handlePress(event) {
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.pressed = true;
        this.emitZoneAwareEvent("onDragReady", event);
      }, this.dragDelay);
    } else {
      this.pressed = true;
    }
    const eventTarget = event.originalEvent.target;
    this.currentDragTargetElement = closestBySelector(eventTarget, this.dragTargetFilter);
    this.currentDragTarget.element = this.currentDragTargetElement;
    this.service.dragIndex = this.getDragIndex();
    this.scrollableParent = this.hintTemplate ? document.body : this.currentDragTargetElement ? getScrollableParent(this.currentDragTargetElement) : null;
    this.prevUserSelect = this.currentDragTargetElement.style.userSelect;
    this.renderer.setStyle(this.currentDragTargetElement, "user-select", "none");
    this.emitZoneAwareEvent("onPress", event);
  }
  handleDragStart(event) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    isDragStartPrevented$1 = this.emitZoneAwareEvent("onDragStart", event).isDefaultPrevented();
    if (isDragStartPrevented$1) {
      return;
    }
    this.position = this.positionsMap.has(this.currentDragTargetElement) ? this.positionsMap.get(this.currentDragTargetElement) : {
      x: 0,
      y: 0
    };
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.currentDragTargetElement, "opacity", "0.7");
      }
    } else {
      this.initialPosition = {
        x: event.clientX - this.position.x,
        y: event.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.currentDragTarget;
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    this.service.dragTargetId = this.dragTargetId(targetIdArgs);
    const targetDataArgs = Object.assign({
      dragTargetId: this.service.dragTargetId
    }, targetIdArgs);
    this.service.dragData = this.dragData(targetDataArgs);
  }
  handleDrag(event) {
    if (!this.pressed || isDragStartPrevented$1) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    this.position = this.calculatePosition(elem, event);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented$1 = this.emitZoneAwareEvent("onDrag", event).isDefaultPrevented();
    if (isDragPrevented$1) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event) {
    if (this.dragStarted) {
      this.positionsMap.set(this.currentDragTargetElement, this.position);
    }
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
    }
    this.pressed = false;
    this.prevUserSelect ? this.renderer.setStyle(this.currentDragTargetElement, "user-select", this.prevUserSelect) : this.renderer.removeStyle(this.currentDragTargetElement, "user-select");
    this.prevUserSelect = null;
    this.emitZoneAwareEvent("onRelease", event);
  }
  handleDragEnd(event) {
    if (!this.dragStarted) {
      return;
    }
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent2(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent2(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.positionsMap.delete(this.currentDragTargetElement);
      }
    }
    if (this.hint && isPresent2(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.currentDragTargetElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragIndex = null;
    this.currentDragTarget.element = null;
    this.emitZoneAwareEvent("onDragEnd", event);
    if (isDragStartPrevented$1 || isDragPrevented$1) {
      return;
    }
    this.dragStarted = false;
  }
  get nativeElement() {
    return this.wrapper.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent2(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  removeListeners() {
    if (isPresent2(this.scrollableParent)) {
      this.scrollableParent.removeEventListener("scroll", this.onPointerMove);
    }
    const element = this.nativeElement;
    if (!isDocumentAvailable()) {
      return;
    }
    document.removeEventListener("pointermove", this.onPointerMove);
    document.removeEventListener("pointerup", this.onPointerUp, true);
    document.removeEventListener("pointercancel", this.onPointerUp);
    document.removeEventListener("contextmenu", this.onContextMenu);
    window.removeEventListener("touchmove", noop2);
    element.removeEventListener("touchmove", this.onTouchMove);
    element.removeEventListener("touchend", this.onPointerUp);
    document.removeEventListener("mousemove", this.onPointerMove);
    document.removeEventListener("mouseup", this.onPointerUp);
    document.removeEventListener("touchcancel", this.onPointerUp);
    element.removeEventListener("pointerdown", this.onPointerDown);
    element.removeEventListener("mousedown", this.onPointerDown);
    element.removeEventListener("touchstart", this.onTouchStart);
  }
  get supportPointerEvent() {
    return Boolean(typeof window !== "undefined" && window.PointerEvent);
  }
  subscribe() {
    this.ngZone.runOutsideAngular(() => {
      this.removeListeners();
      if (!(isDocumentAvailable() && isPresent2(this.wrapper))) {
        return;
      }
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      const element = this.nativeElement;
      if (this.supportPointerEvent) {
        if (isPresent2(this.scrollableParent)) {
          this.scrollableParent.addEventListener("scroll", this.onPointerMove, {
            passive: true
          });
        }
        element.addEventListener("pointerdown", this.onPointerDown, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("pointermove", this.onPointerMove);
          document.addEventListener("pointerup", this.onPointerUp, true);
          document.addEventListener("contextmenu", this.onContextMenu);
          document.addEventListener("pointercancel", this.onPointerUp, {
            passive: true
          });
        }
      } else {
        window.addEventListener("touchmove", noop2, {
          capture: false,
          passive: false
        });
        element.addEventListener("mousedown", this.onPointerDown, {
          passive: true
        });
        element.addEventListener("touchstart", this.onTouchStart, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("mousemove", this.onPointerMove, {
            passive: true
          });
          document.addEventListener("mouseup", this.onPointerUp, {
            passive: true
          });
          element.addEventListener("touchmove", this.onTouchMove, {
            passive: true
          });
          element.addEventListener("touchend", this.onPointerUp, {
            passive: true
          });
        }
      }
    });
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const targetIdArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetIndex: this.service.dragIndex
    };
    const eventProps = {
      dragTarget: this.currentDragTargetElement,
      dragEvent: normalizedEvent,
      dragTargetIndex: this.service.dragIndex,
      dragTargetId: this.dragTargetId(targetIdArgs)
    };
    if (this.hint && isPresent2(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    let eventArgs;
    switch (event) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
    return eventArgs;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent2(this.wrapper))) {
      return;
    }
    if (isPresent2(this.hint) && typeof this.hint === "object") {
      if (isPresent2(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.currentDragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.currentDragTargetElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent2(this.hint.hintClass)) {
        const hintClasses = parseCSSClassNames(this.hint.hintClass);
        hintClasses.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent2(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.instance.targetIndex = this.service.dragIndex;
    const targetDataArgs = {
      dragTarget: this.currentDragTargetElement,
      dragTargetId: this.service.dragTargetId,
      dragTargetIndex: this.service.dragIndex
    };
    this.hintComponent.instance.contextData = this.dragData(targetDataArgs);
    this.hintComponent.instance.customContext = this.hintContext;
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent2(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      document.body.removeChild(this.defaultHint);
      this.defaultHint = null;
    }
    this.currentDragTarget.hint = null;
  }
  getDragIndex() {
    return this.allDragTargets.indexOf(this.currentDragTargetElement);
  }
  initializeDragTargets() {
    if (!isPresent2(this.allDragTargets)) {
      if (this.previousDragTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDragTargets.forEach((dragTargetEl) => {
      const isDragTargetInitialized = this.service.dragTargets.find((dt) => dt.element === dragTargetEl);
      if (!isDragTargetInitialized) {
        this.service.dragTargets.push({
          element: dragTargetEl,
          hint: null,
          onPress: this.handlePress.bind(this),
          onRelease: this.handleRelease.bind(this),
          onDragStart: this.handleDragStart.bind(this),
          onDrag: this.handleDrag.bind(this),
          onDragEnd: this.handleDragEnd.bind(this)
        });
      }
    });
    if (this.previousDragTargets.length > 0) {
      const dragTargetsToRemove = this.previousDragTargets.filter((dt) => !this.allDragTargets.includes(dt));
      dragTargetsToRemove.forEach((dragTarget) => {
        const idx = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
        if (idx > -1) {
          this.service.dragTargets.splice(idx, 1);
        }
      });
    }
    this.previousDragTargets = this.allDragTargets;
    this.currentDragTarget = {
      element: null,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
    this.setTargetStyles();
  }
  isDragHandle(el) {
    return this.dragHandles.some((dh) => contains(dh, el, true));
  }
  get isHandleSelectorValid() {
    return isPresent2(this.dragHandle) && this.dragHandle !== "";
  }
  setTargetStyles() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (isPresent2(this.dragHandle) && this.dragHandle !== "") {
      if (isPresent2(this.dragHandles) && this.dragHandles.length > 0) {
        this.dragHandles.forEach((handle) => {
          this.renderer.setStyle(handle, "cursor", this.cursorStyle);
          this.renderer.setStyle(handle, "touch-action", "none");
        });
      }
    } else {
      this.allDragTargets.forEach((target) => {
        this.renderer.setStyle(target, "cursor", this.cursorStyle);
        this.renderer.setStyle(target, "touch-action", "none");
      });
    }
  }
  queryHost(selector) {
    if (isPresent2(selector) && selector !== "") {
      return Array.from(this.nativeElement.querySelectorAll(selector));
    }
  }
  clearPreviousTargets() {
    this.previousDragTargets.forEach((dragTarget) => {
      const idx = this.service.dragTargets.findIndex((serviceDragTarget) => serviceDragTarget.element === dragTarget);
      if (idx > -1) {
        this.service.dragTargets.splice(idx, 1);
      }
    });
    this.previousDragTargets = [];
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event) {
    let position = null;
    if (!isDocumentAvailable()) {
      return {
        x: 0,
        y: 0
      };
    }
    if (element === this.hintElem) {
      position = {
        x: event.clientX + window.scrollX,
        y: event.clientY + window.scrollY
      };
    } else {
      position = {
        x: event.clientX - this.initialPosition.x + event.scrollX,
        y: event.clientY - this.initialPosition.y + event.scrollY
      };
    }
    return position;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      return {
        top: `${this.position.y}px`,
        left: `${this.position.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform2 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform2,
        transition: "none"
      };
    }
  }
  static ɵfac = function DragTargetContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragTargetContainerDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragTargetContainerDirective,
    selectors: [["", "kendoDragTargetContainer", ""]],
    inputs: {
      hint: "hint",
      dragTargetFilter: "dragTargetFilter",
      dragHandle: "dragHandle",
      dragDelay: "dragDelay",
      threshold: "threshold",
      dragTargetId: "dragTargetId",
      dragData: "dragData",
      dragDisabled: "dragDisabled",
      mode: "mode",
      cursorStyle: "cursorStyle",
      hintContext: "hintContext"
    },
    outputs: {
      onDragReady: "onDragReady",
      onPress: "onPress",
      onDragStart: "onDragStart",
      onDrag: "onDrag",
      onRelease: "onRelease",
      onDragEnd: "onDragEnd"
    },
    exportAs: ["kendoDragTargetContainer"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTargetContainer]",
      exportAs: "kendoDragTargetContainer",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hint: [{
      type: Input
    }],
    dragTargetFilter: [{
      type: Input
    }],
    dragHandle: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    dragDisabled: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    cursorStyle: [{
      type: Input
    }],
    hintContext: [{
      type: Input
    }],
    onDragReady: [{
      type: Output
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }]
  });
})();
var isDragStartPrevented = false;
var isDragPrevented = false;
var DragTargetDirective = class _DragTargetDirective {
  element;
  renderer;
  ngZone;
  service;
  viewContainer;
  get touchActionStyle() {
    return this.dragHandles.length > 0 ? null : "none";
  }
  /**
   * Defines whether a hint will be used for dragging. By default, the hint is a copy of the drag target. ([see example]({% slug drag_hint %})).
   *
   * @default false
   */
  hint = false;
  /**
   * Sets the number of pixels the pointer must move before dragging starts. Applies when `manualDrag` is `false`. [See example]({% slug minimum_distance %}).
   *
   * @default 0
   */
  threshold = 0;
  /**
   * Sets the automatic container scrolling behavior when close to the edge. [See example]({% slug auto_scroll %}).
   *
   * @default true
   */
  autoScroll = true;
  /**
   * Sets a unique identifier for the drag target.
   */
  dragTargetId;
  /**
   * Sets the delay in milliseconds before dragging begins. [See example]({% slug drag_delay %}).
   *
   * @default 0
   */
  dragDelay = 0;
  /**
   * Restricts dragging to horizontal or vertical only. Applies when `mode` is `auto`. [See example]({% slug axis_lock %}).
   */
  restrictByAxis;
  /**
   * Specifies whether to use the default dragging behavior or handle it manually.
   *
   * @default 'auto'
   */
  mode = "auto";
  /**
   * Defines a callback function used for attaching custom data to the drag target.
   * The data is available in the events of the respective [`DropTarget`]({% slug api_utils_droptargetdirective %}) or [`DropTargetContainer`]({% slug api_utils_droptargetcontainerdirective %}) directives.
   * The current DragTarget HTML element and its `dragTargetId` will be available as arguments.
   */
  set dragData(fn) {
    if (isDevMode && typeof fn !== "function") {
      throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this._dragData = fn;
  }
  get dragData() {
    return this._dragData;
  }
  /**
   * Sets the cursor style of the drag target. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
   *
   * @default 'move'
   */
  cursorStyle = "move";
  /**
   * Fires when the user presses the drag target element.
   */
  onPress = new EventEmitter();
  /**
   * Fires when dragging of the drag target element begins.
   */
  onDragStart = new EventEmitter();
  /**
   * Fires while the user drags the drag target element.
   */
  onDrag = new EventEmitter();
  /**
   * Fires when the drag target's `dragDelay` has passed and the user can drag the element.
   */
  onDragReady = new EventEmitter();
  /**
   * Fires when `DragTarget` is released, either by dropping it on a drop target or by releasing the mouse button.
   */
  onRelease = new EventEmitter();
  /**
   * Fires when dragging of the drag target ends and the element is released.
   */
  onDragEnd = new EventEmitter();
  dragTarget = null;
  hintComponent = null;
  dragStarted = false;
  pressed = false;
  dragReady = false;
  dragTimeout = null;
  initialPosition = {
    x: 0,
    y: 0
  };
  position = {
    x: 0,
    y: 0
  };
  scrollableParent = null;
  defaultHint = null;
  _dragData = () => null;
  prevUserSelect;
  get hintTemplate() {
    return isPresent2(this.hint) && typeof this.hint === "object" ? this.hint.hintTemplate : null;
  }
  get nativeElement() {
    return this.element.nativeElement;
  }
  get hintElem() {
    return this.hintTemplate && isPresent2(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
  }
  onPointerDown(event) {
    if (this.dragHandles.length && !this.isDragHandle(event.target)) {
      return;
    }
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.service.autoScroll = typeof this.autoScroll === "object" ? this.autoScroll.enabled !== false : this.autoScroll;
    this.service.scrollableParent = this.getAutoScrollContainer();
    this.service.autoScrollDirection = typeof this.autoScroll === "object" ? this.autoScroll.direction : {
      horizontal: true,
      vertical: true
    };
    this.attachDomHandlers();
  }
  onTouchStart(event) {
    if (this.dragHandles.length && !this.isDragHandle(event.target)) {
      return;
    }
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.service.autoScroll = typeof this.autoScroll === "object" ? this.autoScroll.enabled !== false : this.autoScroll;
    this.service.scrollableParent = this.getAutoScrollContainer();
    this.service.autoScrollDirection = typeof this.autoScroll === "object" ? this.autoScroll.direction : {
      horizontal: true,
      vertical: true
    };
    this.attachDomHandlers();
  }
  onPointerMove(event) {
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
  }
  onTouchMove(event) {
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
  }
  onPointerUp(event) {
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.attachDomHandlers();
  }
  onContextMenu(event) {
    event.preventDefault();
    const action = getAction(event, this.dragTarget);
    this.service.handleDragAndDrop(action);
    this.attachDomHandlers();
  }
  dragHandles;
  constructor(element, renderer, ngZone, service, viewContainer) {
    this.element = element;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.service = service;
    this.viewContainer = viewContainer;
    validatePackage(packageMetadata);
  }
  ngOnInit() {
    this.initializeDragTarget();
  }
  ngAfterContentInit() {
    if (isPresent2(this.element) || isPresent2(this.dragTarget)) {
      this.attachDomHandlers();
      if (!this.dragHandles.length) {
        this.renderer.setStyle(this.nativeElement, "cursor", this.cursorStyle);
      }
    }
    this.service.dragTargets.push(this.dragTarget);
  }
  ngOnDestroy() {
    this.removeListeners();
    const currentDragTargetIndex = this.service.dragTargets.indexOf(this.dragTarget);
    this.service.dragTargets.splice(currentDragTargetIndex, 1);
  }
  handlePress(event) {
    this.pressed = true;
    if (this.dragDelay > 0) {
      this.dragTimeout = window.setTimeout(() => {
        this.dragReady = true;
        this.emitZoneAwareEvent("onDragReady", event);
      }, this.dragDelay);
    } else {
      this.dragReady = true;
    }
    this.scrollableParent = this.dragTarget.element ? getScrollableParent(this.dragTarget.element) : null;
    this.prevUserSelect = this.dragTarget.element.style.userSelect;
    this.renderer.setStyle(this.dragTarget.element, "user-select", "none");
    this.emitZoneAwareEvent("onPress", event);
  }
  handleDragStart(event) {
    if (!this.pressed) {
      if (this.dragTimeout) {
        window.clearTimeout(this.dragTimeout);
        this.dragTimeout = null;
      }
      return;
    }
    if (!this.dragReady) {
      return;
    }
    isDragStartPrevented = this.emitZoneAwareEvent("onDragStart", event).isDefaultPrevented();
    if (isDragStartPrevented) {
      return;
    }
    if (this.hint) {
      this.createHint();
      if (this.mode === "auto") {
        this.renderer.setStyle(this.nativeElement, "opacity", "0.7");
      }
      this.initialPosition = {
        x: event.offsetX,
        y: event.offsetY
      };
    } else {
      this.initialPosition = {
        x: event.clientX - this.position.x,
        y: event.clientY - this.position.y
      };
    }
    this.dragStarted = this.threshold === 0;
    this.service.dragTarget = this.dragTarget;
    this.service.dragTargetDirective = this;
    this.service.dragData = this.dragData({
      dragTarget: this.dragTarget.element,
      dragTargetId: this.dragTargetIdResult,
      dragTargetIndex: null
    });
  }
  handleDrag(event) {
    if (!this.pressed || !this.dragReady || isDragStartPrevented) {
      return;
    }
    const elem = this.hint ? this.hintElem : this.nativeElement;
    this.position = this.calculatePosition(elem, event);
    const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
    if (!this.dragStarted && thresholdNotReached) {
      return;
    }
    if (!this.dragStarted && this.threshold > 0) {
      this.dragStarted = true;
    }
    isDragPrevented = this.emitZoneAwareEvent("onDrag", event).isDefaultPrevented();
    if (isDragPrevented) {
      return;
    }
    if (this.mode === "auto") {
      this.performDrag();
    } else {
      this.dragStarted = true;
    }
  }
  handleRelease(event) {
    if (this.dragTimeout) {
      clearTimeout(this.dragTimeout);
      this.dragTimeout = null;
    }
    this.pressed = false;
    this.dragReady = false;
    this.prevUserSelect ? this.renderer.setStyle(this.dragTarget.element, "user-select", this.prevUserSelect) : this.renderer.removeStyle(this.dragTarget.element, "user-select");
    this.prevUserSelect = null;
    this.emitZoneAwareEvent("onRelease", event);
  }
  handleDragEnd(event) {
    if (this.mode === "auto") {
      const isDroppedOverParentTarget = isPresent2(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
      const elem = this.hint ? this.hintElem : this.nativeElement;
      if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent2(elem)) {
        this.renderer.removeStyle(elem, "transform");
        setElementStyles(this.renderer, elem, {
          transition: dragTargetTransition
        });
        this.position = {
          x: 0,
          y: 0
        };
      }
    }
    if (this.hint && isPresent2(this.hintElem)) {
      this.destroyHint();
      if (this.mode === "auto") {
        this.renderer.removeStyle(this.nativeElement, "opacity");
      }
    }
    this.service.dragTarget = null;
    this.service.dragTargetDirective = null;
    if (!this.dragStarted || isDragStartPrevented || isDragPrevented) {
      return;
    }
    this.emitZoneAwareEvent("onDragEnd", event);
    this.dragStarted = false;
  }
  initializeDragTarget() {
    this.dragTarget = {
      element: this.nativeElement,
      hint: null,
      onPress: this.handlePress.bind(this),
      onRelease: this.handleRelease.bind(this),
      onDragStart: this.handleDragStart.bind(this),
      onDrag: this.handleDrag.bind(this),
      onDragEnd: this.handleDragEnd.bind(this)
    };
  }
  get supportPointerEvent() {
    return Boolean(typeof window !== "undefined" && window.PointerEvent);
  }
  removeListeners() {
    if (isPresent2(this.scrollableParent)) {
      this.scrollableParent.removeEventListener("scroll", this.onPointerMove);
    }
    const element = this.nativeElement;
    if (!isDocumentAvailable()) {
      return;
    }
    document.removeEventListener("pointermove", this.onPointerMove);
    document.removeEventListener("pointerup", this.onPointerUp, true);
    document.removeEventListener("contextmenu", this.onContextMenu);
    document.removeEventListener("pointercancel", this.onPointerUp);
    window.removeEventListener("touchmove", noop2);
    element.removeEventListener("touchmove", this.onTouchMove);
    element.removeEventListener("touchend", this.onPointerUp);
    document.removeEventListener("mousemove", this.onPointerMove);
    document.removeEventListener("mouseup", this.onPointerUp);
    document.removeEventListener("touchcancel", this.onPointerUp);
    element.removeEventListener("pointerdown", this.onPointerDown);
    element.removeEventListener("mousedown", this.onPointerDown);
    element.removeEventListener("touchstart", this.onTouchStart);
  }
  attachDomHandlers() {
    this.ngZone.runOutsideAngular(() => {
      this.removeListeners();
      if (!(isDocumentAvailable() && isPresent2(this.element))) {
        return;
      }
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onContextMenu = this.onContextMenu.bind(this);
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      const element = this.nativeElement;
      if (this.supportPointerEvent) {
        if (isPresent2(this.scrollableParent)) {
          if (this.scrollableParent === document.getElementsByTagName("html")[0]) {
            this.scrollableParent = window;
          }
          this.scrollableParent.addEventListener("scroll", this.onPointerMove, {
            passive: true
          });
        }
        element.addEventListener("pointerdown", this.onPointerDown, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("pointermove", this.onPointerMove);
          document.addEventListener("pointerup", this.onPointerUp, true);
          document.addEventListener("contextmenu", this.onContextMenu);
          document.addEventListener("pointercancel", this.onPointerUp, {
            passive: true
          });
        }
      } else {
        window.addEventListener("touchmove", noop2, {
          capture: false,
          passive: false
        });
        element.addEventListener("mousedown", this.onPointerDown, {
          passive: true
        });
        element.addEventListener("touchstart", this.onTouchStart, {
          passive: true
        });
        if (this.pressed) {
          document.addEventListener("mousemove", this.onPointerMove, {
            passive: true
          });
          document.addEventListener("mouseup", this.onPointerUp, {
            passive: true
          });
          element.addEventListener("touchmove", this.onTouchMove, {
            passive: true
          });
          element.addEventListener("touchend", this.onPointerUp, {
            passive: true
          });
        }
      }
    });
  }
  isDragHandle(el) {
    return this.dragHandles.toArray().some((dh) => contains(dh.element.nativeElement, el, true));
  }
  getAutoScrollContainer() {
    return typeof this.autoScroll === "object" && this.autoScroll.boundaryElementRef && this.autoScroll.boundaryElementRef.nativeElement ? this.autoScroll.boundaryElementRef.nativeElement : null;
  }
  createHint() {
    if (!(isDocumentAvailable() && isPresent2(this.element))) {
      return;
    }
    if (isPresent2(this.hint) && typeof this.hint === "object") {
      if (isPresent2(this.hint.hintTemplate)) {
        this.createCustomHint();
      } else {
        this.createDefaultHint();
      }
    } else {
      this.createDefaultHint();
    }
    this.dragTarget.hint = this.hintElem;
    if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
      this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
    } else {
      document.body.appendChild(this.hintElem);
    }
  }
  createDefaultHint() {
    this.defaultHint = this.nativeElement.cloneNode(true);
    if (typeof this.hint === "object") {
      if (isPresent2(this.hint.hintClass)) {
        const hintClasses = parseCSSClassNames(this.hint.hintClass);
        hintClasses.forEach((className) => this.renderer.addClass(this.defaultHint, className));
      }
    }
  }
  createCustomHint() {
    if (isPresent2(this.hint.appendTo)) {
      this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
    } else {
      this.hintComponent = this.viewContainer.createComponent(HintComponent);
    }
    this.hintComponent.instance.template = this.hintTemplate;
    this.hintComponent.instance.directive = this;
    this.hintComponent.changeDetectorRef.detectChanges();
  }
  destroyHint() {
    if (isPresent2(this.hintTemplate)) {
      this.hintComponent.destroy();
      this.hintComponent.changeDetectorRef.detectChanges();
      this.hintComponent = null;
    } else {
      if (typeof this.hint === "object" && isPresent2(this.hint.appendTo)) {
        this.hint.appendTo.element.nativeElement.removeChild(this.defaultHint);
      } else {
        document.body.removeChild(this.defaultHint);
      }
      this.defaultHint = null;
    }
    this.dragTarget.hint = null;
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dragTarget: this.nativeElement,
      dragEvent: normalizedEvent
    };
    if (this.hint && isPresent2(this.hintElem)) {
      eventProps.hintElement = this.hintElem;
    }
    if (this.dragTargetId && this.dragTargetId !== "") {
      eventProps.dragTargetId = this.dragTargetIdResult;
    }
    let eventArgs;
    switch (event) {
      case "onDragReady":
        eventArgs = new DragTargetDragReadyEvent(eventProps);
        break;
      case "onPress":
        eventArgs = new DragTargetPressEvent(eventProps);
        break;
      case "onDragStart":
        eventArgs = new DragTargetDragStartEvent(eventProps);
        break;
      case "onDrag":
        eventArgs = new DragTargetDragEvent(eventProps);
        break;
      case "onRelease":
        eventArgs = new DragTargetReleaseEvent(eventProps);
        break;
      case "onDragEnd":
        eventArgs = new DragTargetDragEndEvent(eventProps);
        break;
      default:
        break;
    }
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
    return eventArgs;
  }
  get dragTargetIdResult() {
    if (this.dragTargetId && this.dragTargetId !== "") {
      return typeof this.dragTargetId === "string" ? this.dragTargetId : this.dragTargetId({
        dragTarget: this.dragTarget.element,
        dragTargetIndex: null
      });
    }
  }
  performDrag() {
    const elem = this.hint ? this.hintElem : this.nativeElement;
    if (elem) {
      const styles = this.getStylesPerElement(elem);
      setElementStyles(this.renderer, elem, styles);
    }
  }
  calculatePosition(element, event) {
    let position = null;
    if (element === this.hintElem) {
      position = {
        x: event.clientX + window.scrollX,
        y: event.clientY + window.scrollY
      };
    } else {
      position = {
        x: event.clientX - this.initialPosition.x + event.scrollX,
        y: event.clientY - this.initialPosition.y + event.scrollY
      };
    }
    if (this.restrictByAxis === "horizontal") {
      position.y = 0;
    } else if (this.restrictByAxis === "vertical") {
      position.x = 0;
    }
    return position;
  }
  getStylesPerElement(element) {
    if (element === this.hintElem) {
      const hintCoordinates = {
        x: this.position.x - this.initialPosition.x,
        y: this.position.y - this.initialPosition.y
      };
      return {
        top: `${hintCoordinates.y}px`,
        left: `${hintCoordinates.x}px`,
        transition: "none",
        position: "absolute",
        zIndex: 1999
      };
    } else {
      const transform2 = `translate(${this.position.x}px, ${this.position.y}px)`;
      return {
        transform: transform2,
        transition: "none"
      };
    }
  }
  static ɵfac = function DragTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragTargetDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ViewContainerRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragTargetDirective,
    selectors: [["", "kendoDragTarget", ""]],
    contentQueries: function DragTargetDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DragHandleDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragHandles = _t);
      }
    },
    hostVars: 2,
    hostBindings: function DragTargetDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("touch-action", ctx.touchActionStyle);
      }
    },
    inputs: {
      hint: "hint",
      threshold: "threshold",
      autoScroll: "autoScroll",
      dragTargetId: "dragTargetId",
      dragDelay: "dragDelay",
      restrictByAxis: "restrictByAxis",
      mode: "mode",
      dragData: "dragData",
      cursorStyle: "cursorStyle"
    },
    outputs: {
      onPress: "onPress",
      onDragStart: "onDragStart",
      onDrag: "onDrag",
      onDragReady: "onDragReady",
      onRelease: "onRelease",
      onDragEnd: "onDragEnd"
    },
    exportAs: ["kendoDragTarget"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDragTarget]",
      exportAs: "kendoDragTarget",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: DragStateService
    }, {
      type: ViewContainerRef
    }];
  }, {
    touchActionStyle: [{
      type: HostBinding,
      args: ["style.touch-action"]
    }],
    hint: [{
      type: Input
    }],
    threshold: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragTargetId: [{
      type: Input
    }],
    dragDelay: [{
      type: Input
    }],
    restrictByAxis: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    cursorStyle: [{
      type: Input
    }],
    onPress: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }],
    onDrag: [{
      type: Output
    }],
    onDragReady: [{
      type: Output
    }],
    onRelease: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    dragHandles: [{
      type: ContentChildren,
      args: [DragHandleDirective, {
        descendants: true
      }]
    }]
  });
})();
var DropTargetEvent = class {
  /**
   * The current drag target element.
   */
  dragTarget;
  /**
   * The current drop target element.
   */
  dropTarget;
  /**
   * The information related to the current drag event.
   */
  dragEvent;
  /**
   * The data passed to the `dragData` input property of the `DragTarget` or `DragTargetContainer` directive.
   */
  dragData;
  /**
   * The index of the current drop target in the collection of drop targets. Applies to `DropTargetContainer` directive.
   */
  dropTargetIndex;
  /**
   * The hint element of the `DragTarget`.
   */
  hintElement;
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get normalizedEvent() {
    return this.dragEvent;
  }
  /**
   * Left for backward compatibility for the DropTarget deprecated events.
   * @hidden
   */
  get hostElement() {
    return this.dropTarget;
  }
  /**
   * @hidden
   */
  constructor(args) {
    Object.assign(this, args);
  }
};
var DropTargetContainerDirective = class _DropTargetContainerDirective {
  service;
  element;
  ngZone;
  cdr;
  /**
   * Sets a selector for elements in the container to make them drop targets. [See example]({% slug drop_target_container %}).
   */
  set dropTargetFilter(value) {
    this._dropTargetFilter = value;
    if (!this.dropDisabled) {
      this.initializeDropTargets();
    }
  }
  get dropTargetFilter() {
    return this._dropTargetFilter;
  }
  /**
   * Specifies whether the drop targets within the container will emit the corresponding events upon interaction with a drag target.
   */
  set dropDisabled(value) {
    this._dropDisabled = value;
    if (value) {
      this.clearPreviousTargets();
    } else {
      this.initializeDropTargets();
    }
  }
  get dropDisabled() {
    return this._dropDisabled;
  }
  /**
   * Fires when a drag target enters a drop target.
   */
  onDragEnter = new EventEmitter();
  /**
   * Fires when a drag target is dragged over a drop target.
   */
  onDragOver = new EventEmitter();
  /**
   * Fires when a drag target leaves a drop target.
   */
  onDragLeave = new EventEmitter();
  /**
   * Fires when a drag target is dropped over a drop target.
   */
  onDrop = new EventEmitter();
  /**
   * Notifies the `DropTargetContainer` that its content has changed.
   */
  notify() {
    this.cdr.detectChanges();
    this.initializeDropTargets();
  }
  constructor(service, element, ngZone, cdr) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    this.cdr = cdr;
    validatePackage(packageMetadata);
  }
  currentDropTargetElement = null;
  previousDropTargets = [];
  _dropTargetFilter = null;
  _dropDisabled = false;
  get nativeElement() {
    return this.element.nativeElement;
  }
  ngAfterViewInit() {
    !this.dropDisabled && this.initializeDropTargets();
  }
  get allDropTargets() {
    if (isPresent2(this.dropTargetFilter) && this.dropTargetFilter !== "") {
      return Array.from(this.nativeElement.querySelectorAll(this.dropTargetFilter));
    }
  }
  /**
   * @hidden
   */
  handleDragEnter(event) {
    if (!this.service.dragTargetPresent || this.service.dropTargetPresent) {
      return;
    }
    const currDragTargetElement = this.service.dragTarget.hint || this.service.dragTarget.element;
    const currDropTargetElem = intersect2(currDragTargetElement, this.allDropTargets);
    const currDropTarget = this.service.dropTargets.find((dt) => dt.element === currDropTargetElem);
    if (!isPresent2(currDropTargetElem) || !isPresent2(currDropTarget)) {
      return;
    }
    this.currentDropTargetElement = currDropTargetElem;
    this.service.dropTarget = currDropTarget;
    this.service.dropIndex = this.getDropIndex();
    this.emitZoneAwareEvent("onDragEnter", event);
  }
  /**
   * @hidden
   */
  handleDragLeave(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  /**
   * @hidden
   */
  handleDragOver(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event);
  }
  /**
   * @hidden
   */
  handleDrop(event) {
    if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
      return;
    }
    this.emitZoneAwareEvent("onDrop", event);
    this.currentDropTargetElement = null;
    this.service.dropTarget = null;
    this.service.dropIndex = null;
  }
  initializeDropTargets() {
    if (!isPresent2(this.allDropTargets)) {
      if (this.previousDropTargets.length > 0) {
        this.clearPreviousTargets();
      }
      return;
    }
    this.allDropTargets.forEach((dropTargetEl) => {
      const isDropTargetInitialized = this.service.dropTargets.find((dt) => dt.element === dropTargetEl);
      if (!isDropTargetInitialized) {
        this.service.dropTargets.push({
          element: dropTargetEl,
          onDragEnter: this.handleDragEnter.bind(this),
          onDragLeave: this.handleDragLeave.bind(this),
          onDragOver: this.handleDragOver.bind(this),
          onDrop: this.handleDrop.bind(this)
        });
      }
    });
    if (this.previousDropTargets.length > 0) {
      const dropTargetsToRemove = this.previousDropTargets.filter((dt) => !this.allDropTargets.includes(dt));
      dropTargetsToRemove.forEach((dropTarget) => {
        const idx = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
        if (idx > -1) {
          this.service.dropTargets.splice(idx, 1);
        }
      });
    }
    this.previousDropTargets = this.allDropTargets;
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dragTarget: this.service.dragTarget?.element,
      dropTarget: this.currentDropTargetElement,
      dragData: this.service.dragData,
      dragEvent: normalizedEvent,
      dropTargetIndex: this.service.dropIndex
    };
    if (isPresent2(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.hint;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
  }
  getDropIndex() {
    return this.allDropTargets.indexOf(this.currentDropTargetElement);
  }
  clearPreviousTargets() {
    this.previousDropTargets.forEach((dropTarget) => {
      const idx = this.service.dropTargets.findIndex((serviceDropTarget) => serviceDropTarget.element === dropTarget);
      if (idx > -1) {
        this.service.dropTargets.splice(idx, 1);
      }
    });
    this.previousDropTargets = [];
  }
  static ɵfac = function DropTargetContainerDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropTargetContainerDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetContainerDirective,
    selectors: [["", "kendoDropTargetContainer", ""]],
    inputs: {
      dropTargetFilter: "dropTargetFilter",
      dropDisabled: "dropDisabled"
    },
    outputs: {
      onDragEnter: "onDragEnter",
      onDragOver: "onDragOver",
      onDragLeave: "onDragLeave",
      onDrop: "onDrop"
    },
    exportAs: ["kendoDropTargetContainer"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetContainerDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTargetContainer]",
      exportAs: "kendoDropTargetContainer",
      standalone: true
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    dropTargetFilter: [{
      type: Input
    }],
    dropDisabled: [{
      type: Input
    }],
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var DropTargetDirective = class _DropTargetDirective {
  service;
  element;
  ngZone;
  /**
   * Fires when a drag target enters the drop target.
   */
  onDragEnter = new EventEmitter();
  /**
   * Fires when a drag target is dragged over the drop target.
   */
  onDragOver = new EventEmitter();
  /**
   * Fires when a drag target leaves the drop target.
   */
  onDragLeave = new EventEmitter();
  /**
   * Fires when a drag target is dropped over the drop target.
   */
  onDrop = new EventEmitter();
  constructor(service, element, ngZone) {
    this.service = service;
    this.element = element;
    this.ngZone = ngZone;
    validatePackage(packageMetadata);
  }
  dropTarget;
  ngOnInit() {
    this.initializeDropTarget();
    this.service.dropTargets.push(this.dropTarget);
  }
  ngOnDestroy() {
    const currentDropTargetIndex = this.service.dropTargets.indexOf(this.dropTarget);
    this.service.dropTargets.splice(currentDropTargetIndex, 1);
  }
  /**
   * @hidden
   */
  handleDragEnter(event) {
    if (!this.service.dragTarget) {
      return;
    }
    this.service.dropTarget = this.dropTarget;
    this.emitZoneAwareEvent("onDragEnter", event);
  }
  /**
   * @hidden
   */
  handleDragLeave(event) {
    this.service.dropTarget = null;
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragLeave", event);
  }
  /**
   * @hidden
   */
  handleDragOver(event) {
    if (!this.service.dragTarget) {
      return;
    }
    this.emitZoneAwareEvent("onDragOver", event);
  }
  /**
   * @hidden
   */
  handleDrop(event) {
    this.emitZoneAwareEvent("onDrop", event);
    this.service.dropTarget = null;
  }
  initializeDropTarget() {
    this.dropTarget = {
      element: this.element.nativeElement,
      onDragEnter: this.handleDragEnter.bind(this),
      onDragLeave: this.handleDragLeave.bind(this),
      onDragOver: this.handleDragOver.bind(this),
      onDrop: this.handleDrop.bind(this)
    };
  }
  emitZoneAwareEvent(event, normalizedEvent) {
    const eventProps = {
      dropTarget: this.element.nativeElement,
      dragTarget: this.service.dragTarget?.element,
      dragEvent: normalizedEvent,
      dragData: this.service.dragData
    };
    if (isPresent2(this.service.dragTarget?.hint)) {
      eventProps.hintElement = this.service.dragTarget.element;
    }
    const eventArgs = new DropTargetEvent(eventProps);
    this.ngZone.run(() => {
      this[event].emit(eventArgs);
    });
  }
  static ɵfac = function DropTargetDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropTargetDirective)(ɵɵdirectiveInject(DragStateService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropTargetDirective,
    selectors: [["", "kendoDropTarget", ""]],
    outputs: {
      onDragEnter: "onDragEnter",
      onDragOver: "onDragOver",
      onDragLeave: "onDragLeave",
      onDrop: "onDrop"
    },
    exportAs: ["kendoDropTarget"],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropTargetDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropTarget]",
      exportAs: "kendoDropTarget",
      standalone: true
    }]
  }], function() {
    return [{
      type: DragStateService
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    onDragEnter: [{
      type: Output
    }],
    onDragOver: [{
      type: Output
    }],
    onDragLeave: [{
      type: Output
    }],
    onDrop: [{
      type: Output
    }]
  });
})();
var KENDO_DRAGANDDROP = [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent];
var KENDO_UTILS = [...KENDO_DRAGANDDROP];
var UtilsModule = class _UtilsModule {
  static ɵfac = function UtilsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UtilsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _UtilsModule,
    imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent],
    exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UtilsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_UTILS],
      imports: [...KENDO_UTILS]
    }]
  }], null, null);
})();
var DragAndDropModule = class _DragAndDropModule {
  static ɵfac = function DragAndDropModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DragAndDropModule,
    imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent],
    exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DRAGANDDROP],
      imports: [...KENDO_DRAGANDDROP]
    }]
  }], null, null);
})();
var AdaptiveSettingsService = class _AdaptiveSettingsService {
  /**
   * @hidden
   */
  changes = new Subject();
  /**
   * Notifies subscribers that the adaptive settings have changed.
   *
   * @param adaptiveSettings - (Optional) A new value for the adaptive settings token.
   */
  notify(adaptiveSettings) {
    this.changes.next(adaptiveSettings);
  }
  static ɵfac = function AdaptiveSettingsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveSettingsService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveSettingsService,
    factory: _AdaptiveSettingsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveSettingsService, [{
    type: Injectable
  }], null, null);
})();
var ADAPTIVE_SETTINGS = new InjectionToken("Kendo UI Adaptive-Settings token");
var DEFAULT_ADAPTIVE_SETTINGS = {
  small: 500,
  medium: 768
};
var AdaptiveService = class _AdaptiveService {
  _adaptiveSettings;
  zone;
  /**
   * Notifies subscribers of the initial adaptive settings, and upon each call to `notify`.
   * @hidden
   */
  changes = new BehaviorSubject(this.adaptiveSettings || {
    small: 500,
    medium: 700
  });
  /**
   * Notifies subscribers when the window size changes to any of small, medium, or large depending on the set adaptive size breakpoints.
   * @hidden
   */
  sizeChanges = new BehaviorSubject(this.size);
  subs = new Subscription();
  previousSize;
  constructor(_adaptiveSettings, adaptiveSettingsService, zone) {
    this._adaptiveSettings = _adaptiveSettings;
    this.zone = zone;
    if (adaptiveSettingsService) {
      this.subs.add(adaptiveSettingsService.changes.pipe(map((adaptiveSettings) => isPresent(adaptiveSettings) ? adaptiveSettings : this._adaptiveSettings), tap((adaptiveSettings) => this._adaptiveSettings = adaptiveSettings)).subscribe((adaptiveSettings) => this.changes.next(adaptiveSettings)));
    }
    if (isPresent(this.adaptiveSettings) && !areObjectsEqual(this.adaptiveSettings, DEFAULT_ADAPTIVE_SETTINGS)) {
      this.changes.next(this.adaptiveSettings);
    }
    if (isDocumentAvailable()) {
      this.zone.runOutsideAngular(() => {
        this.subs.add(fromEvent(window, "resize").pipe(tap(() => !this.previousSize && (this.previousSize = this.size)), filter(() => this.previousSize !== this.size)).subscribe(() => {
          this.previousSize = this.size;
          this.zone.run(() => {
            this.sizeChanges.next(this.size);
          });
        }));
      });
    }
  }
  /**
   * @hidden
   */
  get adaptiveSettings() {
    return this._adaptiveSettings;
  }
  /**
   * @hidden
   */
  get size() {
    if (!isDocumentAvailable()) {
      return;
    }
    const settings = Object.assign(DEFAULT_ADAPTIVE_SETTINGS, this.adaptiveSettings);
    if (window.innerWidth > settings.medium) {
      return "large";
    } else if (window.innerWidth > settings.small) {
      return "medium";
    } else {
      return "small";
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  static ɵfac = function AdaptiveService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveService)(ɵɵinject(ADAPTIVE_SETTINGS, 8), ɵɵinject(AdaptiveSettingsService, 8), ɵɵinject(NgZone));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _AdaptiveService,
    factory: _AdaptiveService.ɵfac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ADAPTIVE_SETTINGS]
      }]
    }, {
      type: AdaptiveSettingsService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }];
  }, null);
})();

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/result.js
var ResultType;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType || (ResultType = {}));
var Result = (
  /** @class */
  function() {
    function Result3(value, rest, type) {
      if (type === void 0) {
        type = ResultType.Undefined;
      }
      this.value = value;
      this.rest = rest;
      this.type = type;
    }
    Result3.prototype.map = function(fn) {
      return new Result3(fn(this.value), this.rest);
    };
    Result3.prototype.chain = function(fn) {
      return fn(this.value, this.rest);
    };
    Result3.prototype.fold = function(s, _) {
      return s(this.value, this.rest);
    };
    Result3.prototype.concat = function(r) {
      return this.map(function(vs, _) {
        return r.chain(function(v, __) {
          return vs.concat([v]);
        });
      });
    };
    Result3.prototype.toString = function() {
      return "Result({ value: '" + this.value + "', rest: " + this.rest + " })";
    };
    return Result3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/stream.js
var Stream = (
  /** @class */
  function() {
    function Stream3(input, control) {
      if (input === void 0) {
        input = [];
      }
      if (control === void 0) {
        control = [];
      }
      this.input = input;
      this.control = control;
      this.inputCursor = 0;
      this.controlCursor = 0;
    }
    Stream3.prototype.eof = function() {
      return this.inputCursor >= this.input.length;
    };
    Stream3.prototype.next = function() {
      return {
        char: this.input[this.inputCursor++],
        control: this.control[this.controlCursor++]
      };
    };
    Stream3.prototype.peek = function() {
      return {
        char: this.input[this.inputCursor],
        control: this.control[this.controlCursor]
      };
    };
    Stream3.prototype.eat_input = function() {
      this.inputCursor++;
    };
    Stream3.prototype.eat_control = function() {
      this.controlCursor++;
    };
    Stream3.prototype.eat = function() {
      this.inputCursor++;
      this.controlCursor++;
    };
    return Stream3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/parsers.js
var toArray = function(value) {
  return (value || "").split("");
};
var ESCAPE_CHARACTER = "\\";
var Parser = (
  /** @class */
  function() {
    function Parser3(parse) {
      this.parse = parse;
    }
    Parser3.prototype.run = function(input, control) {
      if (control === void 0) {
        control = "";
      }
      if (input instanceof Stream) {
        return this.parse(input);
      } else {
        return this.parse(new Stream(toArray(input), toArray(control)));
      }
    };
    Parser3.prototype.map = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).map(f);
      });
    };
    Parser3.prototype.chain = function(f) {
      var _this = this;
      return new Parser3(function(stream) {
        return _this.parse(stream).chain(function(v, s) {
          return f(v).run(s);
        });
      });
    };
    Parser3.prototype.isLiteral = function(c) {
      return this.run(c).type === ResultType.Literal;
    };
    return Parser3;
  }()
);
var mask = function(_a2) {
  var prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
  return function(rule) {
    return new Parser(function(stream) {
      while (!stream.eof()) {
        var _a3 = stream.peek(), char = _a3.char, control = _a3.control;
        if (char === control && control === prompt) {
          stream.eat();
          return new Result(prompt, stream, ResultType.Mask);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result(char, stream, ResultType.Mask);
        }
        if (char === promptPlaceholder) {
          stream.eat();
          return new Result(prompt, stream, ResultType.Mask);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result(prompt, stream, ResultType.Mask);
    });
  };
};
var literal = function(_token) {
  return new Parser(function(stream) {
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
      return new Result(_token, stream, ResultType.Literal);
    }
    return new Result(_token, stream, ResultType.Literal);
  });
};
var unmask = function(prompt) {
  return function(rule) {
    return new Parser(function(stream) {
      while (!stream.eof()) {
        var _a2 = stream.peek(), char = _a2.char, control = _a2.control;
        if (char === prompt && control === prompt) {
          stream.eat();
          return new Result(char, stream);
        }
        if (rule.test(char)) {
          stream.eat();
          return new Result(char, stream);
        }
        stream.eat_input();
      }
      stream.eat();
      return new Result("", stream);
    });
  };
};
var unliteral = function(_token) {
  return new Parser(function(stream) {
    if (stream.eof()) {
      return new Result("", stream);
    }
    var char = stream.peek().char;
    if (char === _token) {
      stream.eat();
    }
    return new Result(_token, stream);
  });
};
var token = function(rules, creator) {
  return new Parser(function(stream) {
    var char = stream.next().char;
    var rule = rules[char];
    if (char === ESCAPE_CHARACTER) {
      char = stream.next().char;
      return new Result(creator.literal(char), stream);
    }
    if (!rule) {
      return new Result(creator.literal(char), stream);
    }
    return new Result(creator.mask(rule), stream);
  });
};
var rawMask = function(_a2) {
  var prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
  return new Parser(function(stream) {
    var char = stream.next().char;
    if (char === prompt) {
      return new Result(promptPlaceholder, stream);
    }
    return new Result(char, stream);
  });
};
var rawLiteral = function(includeLiterals) {
  return new Parser(function(stream) {
    var char = stream.next().char;
    if (includeLiterals) {
      return new Result(char, stream);
    }
    return new Result("", stream);
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/parsing/combinators.js
var always = function(value) {
  return new Parser(function(stream) {
    return new Result(value, stream);
  });
};
var append = function(p1, p2) {
  return p1.chain(function(vs) {
    return p2.map(function(v) {
      return vs.concat([v]);
    });
  });
};
var sequence = function(list) {
  return list.reduce(function(acc, parser) {
    return append(acc, parser);
  }, always([]));
};
var greedy = function(parser) {
  return new Parser(function(stream) {
    var result = new Result([], stream);
    while (!stream.eof()) {
      result = result.concat(parser.run(stream));
    }
    return result;
  });
};

// node_modules/@progress/kendo-inputs-common/dist/es/maskedtextbox/masking.service.js
var MaskingService = (
  /** @class */
  function() {
    function MaskingService3() {
      this.rules = {};
      this.prompt = "_";
      this.mask = "";
      this.promptPlaceholder = " ";
      this.includeLiterals = false;
      this.maskTokens = [];
      this.unmaskTokens = [];
      this.rawTokens = [];
      this.validationTokens = [];
    }
    MaskingService3.prototype.update = function(_a2) {
      var _b = _a2.mask, mask3 = _b === void 0 ? "" : _b, _c = _a2.prompt, prompt = _c === void 0 ? "" : _c, _d = _a2.promptPlaceholder, promptPlaceholder = _d === void 0 ? " " : _d, _e = _a2.rules, rules = _e === void 0 ? {} : _e, _f = _a2.includeLiterals, includeLiterals = _f === void 0 ? false : _f;
      this.mask = mask3;
      this.prompt = prompt;
      this.promptPlaceholder = promptPlaceholder;
      this.rules = rules;
      this.includeLiterals = includeLiterals;
      this.tokenize();
    };
    MaskingService3.prototype.validationValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value = maskedValue;
      sequence(this.validationTokens).run(maskedValue).fold(function(unmasked) {
        value = unmasked.join("");
      });
      return value;
    };
    MaskingService3.prototype.rawValue = function(maskedValue) {
      if (maskedValue === void 0) {
        maskedValue = "";
      }
      var value = maskedValue;
      if (!this.rawTokens.length) {
        return value;
      }
      sequence(this.rawTokens).run(maskedValue).fold(function(unmasked) {
        value = unmasked.join("");
      });
      return value;
    };
    MaskingService3.prototype.maskRaw = function(rawValue) {
      if (rawValue === void 0) {
        rawValue = "";
      }
      var value = rawValue;
      if (!this.maskTokens.length) {
        return value;
      }
      sequence(this.maskTokens).run(rawValue).fold(function(masked) {
        value = masked.join("");
      });
      return value;
    };
    MaskingService3.prototype.maskInput = function(input, control, splitPoint) {
      if (input.length < control.length) {
        return this.maskRemoved(input, control, splitPoint);
      }
      return this.maskInserted(input, control, splitPoint);
    };
    MaskingService3.prototype.maskInRange = function(pasted, oldValue, start, end) {
      var value = "";
      var selection = end;
      var beforeChange = oldValue.split("").slice(0, start);
      var afterChange = oldValue.split("").slice(end);
      sequence(this.maskTokens.slice(start, end)).run(pasted).fold(function(masked) {
        value = beforeChange.concat(masked).concat(afterChange).join("");
      });
      return {
        selection,
        value
      };
    };
    MaskingService3.prototype.maskRemoved = function(input, control, splitPoint) {
      var _this = this;
      var value = "";
      var selection = splitPoint;
      var unchanged = input.split("").slice(splitPoint);
      var changed = input.split("").slice(0, splitPoint).join("");
      var take2 = this.maskTokens.length - (input.length - splitPoint);
      sequence(this.maskTokens.slice(0, take2)).run(changed, control).fold(function(masked) {
        selection = _this.adjustPosition(masked, selection);
        value = masked.concat(unchanged).join("");
      });
      return {
        selection,
        value
      };
    };
    MaskingService3.prototype.adjustPosition = function(input, selection) {
      var caretChar = input[selection];
      var isLiteral = this.maskTokens[selection].isLiteral(caretChar);
      if (!isLiteral && caretChar !== this.prompt) {
        return selection + 1;
      }
      return selection;
    };
    MaskingService3.prototype.maskInserted = function(input, control, splitPoint) {
      var _this = this;
      var value = "";
      var selection = splitPoint;
      var changed = input.slice(0, splitPoint);
      sequence(this.unmaskTokens).run(changed, control).chain(function(unmasked) {
        selection = unmasked.join("").length;
        var unchanged = control.slice(selection);
        return sequence(_this.maskTokens).run(unmasked.join("") + unchanged, control);
      }).fold(function(masked) {
        value = masked.join("");
      });
      return {
        selection,
        value
      };
    };
    Object.defineProperty(MaskingService3.prototype, "maskTokenCreator", {
      get: function() {
        var _a2 = this, prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder;
        return {
          literal: function(rule) {
            return literal(rule);
          },
          mask: function(rule) {
            return mask({
              prompt,
              promptPlaceholder
            })(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "unmaskTokenCreator", {
      get: function() {
        var _this = this;
        return {
          literal: function(rule) {
            return unliteral(rule);
          },
          mask: function(rule) {
            return unmask(_this.prompt)(rule);
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "rawTokenCreator", {
      get: function() {
        var _a2 = this, prompt = _a2.prompt, promptPlaceholder = _a2.promptPlaceholder, includeLiterals = _a2.includeLiterals;
        return {
          literal: function(_) {
            return rawLiteral(includeLiterals);
          },
          mask: function(_) {
            return rawMask({
              prompt,
              promptPlaceholder
            });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MaskingService3.prototype, "validationTokenCreator", {
      get: function() {
        var prompt = this.prompt;
        return {
          literal: function(_) {
            return rawLiteral(false);
          },
          mask: function(_) {
            return rawMask({
              prompt,
              promptPlaceholder: ""
            });
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MaskingService3.prototype.tokenize = function() {
      var _this = this;
      greedy(token(this.rules, this.maskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.maskTokens = tokens;
      });
      greedy(token(this.rules, this.unmaskTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.unmaskTokens = tokens;
      });
      greedy(token(this.rules, this.rawTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.rawTokens = tokens;
      });
      greedy(token(this.rules, this.validationTokenCreator)).run(this.mask).fold(function(tokens, _) {
        _this.validationTokens = tokens;
      });
    };
    return MaskingService3;
  }()
);

// node_modules/@progress/kendo-inputs-common/dist/es/common/drawing-utils.js
var _a = drawing_exports.util;
var elementOffset = _a.elementOffset;
var limitValue = _a.limitValue;

// node_modules/@progress/kendo-inputs-common/dist/es/signature/signature-pad.js
var Point = geometry_exports.Point;
var Rect = geometry_exports.Rect;
var transform = geometry_exports.transform;
var noop3 = function() {
};
var DECIMAL_DIGITS = 3;
var DEFAULT_COLOR = "#000";
var DEFAULT_BACKGROUND_COLOR = "#fff";
var DEFAULT_PRECISION = 1;
var DEFAULT_SAMPLING_RATE = 200;
var DEFAULT_STROKE_WIDTH = 1;
var DEFAULT_WIDTH = 750;
var DEFAULT_HEIGHT = 250;
var DEFAULT_SCALE = 1;
var DEFAULT_EXPORT_SCALE = 6;
var SignaturePad = (
  /** @class */
  function() {
    function SignaturePad2(element, options) {
      if (options === void 0) {
        options = {};
      }
      this.element = element;
      this.lastMoveTime = 0;
      this.resolveColors(options);
      this.options = Object.assign({
        scale: DEFAULT_SCALE,
        precision: DEFAULT_PRECISION,
        samplingRate: DEFAULT_SAMPLING_RATE,
        smooth: options.smooth !== false,
        color: DEFAULT_COLOR,
        backgroundColor: DEFAULT_BACKGROUND_COLOR,
        strokeWidth: DEFAULT_STROKE_WIDTH,
        onChange: noop3,
        onDraw: noop3,
        onDrawEnd: noop3
      }, options, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions = {
        stroke: {
          color: this.options.color,
          width: this.options.strokeWidth,
          lineCap: "round",
          lineJoin: "round"
        }
      };
      this.initSurface();
      this.attachEvents();
    }
    SignaturePad2.prototype.destroy = function() {
      this.detachEvents();
    };
    SignaturePad2.prototype.clear = function() {
      this.rootGroup.clear();
      this.path = null;
    };
    SignaturePad2.prototype.readThemeColors = function() {
      var themeColor;
      var themeBackgroundColor;
      if (typeof document !== "undefined") {
        var themeElement = this.element.closest(".k-signature") || this.element;
        var computedStyle = themeElement.ownerDocument.defaultView.getComputedStyle(themeElement);
        themeColor = computedStyle.color;
        themeBackgroundColor = computedStyle.backgroundColor;
      }
      this.themeColor = themeColor || this.themeColor || DEFAULT_COLOR;
      this.themeBackgroundColor = themeBackgroundColor || this.themeBackgroundColor || DEFAULT_BACKGROUND_COLOR;
    };
    SignaturePad2.prototype.resolveColors = function(options) {
      this.readThemeColors();
      this.color = options.color || (this.options || {}).color || this.themeColor;
      this.backgroundColor = options.backgroundColor || (this.options || {}).backgroundColor || this.themeBackgroundColor;
    };
    Object.defineProperty(SignaturePad2.prototype, "isDrawing", {
      get: function() {
        return Boolean(this.points);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SignaturePad2.prototype, "pathData", {
      get: function() {
        var _a2;
        return (_a2 = this.path) === null || _a2 === void 0 ? void 0 : _a2.toString(DECIMAL_DIGITS);
      },
      set: function(value) {
        this.clear();
        this.path = MultiPath.parse(value, this.pathOptions);
        this.rootGroup.append(this.path);
      },
      enumerable: false,
      configurable: true
    });
    SignaturePad2.prototype.loadImage = function(data, size) {
      if (size === void 0) {
        size = [];
      }
      if (!data) {
        this.clear();
        return;
      }
      var _a2 = this.size, width = _a2[0], height = _a2[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;
      var importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = contentWidth / importWidth;
      var scaleY = contentHeight / importHeight;
      var scale = Math.min(scaleX, scaleY);
      var img = new image_default(data, new geometry_exports.Rect([0, 0], [importWidth, importHeight]));
      img.transform(transform().scale(scale, scale));
      this.clear();
      this.rootGroup.append(img);
    };
    SignaturePad2.prototype.exportImage = function(options) {
      var _a2;
      var _b = this.size, width = _b[0], height = _b[1];
      var contentWidth = width / this.options.scale;
      var contentHeight = height / this.options.scale;
      var exportWidth = (options === null || options === void 0 ? void 0 : options.width) || contentWidth * DEFAULT_EXPORT_SCALE;
      var exportHeight = (options === null || options === void 0 ? void 0 : options.height) || contentHeight * DEFAULT_EXPORT_SCALE;
      var scaleX = exportWidth / contentWidth;
      var scaleY = exportHeight / contentHeight;
      var scale = Math.min(scaleX, scaleY);
      var exportRect = new Rect([0, 0], [exportWidth, exportHeight]);
      var exportGroup = new group_default({
        clip: Path.fromRect(exportRect)
      });
      var contentGroup = new group_default({
        transform: transform().scale(scale, scale)
      });
      var frame = Path.fromRect(exportRect, {
        fill: {
          color: this.options.backgroundColor
        }
      });
      exportGroup.append(frame);
      exportGroup.append(contentGroup);
      (_a2 = contentGroup.children).push.apply(_a2, this.rootGroup.children);
      return exportImage(exportGroup, Object.assign({
        width: exportWidth,
        height: exportHeight
      }, options));
    };
    SignaturePad2.prototype.resize = function() {
      this.surface.resize(true);
    };
    SignaturePad2.prototype.setOptions = function(options) {
      this.resolveColors(options);
      Object.assign(this.options, options, {
        color: this.color,
        backgroundColor: this.backgroundColor
      });
      this.pathOptions.stroke.color = this.options.color;
      this.pathOptions.stroke.width = this.options.strokeWidth;
      if (this.path) {
        this.path.options.set("stroke.color", this.options.color);
        this.path.options.set("stroke.width", this.options.strokeWidth);
      }
      this.background.options.set("fill.color", this.options.backgroundColor);
    };
    SignaturePad2.prototype.initSurface = function() {
      this.surface = surface_default.create(this.element, {
        type: "canvas"
      });
      this.element.style.touchAction = "none";
      var scale = this.options.scale;
      this.rootGroup = new group_default({
        transform: transform().scale(scale, scale)
      });
      var width = this.element.offsetWidth || DEFAULT_WIDTH;
      var height = this.element.offsetHeight || DEFAULT_HEIGHT;
      this.size = [width, height];
      this.background = Path.fromRect(new Rect([0, 0], this.size), {
        fill: {
          color: this.options.backgroundColor
        }
      });
      this.surface.draw(this.background);
      this.surface.draw(this.rootGroup);
    };
    SignaturePad2.prototype.attachEvents = function() {
      this.onPointerDown = this.onPointerDown.bind(this);
      this.onPointerMove = this.onPointerMove.bind(this);
      this.onPointerUp = this.onPointerUp.bind(this);
      this.onDragStart = this.onDragStart.bind(this);
      this.element.addEventListener("pointerdown", this.onPointerDown);
      this.element.addEventListener("pointerup", this.onPointerUp);
      this.element.addEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.detachEvents = function() {
      this.element.removeEventListener("pointerdown", this.onPointerDown);
      this.detachPointerMove();
      this.element.removeEventListener("pointerup", this.onPointerUp);
      this.element.removeEventListener("dragstart", this.onDragStart);
    };
    SignaturePad2.prototype.attachPointerMove = function() {
      this.element.addEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.detachPointerMove = function() {
      this.element.removeEventListener("pointermove", this.onPointerMove);
    };
    SignaturePad2.prototype.touchPoint = function(e) {
      var offset = elementOffset(this.element);
      var pageX = e.pageX;
      var pageY = e.pageY;
      var scale = 1 / this.options.scale;
      return new Point(pageX - offset.left, pageY - offset.top).scale(scale, scale);
    };
    SignaturePad2.prototype.onDragStart = function(e) {
      e.preventDefault();
    };
    SignaturePad2.prototype.onPointerDown = function(e) {
      if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {
        return;
      }
      this.detachPointerMove();
      this.attachPointerMove();
      if (!this.path) {
        this.path = new MultiPath(this.pathOptions);
        this.rootGroup.append(this.path);
      }
      this.options.onDraw();
      this.element.setPointerCapture(e.pointerId);
      var point = this.touchPoint(e);
      this.points = [point];
      this.path.moveTo(point);
    };
    SignaturePad2.prototype.onPointerMove = function(e) {
      if (!this.points || !this.path || !e.isPrimary) {
        return;
      }
      var now = (/* @__PURE__ */ new Date()).getTime();
      var elapsed = now - this.lastMoveTime;
      var minTimeDelta = 1e3 / limitValue(this.options.samplingRate, 1, 1e4);
      if (elapsed < minTimeDelta) {
        return;
      } else {
        this.lastMoveTime = now;
      }
      var point = this.touchPoint(e);
      var lastPoint = this.points[this.points.length - 1];
      var minDelta = 1 / limitValue(this.options.precision, 0.01, 100);
      if (point.distanceTo(lastPoint) < minDelta) {
        return;
      }
      this.points.push(point);
      this.path.lineTo(point);
    };
    SignaturePad2.prototype.onPointerUp = function(e) {
      if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {
        return;
      }
      this.detachPointerMove();
      if (this.options.smooth) {
        var segments = Path.curveFromPoints(this.points);
        this.path.paths.splice(this.path.paths.length - 1, 1, segments);
      }
      this.points = null;
      this.options.onDrawEnd();
      this.options.onChange(this.pathData);
    };
    return SignaturePad2;
  }()
);
function isMainButton(e) {
  return typeof e.button !== "number" || e.button === 0;
}

// node_modules/@progress/kendo-angular-inputs/fesm2022/progress-kendo-angular-inputs.mjs
var _c02 = ["wrap"];
var _c1 = ["track"];
var _c2 = ["sliderSelection"];
var _c3 = ["ticks"];
var _c4 = ["tickElement"];
var _c5 = ["kendoSliderTicks", ""];
function SliderTicksComponent_li_0_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵelementContainer(1, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    const defaultLabel_r3 = ɵɵreference(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.labelTemplate || defaultLabel_r3)("ngTemplateOutletContext", tick_r1);
  }
}
function SliderTicksComponent_li_0_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1, " ");
    ɵɵelementContainerEnd();
  }
}
function SliderTicksComponent_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3, 1);
    ɵɵelementContainerStart(2, 4);
    ɵɵtemplate(3, SliderTicksComponent_li_0_span_3_Template, 2, 2, "span", 5)(4, SliderTicksComponent_li_0_ng_container_4_Template, 2, 0, "ng-container", 6);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵpropertyInterpolate("title", ctx_r1.tickTitle(tick_r1.value));
    ɵɵproperty("ngClass", tick_r1.classes);
    ɵɵadvance(2);
    ɵɵproperty("ngSwitch", tick_r1.large);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", false);
  }
}
function SliderTicksComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const value_r4 = ctx.value;
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate1(" ", ctx_r1.tickTitle(value_r4), " ");
  }
}
var _c6 = ["draghandle"];
var _c7 = ["decreaseButton"];
var _c8 = ["increaseButton"];
var _c9 = (a0, a1) => ({
  click: a0,
  keydown: a1
});
function SliderComponent_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "button", 16, 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("icon", ctx_r1.decreaseButtonArrowIcon)("svgIcon", ctx_r1.decreaseButtonArrowSVGIcon)("title", ctx_r1.decrementMessage);
    ɵɵattribute("tabindex", -1);
  }
}
function SliderComponent_ul_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 17, 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
  }
}
function SliderComponent_button_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "button", 18, 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("icon", ctx_r1.increaseButtonArrowIcon)("svgIcon", ctx_r1.increaseButtonArrowSVGIcon)("title", ctx_r1.incrementMessage);
    ɵɵattribute("tabindex", -1);
  }
}
var _c10 = ["draghandleStart"];
var _c11 = ["draghandleEnd"];
function RangeSliderComponent_ul_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 13, 5);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tickTitle", ctx_r1.title)("vertical", ctx_r1.vertical)("step", ctx_r1.smallStep)("largeStep", ctx_r1.largeStep)("min", ctx_r1.min)("max", ctx_r1.max)("labelTemplate", ctx_r1.labelTemplate == null ? null : ctx_r1.labelTemplate.templateRef);
    ɵɵattribute("aria-hidden", true);
  }
}
var _c12 = ["thumb"];
var _c13 = ["numericInput"];
var _c14 = (a0, a1, a2, a3, a4, a5, a6) => ({
  mousedown: a0,
  dragenter: a1,
  keydown: a2,
  input: a3,
  focus: a4,
  blur: a5,
  paste: a6
});
var _c15 = (a0, a1) => ({
  mouseup: a0,
  mouseleave: a1
});
var _c16 = (a0) => ({
  mousedown: a0
});
function NumericTextBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function NumericTextBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtemplate(1, NumericTextBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function NumericTextBoxComponent_kendo_input_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function NumericTextBoxComponent_kendo_input_separator_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function NumericTextBoxComponent_span_7_ng_template_1_Template(rf, ctx) {
}
function NumericTextBoxComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtemplate(1, NumericTextBoxComponent_span_7_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function NumericTextBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 11)(1, "button", 12);
    ɵɵelement(2, "kendo-icon-wrapper", 13);
    ɵɵelementEnd();
    ɵɵelementStart(3, "button", 14);
    ɵɵelement(4, "kendo-icon-wrapper", 15);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(15, _c15, ctx_r1.releaseArrow, ctx_r1.releaseArrow));
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Up);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(18, _c16, ctx_r1.increasePress))("title", ctx_r1.incrementTitle);
    ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.incrementTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.arrowUpIcon);
    ɵɵadvance();
    ɵɵclassProp("k-active", ctx_r1.arrowDirection === ctx_r1.ArrowDirection.Down);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(20, _c16, ctx_r1.decreasePress))("title", ctx_r1.decrementTitle);
    ɵɵattribute("aria-hidden", true)("aria-label", ctx_r1.decrementTitle);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.arrowDownIcon);
  }
}
var _c17 = ["input"];
var _c18 = (a0, a1, a2, a3, a4) => ({
  focus: a0,
  blur: a1,
  click: a2,
  dragstart: a3,
  drop: a4
});
function MaskedTextBoxComponent_span_1_ng_template_1_Template(rf, ctx) {
}
function MaskedTextBoxComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 6);
    ɵɵtemplate(1, MaskedTextBoxComponent_span_1_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MaskedTextBoxComponent_kendo_input_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function MaskedTextBoxComponent_kendo_input_separator_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function MaskedTextBoxComponent_span_6_ng_template_1_Template(rf, ctx) {
}
function MaskedTextBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtemplate(1, MaskedTextBoxComponent_span_6_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
var _c19 = (a0, a1) => ({
  blur: a0,
  change: a1
});
var _c20 = (a0, a1, a2) => ({
  focus: a0,
  blur: a1,
  input: a2
});
function TextBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function TextBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TextBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefix == null ? null : ctx_r1.prefix.templateRef);
  }
}
function TextBoxComponent_kendo_input_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function TextBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 11);
    ɵɵlistener("click", function TextBoxComponent_span_6_Template_span_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue());
    })("mousedown", function TextBoxComponent_span_6_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    })("keydown.enter", function TextBoxComponent_span_6_Template_span_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    })("keydown.space", function TextBoxComponent_span_6_Template_span_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.tabIndex)("title", ctx_r1.clearTitle());
    ɵɵattribute("aria-label", ctx_r1.clearTitle());
    ɵɵadvance();
    ɵɵproperty("name", ctx_r1.clearButtonClass)("customFontClass", ctx_r1.customClearButtonClasses)("svgIcon", ctx_r1.clearButtonSvgIcon || ctx_r1.svgIcon("xIcon"));
  }
}
function TextBoxComponent_kendo_icon_wrapper_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.errorIconClasses)("customFontClass", ctx_r1.customIconClasses)("svgIcon", ctx_r1.errorSvgIcon || ctx_r1.svgIcon("exclamationCircleIcon"));
  }
}
function TextBoxComponent_kendo_icon_wrapper_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.successIconClasses)("customFontClass", ctx_r1.customSuccessIconClasses)("svgIcon", ctx_r1.successSvgIcon || ctx_r1.svgIcon("checkIcon"));
  }
}
function TextBoxComponent_kendo_input_separator_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator");
  }
}
function TextBoxComponent_span_10_ng_template_1_Template(rf, ctx) {
}
function TextBoxComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, TextBoxComponent_span_10_ng_template_1_Template, 0, 0, "ng-template", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffix == null ? null : ctx_r1.suffix.templateRef);
  }
}
var _c21 = ["opacityInput"];
var _c22 = ["hexInput"];
var _c23 = ["blue"];
var _c24 = ["toggleFormatButton"];
function ColorInputComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10)(1, "kendo-textbox", 11, 1);
    ɵɵlistener("blur", function ColorInputComponent_div_3_Template_kendo_textbox_blur_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleHexInputBlur());
    })("input", function ColorInputComponent_div_3_Template_kendo_textbox_input_1_listener() {
      ɵɵrestoreView(_r1);
      const hexInput_r3 = ɵɵreference(2);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleHexValueChange(hexInput_r3.value));
    })("keydown.tab", function ColorInputComponent_div_3_Template_kendo_textbox_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusDragHandle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 12);
    ɵɵtext(4, "HEX");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-readonly", ctx_r1.readonly);
    ɵɵproperty("focusableId", ctx_r1.focusableId)("size", ctx_r1.size)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("value", ctx_r1.hex || "")("tabindex", ctx_r1.tabindex);
    ɵɵadvance(2);
    ɵɵproperty("for", ctx_r1.focusableId);
  }
}
function ColorInputComponent_ng_container_4_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 6)(1, "kendo-numerictextbox", 17, 5);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.rgba.a, $event) || (ctx_r1.rgba.a = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_blur_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_valueChange_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    })("keydown.tab", function ColorInputComponent_ng_container_4_div_16_Template_kendo_numerictextbox_keydown_tab_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.focusDragHandle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 12);
    ɵɵtext(5, "A");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const alpha_r6 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 1);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.a);
    ɵɵproperty("autoCorrect", true)("spinners", false)("step", 0.01)("format", "n2")("decimals", 2);
    ɵɵadvance(3);
    ɵɵproperty("for", alpha_r6.focusableId);
  }
}
function ColorInputComponent_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 6)(2, "kendo-numerictextbox", 13, 2);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.r, $event) || (ctx_r1.rgba.r = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_2_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    });
    ɵɵelementEnd();
    ɵɵelementStart(4, "label", 12);
    ɵɵtext(5, "R");
    ɵɵelementEnd()();
    ɵɵelementStart(6, "div", 6)(7, "kendo-numerictextbox", 14, 3);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.g, $event) || (ctx_r1.rgba.g = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_7_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    });
    ɵɵelementEnd();
    ɵɵelementStart(9, "label", 12);
    ɵɵtext(10, "G");
    ɵɵelementEnd()();
    ɵɵelementStart(11, "div", 6)(12, "kendo-numerictextbox", 15, 4);
    ɵɵtwoWayListener("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.rgba.b, $event) || (ctx_r1.rgba.b = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("blur", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_blur_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaInputBlur());
    })("valueChange", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_valueChange_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleRgbaValueChange());
    })("keydown.tab", function ColorInputComponent_ng_container_4_Template_kendo_numerictextbox_keydown_tab_12_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onTab());
    });
    ɵɵelementEnd();
    ɵɵelementStart(14, "label", 12);
    ɵɵtext(15, "B");
    ɵɵelementEnd()();
    ɵɵtemplate(16, ColorInputComponent_ng_container_4_div_16_Template, 6, 14, "div", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const red_r7 = ɵɵreference(3);
    const green_r8 = ɵɵreference(8);
    const blue_r9 = ɵɵreference(13);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("size", ctx_r1.size)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.r);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", red_r7.focusableId);
    ɵɵadvance(3);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.g);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", green_r8.focusableId);
    ɵɵadvance(3);
    ɵɵproperty("localizationService", ctx_r1.localizationService)("disabled", ctx_r1.disabled)("readonly", ctx_r1.readonly)("tabindex", ctx_r1.tabindex)("size", ctx_r1.size)("min", 0)("max", 255);
    ɵɵtwoWayProperty("value", ctx_r1.rgba.b);
    ɵɵproperty("autoCorrect", true)("spinners", false)("format", "n")("decimals", 0);
    ɵɵadvance(2);
    ɵɵproperty("for", blue_r9.focusableId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.opacity);
  }
}
var _c25 = ["kendoContrastValidation", ""];
function ContrastValidationComponent_ng_container_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 3);
    ɵɵtext(1);
    ɵɵelement(2, "kendo-icon-wrapper", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.passMessage, " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
  }
}
function ContrastValidationComponent_ng_container_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵtext(1);
    ɵɵelement(2, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.failMessage, " ");
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xCircleIcon);
  }
}
function ContrastValidationComponent_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ContrastValidationComponent_ng_container_2_span_1_Template, 3, 2, "span", 1)(2, ContrastValidationComponent_ng_container_2_span_2_Template, 3, 2, "span", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.pass);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.pass);
  }
}
var _c26 = ["kendoContrastTool", ""];
function ContrastComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
  }
}
function ContrastComponent_ng_container_3_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵelement(1, "kendo-icon-wrapper", 8);
    ɵɵtemplate(2, ContrastComponent_ng_container_3_span_1_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.checkIcon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.satisfiesAAACondition);
  }
}
function ContrastComponent_ng_container_3_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵelement(1, "kendo-icon-wrapper", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r0.xCircleIcon);
  }
}
function ContrastComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ContrastComponent_ng_container_3_span_1_Template, 3, 2, "span", 5)(2, ContrastComponent_ng_container_3_span_2_Template, 2, 1, "span", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.satisfiesAACondition);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.satisfiesAACondition);
  }
}
var _c27 = ["kendoColorContrastSvg", ""];
function ColorContrastSvgComponent__svg_path_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 1);
  }
  if (rf & 2) {
    const path_r1 = ctx.$implicit;
    ɵɵattribute("d", path_r1);
  }
}
var _c28 = ["gradientDragHandle"];
var _c29 = ["inputs"];
var _c30 = ["alphaSlider"];
var _c31 = ["gradientWrapper"];
var _c32 = ["hsvRectangle"];
var _c33 = (a0, a1) => ({
  "k-colorgradient-canvas": true,
  "k-vstack": a0,
  "k-hstack": a1
});
var _c34 = (a0, a1, a2) => ({
  "k-hsv-controls": true,
  "k-sliders-wrap-clearable": a0,
  "k-vstack": a1,
  "k-hstack": a2
});
var _c35 = (a0) => ({
  "k-align-self-end": a0
});
function ColorGradientComponent__svg_svg_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "svg", 16);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const gradientWrapper_r4 = ɵɵreference(5);
    ɵɵstyleMap("position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px;");
    ɵɵproperty("wrapper", gradientWrapper_r4 ? gradientWrapper_r4 : void 0)("hsva", ctx_r2.hsva)("backgroundColor", ctx_r2.contrastTool);
  }
}
function ColorGradientComponent_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 17);
    ɵɵlistener("click", function ColorGradientComponent_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    })("keydown.enter", function ColorGradientComponent_button_10_Template_button_keydown_enter_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    })("keydown.space", function ColorGradientComponent_button_10_Template_button_keydown_space_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.reset());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleMap("position: absolute; top: 0; left: 50%; transform: translateX(-50%);");
    ɵɵproperty("svgIcon", ctx_r2.dropletSlashIcon)("size", ctx_r2.size)("tabindex", ctx_r2.innerTabIndex.toString());
    ɵɵattribute("aria-label", ctx_r2.clearButtonTitle)("title", ctx_r2.clearButtonTitle);
  }
}
function ColorGradientComponent_kendo_slider_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-slider", 18, 4);
    ɵɵlistener("valueChange", function ColorGradientComponent_kendo_slider_12_Template_kendo_slider_valueChange_0_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleAlphaSliderChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r2.clearButton ? "140" : null, "px");
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex)("ngClass", ɵɵpureFunction1(14, _c35, ctx_r2.clearButton))("dragHandleTitle", ctx_r2.opacitySliderTitle)("disabled", ctx_r2.disabled)("readonly", ctx_r2.readonly)("showButtons", false)("vertical", !ctx_r2.adaptiveMode)("min", 0)("max", 100)("smallStep", 1)("largeStep", 10)("value", ctx_r2.alphaSliderValue);
  }
}
function ColorGradientComponent_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 19);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r2.value)("ratio", ctx_r2.contrastTool);
  }
}
var _c36 = (a0, a1, a2, a3) => ({
  backgroundColor: a0,
  width: a1,
  height: a2,
  minWidth: a3
});
function ColorPaletteComponent_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 5);
    ɵɵlistener("click", function ColorPaletteComponent_tr_3_td_1_Template_td_click_0_listener() {
      const ctx_r1 = ɵɵrestoreView(_r1);
      const color_r3 = ctx_r1.$implicit;
      const colIndex_r4 = ctx_r1.index;
      const rowIndex_r5 = ɵɵnextContext().index;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.handleCellSelection(color_r3, {
        row: rowIndex_r5,
        col: colIndex_r4
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const color_r3 = ctx.$implicit;
    const colIndex_r4 = ctx.index;
    const rowIndex_r5 = ɵɵnextContext().index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("k-selected", (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.row) === rowIndex_r5 && (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.col) === colIndex_r4)("k-focus", ctx_r5.focusInComponent && (ctx_r5.focusedCell == null ? null : ctx_r5.focusedCell.row) === rowIndex_r5 && (ctx_r5.focusedCell == null ? null : ctx_r5.focusedCell.col) === colIndex_r4);
    ɵɵproperty("id", "k-" + rowIndex_r5 + "-" + colIndex_r4 + "-" + ctx_r5.uniqueId)("ngStyle", ɵɵpureFunction4(9, _c36, color_r3, (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.width) + "px", (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.height) + "px", (ctx_r5.tileLayout == null ? null : ctx_r5.tileLayout.width) + "px"));
    ɵɵattribute("aria-selected", (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.row) === rowIndex_r5 && (ctx_r5.selectedCell == null ? null : ctx_r5.selectedCell.col) === colIndex_r4 ? "true" : void 0)("aria-label", color_r3)("value", color_r3);
  }
}
function ColorPaletteComponent_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 3);
    ɵɵtemplate(1, ColorPaletteComponent_tr_3_td_1_Template, 1, 14, "td", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r7);
  }
}
var _c37 = ["clearButton"];
var _c38 = ["viewButtons"];
var _c39 = ["kendoFlatColorPickerHeader", ""];
function FlatColorPickerHeaderComponent_div_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9, 0);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_click_0_listener() {
      const view_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onViewButtonClick(view_r2));
    })("keydown.shift.tab", function FlatColorPickerHeaderComponent_div_1_button_1_Template_button_keydown_shift_tab_0_listener($event) {
      const i_r4 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onHeaderTabOut($event, i_r4));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const view_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex.toString())("icon", ctx_r2.getViewButtonIcon(view_r2))("svgIcon", ctx_r2.getViewButtonsSVGIcon(view_r2))("size", ctx_r2.size)("ngClass", ctx_r2.activeView === view_r2 ? "k-selected" : "");
    ɵɵattribute("title", ctx_r2.getText(view_r2 === "gradient" ? "gradientView" : "paletteView"))("aria-label", ctx_r2.getText(view_r2 === "gradient" ? "gradientView" : "paletteView"))("aria-pressed", ctx_r2.activeView === view_r2);
  }
}
function FlatColorPickerHeaderComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_button_1_Template, 2, 8, "button", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.views);
  }
}
function FlatColorPickerHeaderComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10, 1);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_button_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearButtonClick.emit());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r2.innerTabIndex.toString())("size", ctx_r2.size)("svgIcon", ctx_r2.dropletSlashIcon);
    ɵɵattribute("aria-label", ctx_r2.getText("clearButton"))("title", ctx_r2.getText("clearButton"));
  }
}
function FlatColorPickerHeaderComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "span", 12);
    ɵɵelementStart(2, "span", 13);
    ɵɵlistener("click", function FlatColorPickerHeaderComponent_div_5_Template_span_click_2_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.valuePaneClick.emit($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵstyleProp("background-color", ctx_r2.selection);
    ɵɵattribute("title", ctx_r2.getText("previewColor"));
    ɵɵadvance();
    ɵɵstyleProp("background-color", ctx_r2.value);
    ɵɵattribute("title", ctx_r2.getText("revertSelection"));
  }
}
var _c40 = ["first"];
var _c41 = ["last"];
var _c42 = ["kendoFlatColorPickerActionButtons", ""];
var _c43 = ["header"];
var _c44 = ["gradient"];
var _c45 = ["palette"];
var _c46 = ["footer"];
function FlatColorPickerComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10, 0);
    ɵɵlistener("clearButtonClick", function FlatColorPickerComponent_div_1_Template_div_clearButtonClick_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClearButtonClick());
    })("viewChange", function FlatColorPickerComponent_div_1_Template_div_viewChange_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onViewChange($event));
    })("valuePaneClick", function FlatColorPickerComponent_div_1_Template_div_valuePaneClick_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.resetSelection($event));
    })("tabOut", function FlatColorPickerComponent_div_1_Template_div_tabOut_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.lastFocusable($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerTabIndex", ctx_r1.innerTabIndex)("clearButton", ctx_r1.clearButton)("activeView", ctx_r1.activeView)("views", ctx_r1.views)("size", ctx_r1.size)("value", ctx_r1.value)("selection", ctx_r1.selection)("preview", ctx_r1.preview);
  }
}
function FlatColorPickerComponent_kendo_colorgradient_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-colorgradient", 11, 1);
    ɵɵlistener("keydown.tab", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_keydown_tab_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.focusFirstHeaderButton());
    })("valueChange", function FlatColorPickerComponent_kendo_colorgradient_3_Template_kendo_colorgradient_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.innerTabIndex)("value", ctx_r1.selection)("size", ctx_r1.size)("adaptiveMode", ctx_r1.adaptiveMode)("format", ctx_r1.format)("opacity", ctx_r1.gradientSettings.opacity)("delay", ctx_r1.gradientSettings.delay)("contrastTool", ctx_r1.gradientSettings.contrastTool)("gradientSliderSmallStep", ctx_r1.gradientSettings.gradientSliderSmallStep)("gradientSliderStep", ctx_r1.gradientSettings.gradientSliderStep)("readonly", ctx_r1.readonly);
  }
}
function FlatColorPickerComponent_kendo_colorpalette_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-colorpalette", 12, 2);
    ɵɵlistener("valueChange", function FlatColorPickerComponent_kendo_colorpalette_4_Template_kendo_colorpalette_valueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("tabindex", ctx_r1.innerTabIndex)("palette", ctx_r1.paletteSettings.palette)("size", ctx_r1.size)("columns", ctx_r1.paletteSettings.columns)("tileSize", ctx_r1.paletteSettings.tileSize)("format", ctx_r1.format)("value", ctx_r1.selection)("readonly", ctx_r1.readonly);
  }
}
function FlatColorPickerComponent_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13, 3);
    ɵɵlistener("actionButtonClick", function FlatColorPickerComponent_div_5_Template_div_actionButtonClick_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onAction($event));
    })("tabOut", function FlatColorPickerComponent_div_5_Template_div_tabOut_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.firstFocusable.focus());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("innerTabIndex", ctx_r1.innerTabIndex)("size", ctx_r1.size)("ngClass", "k-justify-content-" + ctx_r1.actionsLayout);
  }
}
var _c47 = ["actionSheetSearchBar"];
var _c48 = ["cancel"];
var _c49 = ["apply"];
var _c50 = (a0) => ({
  duration: a0
});
var _c51 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c52 = (a0) => ({
  height: a0
});
function AdaptiveRendererComponent_ng_template_2_div_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.subtitle);
  }
}
function AdaptiveRendererComponent_ng_template_2_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16)(1, "button", 17, 1);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_2_div_10_Template_button_click_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onCancel.emit($event));
    });
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "button", 18, 2);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_2_div_10_Template_button_click_4_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onApply.emit());
    });
    ɵɵtext(6);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("cancelButton"));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("cancelButton"), " ");
    ɵɵadvance();
    ɵɵproperty("title", ctx_r2.messageFor("applyButton"));
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2.messageFor("applyButton"), " ");
  }
}
function AdaptiveRendererComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5)(1, "div", 6)(2, "div", 7)(3, "div", 8);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵtemplate(5, AdaptiveRendererComponent_ng_template_2_div_5_Template, 2, 1, "div", 9);
    ɵɵelementEnd();
    ɵɵelementStart(6, "div", 10)(7, "kendo-adaptive-close-button", 11);
    ɵɵlistener("close", function AdaptiveRendererComponent_ng_template_2_Template_kendo_adaptive_close_button_close_7_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.actionSheetClose.emit($event));
    });
    ɵɵelementEnd()()()();
    ɵɵelementStart(8, "div", 12);
    ɵɵtemplate(9, AdaptiveRendererComponent_ng_template_2_ng_container_9_Template, 1, 0, "ng-container", 13);
    ɵɵelementEnd();
    ɵɵtemplate(10, AdaptiveRendererComponent_ng_template_2_div_10_Template, 7, 4, "div", 14);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r2.title || ctx_r2.messageFor("adaptiveTitle"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("title", ctx_r2.messageFor("adaptiveCloseButtonTitle"))("svgIcon", ctx_r2.checkIcon);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.actionSheetTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.preview);
  }
}
var _c53 = ["container"];
var _c54 = ["activeColor"];
var _c55 = ["popupTemplate"];
var _c56 = ["flatColorPicker"];
var _c57 = (a0, a1) => ({
  "k-icon-color-preview": a0,
  "k-no-color": a1
});
function ColorPickerComponent_kendo_icon_wrapper_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 12);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r1.iconStyles)("customFontClass", ctx_r1.customIconStyles)("svgIcon", ctx_r1.svgIcon);
  }
}
function ColorPickerComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-flatcolorpicker", 13, 3);
    ɵɵlistener("cancel", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_cancel_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCancelEvent($event));
    })("focusout", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_focusout_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePopupBlur($event));
    })("valueChange", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_valueChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleValueChange($event));
    })("keydown", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_keydown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handlePopupKeyDown($event));
    })("activeViewChange", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_activeViewChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.activeViewChange.emit($event));
    })("clearButtonClick", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_clearButtonClick_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearButtonClick.emit());
    })("actionButtonClick", function ColorPickerComponent_ng_template_7_Template_kendo_flatcolorpicker_actionButtonClick_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePopup());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("value", ctx_r1.value)("format", ctx_r1.format)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("views", ctx_r1.views)("activeView", ctx_r1.activeView)("actionsLayout", ctx_r1.actionsLayout)("adaptiveMode", ctx_r1.isActionSheetExpanded)("preview", ctx_r1.preview)("gradientSettings", ctx_r1.gradientSettings)("paletteSettings", ctx_r1.paletteSettings)("clearButton", ctx_r1.clearButton);
  }
}
function ColorPickerComponent_kendo_resize_sensor_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 14);
    ɵɵlistener("resize", function ColorPickerComponent_kendo_resize_sensor_12_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var _c58 = ["*"];
var _c59 = [[["label"], ["kendo-label"]], "*", [["kendo-formhint"]], [["kendo-formerror"]]];
var _c60 = ["label, kendo-label", "*", "kendo-formhint", "kendo-formerror"];
function FormFieldComponent_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "hasHints"]);
  }
}
function FormFieldComponent_ng_content_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "hasErrors"]);
  }
}
var _c61 = (a0, a1) => ({
  "k-selected": a0,
  "k-hover": a1
});
var _c62 = (a0) => ({
  index: a0
});
var _c63 = (a0) => ({
  "clipPath": a0
});
function RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", item_r4.selected || item_r4.hovered ? "star" : "star-outline")("svgIcon", item_r4.selected || item_r4.hovered ? ctx_r1.svgIcon : ctx_r1.svgIconOutline);
  }
}
function RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("name", item_r4.selected || item_r4.hovered ? ctx_r1.icon : ctx_r1.icon + "-outline");
  }
}
function RatingComponent_span_1_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_1_Template, 1, 2, "kendo-icon-wrapper", 5)(2, RatingComponent_span_1_ng_container_1_ng_container_1_kendo_icon_wrapper_2_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_1_2_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_2_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c62, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_3_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_3_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.hoveredItemTemplate == null ? null : ctx_r1.hoveredItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c62, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_4_ng_template_0_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_1_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, RatingComponent_span_1_ng_container_1_4_ng_template_0_Template, 0, 0, "ng-template", 9);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.selectedItemTemplate == null ? null : ctx_r1.selectedItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c62, i_r3));
  }
}
function RatingComponent_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_ng_container_1_Template, 3, 2, "ng-container", 4)(2, RatingComponent_span_1_ng_container_1_2_Template, 1, 4, null, 4)(3, RatingComponent_span_1_ng_container_1_3_Template, 1, 4, null, 4)(4, RatingComponent_span_1_ng_container_1_4_Template, 1, 4, null, 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r4 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.itemTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.itemTemplate && !item_r4.selected && !item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hoveredItemTemplate && item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectedItemTemplate && item_r4.selected && !item_r4.hovered);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", "star-outline")("svgIcon", ctx_r1.svgIconOutline);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.icon + "-outline");
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", "star")("svgIcon", ctx_r1.svgIcon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("name", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 10);
    ɵɵtemplate(2, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_2_Template, 1, 2, "kendo-icon-wrapper", 5)(3, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_3_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
    ɵɵelementStart(4, "span", 12);
    ɵɵtemplate(5, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_5_Template, 1, 2, "kendo-icon-wrapper", 5)(6, RatingComponent_span_1_ng_container_2_ng_container_1_kendo_icon_wrapper_6_Template, 1, 1, "kendo-icon-wrapper", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(5, _c63, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.icon);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.icon);
  }
}
function RatingComponent_span_1_ng_container_2_ng_template_3_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_4_ng_template_1_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_span_4_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c63, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.hoveredItemTemplate == null ? null : ctx_r1.hoveredItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c62, i_r3));
  }
}
function RatingComponent_span_1_ng_container_2_span_5_ng_template_1_Template(rf, ctx) {
}
function RatingComponent_span_1_ng_container_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 12);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_span_5_ng_template_1_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext(2).index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ɵɵpureFunction1(3, _c63, ctx_r1.direction === "rtl" ? "inset(0 0 0 50%)" : "inset(0 50% 0 0)"));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.selectedItemTemplate == null ? null : ctx_r1.selectedItemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c62, i_r3));
  }
}
function RatingComponent_span_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_2_ng_container_1_Template, 7, 7, "ng-container", 4);
    ɵɵelementStart(2, "span", 10);
    ɵɵtemplate(3, RatingComponent_span_1_ng_container_2_ng_template_3_Template, 0, 0, "ng-template", 9);
    ɵɵelementEnd();
    ɵɵtemplate(4, RatingComponent_span_1_ng_container_2_span_4_Template, 2, 7, "span", 11)(5, RatingComponent_span_1_ng_container_2_span_5_Template, 2, 7, "span", 11);
    ɵɵelement(6, "span");
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const item_r4 = ctx_r4.$implicit;
    const i_r3 = ctx_r4.index;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.itemTemplate);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.itemTemplate == null ? null : ctx_r1.itemTemplate.templateRef)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c62, i_r3));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.hoveredItemTemplate && item_r4.hovered);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selectedItemTemplate && item_r4.selected && !item_r4.hovered);
    ɵɵadvance();
    ɵɵstyleProp("width", 24, "px")("height", 24, "px")("display", "block");
  }
}
function RatingComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 3);
    ɵɵlistener("mouseenter", function RatingComponent_span_1_Template_span_mouseenter_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMouseEnter($event));
    })("mouseout", function RatingComponent_span_1_Template_span_mouseout_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMouseOut());
    })("click", function RatingComponent_span_1_Template_span_click_0_listener($event) {
      const i_r3 = ɵɵrestoreView(_r1).index;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.changeValue(i_r3, $event));
    });
    ɵɵtemplate(1, RatingComponent_span_1_ng_container_1_Template, 5, 4, "ng-container", 4)(2, RatingComponent_span_1_ng_container_2_Template, 7, 13, "ng-container", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    ɵɵproperty("title", item_r4.title)("ngClass", ɵɵpureFunction2(4, _c61, item_r4.selected || item_r4.selectedIndicator, item_r4.hovered));
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r4.half);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r4.half);
  }
}
function RatingComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.label);
  }
}
var _c64 = ["canvas"];
var _c65 = ["minimize"];
var _c66 = ["maximize"];
function SignatureComponent_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 12, 1);
    ɵɵlistener("click", function SignatureComponent_button_4_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMaximize());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("hyperlinkOpenIcon"))("size", ctx_r1.size)("title", ctx_r1.maximizeTitle);
    ɵɵattribute("aria-label", ctx_r1.maximizeTitle);
  }
}
function SignatureComponent_button_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 13, 2);
    ɵɵlistener("click", function SignatureComponent_button_5_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMinimize());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("hyperlinkOpenIcon"))("size", ctx_r1.size)("title", ctx_r1.minimizeTitle);
    ɵɵattribute("aria-label", ctx_r1.minimizeTitle);
  }
}
function SignatureComponent_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 14);
  }
}
function SignatureComponent_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 15);
    ɵɵlistener("click", function SignatureComponent_button_8_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onClear());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("svgIcon", ctx_r1.svgIcon("xIcon"))("size", ctx_r1.size)("title", ctx_r1.clearTitle);
    ɵɵattribute("aria-label", ctx_r1.clearTitle);
  }
}
function SignatureComponent_kendo_dialog_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-dialog", 16);
    ɵɵlistener("click", function SignatureComponent_kendo_dialog_9_Template_kendo_dialog_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogClick($event));
    })("keydown", function SignatureComponent_kendo_dialog_9_Template_kendo_dialog_keydown_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogKeydown($event));
    });
    ɵɵelementStart(1, "kendo-signature", 17);
    ɵɵlistener("valueChange", function SignatureComponent_kendo_dialog_9_Template_kendo_signature_valueChange_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogValueChange($event));
    })("minimize", function SignatureComponent_kendo_dialog_9_Template_kendo_signature_minimize_1_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onDialogClose());
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("k-signature-maximized", true);
    ɵɵproperty("readonly", ctx_r1.readonly)("disabled", ctx_r1.disabled)("size", ctx_r1.size)("rounded", ctx_r1.rounded)("fillMode", ctx_r1.fillMode)("color", ctx_r1.color)("backgroundColor", ctx_r1.backgroundColor)("strokeWidth", ctx_r1.strokeWidth)("smooth", ctx_r1.smooth)("value", ctx_r1.popupValue)("hideLine", ctx_r1.hideLine)("maximized", true)("width", ctx_r1.popupWidth)("height", ctx_r1.popupHeight)("popupScale", ctx_r1.popupScale)("exportScale", 1 / ctx_r1.popupScale * ctx_r1.exportScale)("parentLocalization", ctx_r1.localization);
  }
}
var _c67 = [[["kendo-textarea-prefix"]], [["kendo-textarea-suffix"]]];
var _c68 = ["kendo-textarea-prefix", "kendo-textarea-suffix"];
function TextAreaComponent_kendo_input_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("orientation", ctx_r1.separatorOrientation);
  }
}
function TextAreaComponent_kendo_input_separator_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-input-separator", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("orientation", ctx_r1.separatorOrientation);
  }
}
function OTPInputSeparatorComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.separator);
  }
}
function OTPInputSeparatorComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r0.separatorIconString);
  }
}
function OTPInputSeparatorComponent_kendo_icon_wrapper_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("name", ctx_r0.separatorIconString)("svgIcon", ctx_r0.separatorSVGIcon);
  }
}
var _c69 = ["inputGroup"];
var _c70 = () => [];
function OTPInputComponent_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-otpinput-separator", 9);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("separator", ctx_r3.separator);
  }
}
function OTPInputComponent_ng_container_3_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "kendo-textbox", 7);
    ɵɵlistener("focus", function OTPInputComponent_ng_container_3_ng_container_1_Template_kendo_textbox_focus_1_listener() {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInputFocus(i_r3));
    })("input", function OTPInputComponent_ng_container_3_ng_container_1_Template_kendo_textbox_input_1_listener($event) {
      const i_r3 = ɵɵrestoreView(_r2).index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInput($event, i_r3));
    });
    ɵɵelementEnd();
    ɵɵtemplate(2, OTPInputComponent_ng_container_3_ng_container_1_kendo_otpinput_separator_2_Template, 1, 1, "kendo-otpinput-separator", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("k-invalid", ctx_r3.isControlInvalid);
    ɵɵproperty("selectOnFocus", true)("maxlength", 1)("type", ctx_r3.type !== "number" ? ctx_r3.type : null)("placeholder", ctx_r3.placeholder)("size", ctx_r3.size)("rounded", ctx_r3.rounded)("fillMode", ctx_r3.fillMode)("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.showSeparator(i_r3));
  }
}
function OTPInputComponent_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, OTPInputComponent_ng_container_3_ng_container_1_Template, 3, 12, "ng-container", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.inputsArray);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-textbox", 7);
    ɵɵlistener("focus", function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_focus_0_listener() {
      const j_r6 = ɵɵrestoreView(_r5).index;
      const i_r7 = ɵɵnextContext().index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInputFocus(j_r6, i_r7));
    })("input", function OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template_kendo_textbox_input_0_listener($event) {
      const j_r6 = ɵɵrestoreView(_r5).index;
      const i_r7 = ɵɵnextContext().index;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.handleInput($event, j_r6, i_r7));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵclassProp("k-invalid", ctx_r3.isControlInvalid);
    ɵɵproperty("selectOnFocus", true)("maxlength", 1)("type", ctx_r3.type !== "number" ? ctx_r3.type : null)("placeholder", ctx_r3.placeholder)("size", ctx_r3.size)("rounded", ctx_r3.rounded)("fillMode", ctx_r3.fillMode)("disabled", ctx_r3.disabled)("readonly", ctx_r3.readonly);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-otpinput-separator", 9);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(3);
    ɵɵproperty("separator", ctx_r3.separator);
  }
}
function OTPInputComponent_ng_template_4_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 10, 1);
    ɵɵtemplate(3, OTPInputComponent_ng_template_4_ng_container_0_kendo_textbox_3_Template, 1, 11, "kendo-textbox", 11);
    ɵɵelementEnd();
    ɵɵtemplate(4, OTPInputComponent_ng_template_4_ng_container_0_kendo_otpinput_separator_4_Template, 1, 1, "kendo-otpinput-separator", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const group_r8 = ctx.$implicit;
    const i_r7 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ɵɵpureFunction0(2, _c70).constructor(group_r8));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r3.showGroupSeparator(i_r7));
  }
}
function OTPInputComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, OTPInputComponent_ng_template_4_ng_container_0_Template, 5, 3, "ng-container", 6);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r3.adjacentGroups);
  }
}
var isPresent3 = (value) => value !== null && value !== void 0;
var areSame = (value1, value2) => value1 === value2 || value1 === null && value2 === void 0 || value1 === void 0 && value2 === null;
var requiresZoneOnBlur = (ngControl) => ngControl && (!ngControl.touched || ngControl.control && ngControl.control.updateOn === "blur");
var fitIntoBounds = (contender, min, max) => {
  if (!isPresent3(contender) || isNaN(contender)) {
    return min;
  }
  return contender <= min ? min : contender >= max ? max : contender;
};
var SIZE_MAP = {
  small: "sm",
  medium: "md",
  large: "lg"
};
var ROUNDED_MAP = {
  small: "sm",
  medium: "md",
  large: "lg",
  full: "full"
};
var isNone = (style2) => style2 === "none";
var getStylingClasses = (componentType, stylingOption, previousValue, newValue) => {
  switch (stylingOption) {
    case "size":
      return {
        toRemove: `k-${componentType}-${SIZE_MAP[previousValue]}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${SIZE_MAP[newValue]}` : ""
      };
    case "rounded":
      return {
        toRemove: `k-rounded-${ROUNDED_MAP[previousValue]}`,
        toAdd: newValue !== "none" ? `k-rounded-${ROUNDED_MAP[newValue]}` : ""
      };
    case "fillMode":
      return {
        toRemove: `k-${componentType}-${previousValue}`,
        toAdd: newValue !== "none" ? `k-${componentType}-${newValue}` : ""
      };
    default:
      break;
  }
};
var COMPONENT_TYPE = new InjectionToken("TYPE_TOKEN");
var replaceMessagePlaceholder = (message, name, value) => message.replace(new RegExp(`{\\s*${name}\\s*}`, "g"), value);
var MAX_PRECISION = 20;
var limitPrecision = (precision) => Math.min(precision, MAX_PRECISION);
var fractionLength = (value) => {
  return (String(value).split(".")[1] || "").length;
};
var maxFractionLength = (value1, value2) => {
  return Math.max(fractionLength(value1), fractionLength(value2));
};
var toFixedPrecision = (value, precision) => {
  const maxPrecision = limitPrecision(precision);
  return parseFloat(value.toFixed(maxPrecision));
};
var add = (value1, value2) => {
  const maxPrecision = maxFractionLength(value1, value2);
  return toFixedPrecision(value1 + value2, maxPrecision);
};
var subtract = (value1, value2) => {
  return add(value1, -value2);
};
var multiply = (value1, value2) => {
  const maxPrecision = fractionLength(value1) + fractionLength(value2);
  return toFixedPrecision(value1 * value2, maxPrecision);
};
var divide = (dividend, divisor) => {
  if (divisor === 0) {
    return NaN;
  }
  const power = maxFractionLength(dividend, divisor);
  const correctionValue = Math.pow(10, power);
  return correctionValue * dividend / (correctionValue * divisor);
};
var remainder = (dividend, divisor) => {
  return Math.abs(subtract(dividend, multiply(divisor, Math.floor(divide(dividend, divisor)))));
};
var calculateFixedTrackSize = ({
  max,
  min,
  smallStep,
  fixedTickWidth
}) => (max - min) / smallStep * fixedTickWidth;
var calculateTicksCount = (min = 0, max = 0, smallStep = 1) => {
  if (smallStep <= 0) {
    throw new Error("Invalid argument: smallStep must be a positive number");
  }
  const adjustedRange = Math.abs(subtract(max, min));
  const adjustedRatio = Math.floor(divide(adjustedRange, smallStep));
  const result = add(adjustedRatio, 1);
  return result;
};
var calculateValueFromTick = (index, {
  max,
  min,
  smallStep,
  reverse,
  vertical
}) => {
  const value = add(min, multiply(index, smallStep));
  return vertical || reverse ? Math.abs(subtract(value, max)) : value;
};
var calculateHandlePosition = ({
  trackWidth,
  min,
  max,
  value
}) => {
  const step = trackWidth / Math.abs(max - min);
  const pos = isPresent3(value) ? step * (value - min) : min;
  return Math.floor(pos);
};
var decreaseValueToStep = (value, {
  max,
  min,
  smallStep,
  largeStep
}, large = false) => {
  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
  const stepValue = subtract(value, min);
  let result;
  const stepRemainder = remainder(stepValue, step);
  if (stepRemainder === 0) {
    result = subtract(stepValue, step);
  } else {
    result = subtract(stepValue, stepRemainder);
  }
  return limitValue2(add(result, min), min, max);
};
var increaseValueToStep = (value, {
  max,
  min,
  smallStep,
  largeStep
}, large = false) => {
  const step = large && largeStep ? multiply(smallStep, largeStep) : smallStep;
  const stepValue = subtract(value, min);
  const stepRemainder = remainder(stepValue, step);
  const result = add(subtract(stepValue, stepRemainder), step);
  return limitValue2(add(result, min), min, max);
};
var isStartHandle = (dragHandle) => dragHandle.id.indexOf("k-start-handle") > -1;
var snapValue = (value, options) => {
  const {
    smallStep,
    min,
    max
  } = options;
  const limited = limitValue2(value, min, max);
  if (value !== limited) {
    return limited;
  }
  const left = decreaseValueToStep(value, options);
  const right = increaseValueToStep(value, options);
  if ((value - min) % smallStep === 0) {
    return value;
  }
  if (right - value <= (right - left) / 2) {
    return right;
  }
  return left;
};
var trimValue = (max, min, value) => {
  if (value > max) {
    return max;
  }
  if (value < min) {
    return min;
  }
  return value;
};
var trimValueRange = (max, min, value) => {
  return value ? [trimValue(max, min, value[0]), trimValue(max, min, value[1])] : [min, min];
};
var identity = (value) => value;
var isSameRange = (value1, value2) => areSame(value1[0], value2[0]) && areSame(value1[1], value2[1]);
var elementOffset2 = (element) => {
  const box = element.getBoundingClientRect();
  const documentElement = document.documentElement;
  return {
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0),
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0)
  };
};
var limitValue2 = (value, min, max) => {
  return Math.max(Math.min(value, max), min);
};
var eventValue = (eventArgs, scaleElement, options) => {
  const {
    min,
    max,
    vertical,
    rtl
  } = options;
  const trackOffset = elementOffset2(scaleElement);
  const offset = vertical ? eventArgs.pageY - trackOffset.top : eventArgs.pageX - trackOffset.left;
  const scale = (max - min) / (vertical ? scaleElement.clientHeight : scaleElement.clientWidth);
  const offsetValue = offset * scale;
  let value = rtl || vertical ? max - offsetValue : min + offsetValue;
  const stepFractionLength = fractionLength(options.smallStep);
  value = toFixedPrecision(value, stepFractionLength + 1);
  return snapValue(value, options);
};
var increment = (options) => {
  return increaseValueToStep(options.value, options);
};
var decrement = (options) => {
  return decreaseValueToStep(options.value, options);
};
var incrementLarge = (options) => {
  return increaseValueToStep(options.value, options, true);
};
var decrementLarge = (options) => {
  return decreaseValueToStep(options.value, options, true);
};
var validateValue = (value) => {
  if (isDevMode && value && value[0] > value[1]) {
    throw new Error("[RangeSlider] The start value should not be greater than the end value.");
  }
};
var SliderModelBase = class {
  props;
  wrapper;
  track;
  renderer;
  button;
  tickSizes;
  constructor(props, wrapper, track, renderer, button) {
    this.props = props;
    this.wrapper = wrapper;
    this.track = track;
    this.renderer = renderer;
    this.button = button;
    this.props = props;
    this.wrapper = wrapper;
    this.track = track;
    this.tickSizes = this.getTickSizes();
  }
  resizeTrack() {
    const orientation = this.props.vertical ? "height" : "width";
    const altOrientation = this.props.vertical ? "width" : "height";
    const trackWidth = this.trackWidth();
    this.track.parentElement.style[orientation] = `${trackWidth}px`;
    this.track.parentElement.style[altOrientation] = "";
  }
  resizeTicks(ticksContainer, ticks) {
    const dimension = this.props.vertical ? "height" : "width";
    [...ticks].map((tick, index) => tick.style[dimension] = `${this.tickSizes[index]}px`);
    if (this.props.vertical) {
      this.adjustPadding(ticksContainer);
    }
  }
  resizeWrapper() {
    const dimension = this.props.vertical ? "height" : "width";
    const fixedTrackWidth = calculateFixedTrackSize(this.props);
    const wrapperParentEl = this.wrapper.parentElement;
    if (fixedTrackWidth) {
      wrapperParentEl.style[dimension] = "auto";
    }
  }
  trackWidth() {
    if (this.props.fixedTickWidth) {
      return calculateFixedTrackSize(this.props);
    }
    const wrapperWidth = this.elementSize(this.wrapper.parentElement);
    const trackOffset = this.getTrackOffset();
    return wrapperWidth - trackOffset;
  }
  getTickSizes() {
    const {
      min,
      max,
      smallStep
    } = this.props;
    const count = calculateTicksCount(min, max, smallStep);
    const trackSize = this.trackWidth();
    const distStep = trackSize / subtract(max, min);
    const result = [];
    let usedSpace = 0;
    let endPoint = 0;
    for (let i = 0; i < count; i++) {
      if (i === 0 || i === count - 1) {
        endPoint += smallStep / 2 * distStep;
      } else {
        endPoint += smallStep * distStep;
      }
      endPoint = +endPoint.toFixed(2) - 0.01;
      const size = Math.round(endPoint - usedSpace);
      result.push(size);
      usedSpace += size;
    }
    if (usedSpace >= trackSize) {
      result[result.length - 1] -= 1;
    }
    return result;
  }
  adjustPadding(ticksContainer) {
    const totalTickSize = this.tickSizes.reduce((prev, curr) => prev + curr, 0);
    const trackWidth = this.trackWidth();
    const reminder = trackWidth - totalTickSize;
    if (reminder !== 0) {
      const padding = reminder + this.elementOffset(this.track);
      ticksContainer.style.paddingTop = `${padding}px`;
    }
  }
  elementOffset(element) {
    const {
      vertical
    } = this.props;
    const style2 = getComputedStyle(element);
    return parseInt(vertical ? style2.bottom : style2.left, 10);
  }
  elementSize(element) {
    const {
      vertical
    } = this.props;
    return vertical ? element.clientHeight : element.clientWidth;
  }
  getTrackOffset() {
    const showButtons = this.props.buttons && isPresent3(this.button);
    if (!showButtons) {
      return 0;
    }
    const BUTTONS_COUNT = 2;
    const buttonStyles = this.button.nativeElement.getBoundingClientRect();
    const wrapperGap = parseInt(window.getComputedStyle(this.wrapper.parentElement).gap);
    const buttonSize = this.props.vertical ? buttonStyles?.height : buttonStyles?.width;
    return (buttonSize + wrapperGap) * BUTTONS_COUNT;
  }
};
var SliderModel = class extends SliderModelBase {
  handlePosition;
  positionHandle(dragHandle) {
    const {
      max,
      min,
      reverse,
      vertical
    } = this.props;
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const trackWidth = this.trackWidth();
    const value = trimValue(max, min, this.props.value);
    this.handlePosition = calculateHandlePosition({
      min,
      max,
      reverse,
      value,
      trackWidth
    });
    this.renderer.setStyle(dragHandle, position, `${this.handlePosition}px`);
  }
  positionSelection(selection) {
    const {
      vertical
    } = this.props;
    const dimension = vertical ? "height" : "width";
    const size = this.handlePosition;
    this.renderer.setStyle(selection, dimension, `${size}px`);
  }
};
var UNTOUCHED = "ng-untouched";
var toClassList = (classNames) => String(classNames).trim().split(" ");
var hasClass = (element, className) => Boolean(toClassList(element.className).find((name) => name === className));
function invokeElementMethod(element, name, ...args) {
  if (element && element.nativeElement) {
    return element.nativeElement[name].apply(element.nativeElement, args);
  }
}
var isUntouched = (element) => element && element.nativeElement && hasClass(element.nativeElement, UNTOUCHED);
var containsFocus = (hostElement, contender) => hostElement && contender && (hostElement === contender || hostElement.contains(contender));
var closest2 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var packageMetadata2 = {
  name: "@progress/kendo-angular-inputs",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1751463027,
  version: "19.2.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var LabelTemplateDirective = class _LabelTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LabelTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LabelTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LabelTemplateDirective,
    selectors: [["", "kendoSliderLabelTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoSliderLabelTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var SliderBase = class _SliderBase {
  localizationService;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * Sets the title for the ticks.
   * The default title for each tick is its Slider value.
   * If you use a callback function, the function receives the component value and returns a string for the new title [see example]({% slug ticks_slider %}#toc-titles).
   */
  title = identity;
  /**
   * Sets the location of the tick marks in the Slider [see example]({% slug ticks_slider %}#toc-placement).
   *
   * The options are:
   * - `before` – Shows tick marks above a horizontal track or left of a vertical track.
   * - `after` – Shows tick marks below a horizontal track or right of a vertical track.
   * - `both` – Shows tick marks on both sides of the track.
   * - `none` – Hides tick marks and removes them from the DOM.
   *
   * @default 'both'
   */
  tickPlacement = "both";
  /**
   * When `true`. renders a vertical Slider [see example]({% slug orientation_slider %}).
   *
   * @default false
   */
  vertical = false;
  /**
   * Sets the minimum value of the Slider.
   * Accepts integers and floating-point numbers [see example]({% slug predefinedsteps_slider %}#toc-small-steps).
   *
   * @default 0
   */
  min = 0;
  /**
   * Sets the maximum value of the Slider.
   * Accepts integers and floating-point numbers [see example]({% slug predefinedsteps_slider %}#toc-small-steps).
   *
   * @default 10
   */
  max = 10;
  /**
   * Sets the step value of the Slider.
   * Accepts only positive values.
   * Can be an integer or a floating-point number [see example]({% slug predefinedsteps_slider %}#toc-small-steps).
   *
   * @default 1
   */
  smallStep = 1;
  /**
   * Sets every n<sup>th</sup> tick as large and shows a label for it [see example]({% slug predefinedsteps_slider %}#toc-large-steps).
   *
   * @default null
   */
  largeStep = null;
  /**
   * Sets the width between two ticks along the track, in pixels.
   * If you do not set `fixedTickWidth`, the Slider adjusts the tick width automatically [see example]({% slug ticks_slider %}#toc-width).
   *
   */
  fixedTickWidth;
  /**
   * When `true`, disables the Slider.
   * To disable the component in reactive forms, see [Forms Support](slug:formssupport_slider#toc-managing-the-slider-disabled-state-in-reactive-forms) [see example]({% slug disabledstate_slider %}).
   *
   * @default false
   */
  disabled = false;
  /**
   * When `true`, sets the Slider to read-only [see example]({% slug readonly_slider %}).
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Slider.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * Fires when the user focuses the component.
   *
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the component is blurred.
   *
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the user selects a new value.
   *
   */
  valueChange = new EventEmitter();
  direction;
  get horizontalClass() {
    return !this.vertical;
  }
  get verticalClass() {
    return this.vertical;
  }
  sliderClass = true;
  get disabledClass() {
    return this.disabled;
  }
  wrapper;
  track;
  sliderSelection;
  ticksContainer;
  ticks;
  labelTemplate;
  subscriptions = new Subscription();
  isFocused;
  isDragged;
  control;
  constructor(localizationService, injector, renderer, ngZone, changeDetector, hostElement) {
    this.localizationService = localizationService;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  ngOnInit() {
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.sizeComponent();
    }));
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
  }
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  /**
   * @hidden
   */
  ifEnabled = (callback, event) => {
    if (!this.isDisabled) {
      callback.call(this, event);
    }
  };
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  get reverse() {
    return this.localizationService.rtl && !this.vertical;
  }
  get keyBinding() {
    const reverse = this.reverse;
    return {
      [Keys.ArrowLeft]: reverse ? increment : decrement,
      [Keys.ArrowRight]: reverse ? decrement : increment,
      [Keys.ArrowDown]: decrement,
      [Keys.ArrowUp]: increment,
      [Keys.PageUp]: incrementLarge,
      [Keys.PageDown]: decrementLarge,
      [Keys.Home]: ({
        min
      }) => min,
      [Keys.End]: ({
        max
      }) => max
    };
  }
  resetStyles(elements) {
    elements.forEach((el) => {
      if (el) {
        if (this.vertical) {
          this.renderer.removeStyle(el, "width");
          this.renderer.removeStyle(el, "left");
          this.renderer.removeStyle(el, "right");
        } else {
          this.renderer.removeStyle(el, "height");
          this.renderer.removeStyle(el, "bottom");
        }
        this.renderer.removeStyle(el, "padding-top");
      }
    });
  }
  static ɵfac = function SliderBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderBase,
    selectors: [["kendo-slider-base"]],
    contentQueries: function SliderBase_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, LabelTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
      }
    },
    viewQuery: function SliderBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c02, 7);
        ɵɵviewQuery(_c1, 7);
        ɵɵviewQuery(_c2, 7);
        ɵɵviewQuery(_c3, 5, ElementRef);
        ɵɵviewQuery(_c3, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sliderSelection = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ticksContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.ticks = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function SliderBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-slider-horizontal", ctx.horizontalClass)("k-slider-vertical", ctx.verticalClass)("k-slider", ctx.sliderClass)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      title: "title",
      tickPlacement: "tickPlacement",
      vertical: "vertical",
      min: "min",
      max: "max",
      smallStep: "smallStep",
      largeStep: "largeStep",
      fixedTickWidth: "fixedTickWidth",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    decls: 0,
    vars: 0,
    template: function SliderBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderBase, [{
    type: Component,
    args: [{
      selector: "kendo-slider-base",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    title: [{
      type: Input
    }],
    tickPlacement: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    smallStep: [{
      type: Input
    }],
    largeStep: [{
      type: Input
    }],
    fixedTickWidth: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    horizontalClass: [{
      type: HostBinding,
      args: ["class.k-slider-horizontal"]
    }],
    verticalClass: [{
      type: HostBinding,
      args: ["class.k-slider-vertical"]
    }],
    sliderClass: [{
      type: HostBinding,
      args: ["class.k-slider"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    wrapper: [{
      type: ViewChild,
      args: ["wrap", {
        static: true
      }]
    }],
    track: [{
      type: ViewChild,
      args: ["track", {
        static: true
      }]
    }],
    sliderSelection: [{
      type: ViewChild,
      args: ["sliderSelection", {
        static: true
      }]
    }],
    ticksContainer: [{
      type: ViewChild,
      args: ["ticks", {
        read: ElementRef,
        static: false
      }]
    }],
    ticks: [{
      type: ViewChild,
      args: ["ticks", {
        static: false
      }]
    }],
    labelTemplate: [{
      type: ContentChild,
      args: [LabelTemplateDirective, {
        static: false
      }]
    }]
  });
})();
var SliderTick = class {
  value;
  classes = {
    "k-tick": true
  };
  large;
  constructor(value) {
    this.value = value;
  }
};
var SliderTicksComponent = class _SliderTicksComponent {
  wrapperClasses = "k-reset k-slider-items";
  tickTitle;
  vertical;
  step;
  largeStep;
  min;
  max;
  labelTemplate;
  tickElements;
  ticks = [];
  ngOnChanges(_) {
    this.createTicks();
  }
  createTicks() {
    const count = calculateTicksCount(this.min, this.max, this.step);
    const largeStep = this.largeStep;
    const tickValueProps = {
      max: this.max,
      min: this.min,
      smallStep: this.step
    };
    const result = [];
    for (let i = 0; i < count; i++) {
      result.push(new SliderTick(calculateValueFromTick(i, tickValueProps)));
      if (largeStep && i % largeStep === 0) {
        result[i].large = true;
        result[i].classes["k-tick-large"] = true;
      }
    }
    if (result.length > 0) {
      Object.assign(result[0].classes, this.endTickClasses(true));
      Object.assign(result[result.length - 1].classes, this.endTickClasses(false));
    }
    this.ticks = result;
  }
  endTickClasses(first) {
    return {
      "k-first": first && !this.vertical || !first && this.vertical,
      "k-last": !first && !this.vertical || first && this.vertical
    };
  }
  static ɵfac = function SliderTicksComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderTicksComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderTicksComponent,
    selectors: [["", "kendoSliderTicks", ""]],
    viewQuery: function SliderTicksComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c4, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tickElements = _t);
      }
    },
    hostVars: 2,
    hostBindings: function SliderTicksComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassMap(ctx.wrapperClasses);
      }
    },
    inputs: {
      tickTitle: "tickTitle",
      vertical: "vertical",
      step: "step",
      largeStep: "largeStep",
      min: "min",
      max: "max",
      labelTemplate: "labelTemplate"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c5,
    decls: 3,
    vars: 1,
    consts: [["defaultLabel", ""], ["tickElement", ""], ["role", "presentation", 3, "ngClass", "title", 4, "ngFor", "ngForOf"], ["role", "presentation", 3, "ngClass", "title"], [3, "ngSwitch"], ["class", "k-label", 4, "ngSwitchCase"], [4, "ngSwitchCase"], [1, "k-label"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function SliderTicksComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, SliderTicksComponent_li_0_Template, 5, 5, "li", 2)(1, SliderTicksComponent_ng_template_1_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.ticks);
      }
    },
    dependencies: [NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderTicksComponent, [{
    type: Component,
    args: [{
      selector: "[kendoSliderTicks]",
      template: `
    <li #tickElement *ngFor="let tick of ticks;"
        [ngClass]="tick.classes"
        title="{{ tickTitle(tick.value) }}"
        role="presentation"
     >
         <ng-container [ngSwitch]="tick.large">
            <span class="k-label" *ngSwitchCase="true">
                <ng-container [ngTemplateOutlet]="labelTemplate || defaultLabel" [ngTemplateOutletContext]="tick">
                </ng-container>
            </span>
            <ng-container *ngSwitchCase="false">&nbsp;</ng-container>
         </ng-container>
     </li>

     <ng-template #defaultLabel let-value="value">
        {{ tickTitle(value) }}
     </ng-template>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgSwitch, NgSwitchCase, NgTemplateOutlet]
    }]
  }], null, {
    wrapperClasses: [{
      type: HostBinding,
      args: ["class"]
    }],
    tickTitle: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    largeStep: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    tickElements: [{
      type: ViewChildren,
      args: ["tickElement"]
    }]
  });
})();
var SliderMessages = class _SliderMessages extends ComponentMessages {
  /**
   * The title of the **Decrease** button of the Slider.
   */
  decrement;
  /**
   * The title of the **Increase** button of the Slider.
   */
  increment;
  /**
   * The title of the drag handle of the Slider.
   */
  dragHandle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSliderMessages_BaseFactory;
    return function SliderMessages_Factory(__ngFactoryType__) {
      return (ɵSliderMessages_BaseFactory || (ɵSliderMessages_BaseFactory = ɵɵgetInheritedFactory(_SliderMessages)))(__ngFactoryType__ || _SliderMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SliderMessages,
    selectors: [["kendo-slider-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment",
      dragHandle: "dragHandle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-slider-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }],
    dragHandle: [{
      type: Input
    }]
  });
})();
var LocalizedSliderMessagesDirective = class _LocalizedSliderMessagesDirective extends SliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSliderMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSliderMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSliderMessagesDirective,
    selectors: [["", "kendoSliderLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SliderMessages,
      useExisting: forwardRef(() => _LocalizedSliderMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSliderMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: SliderMessages,
        useExisting: forwardRef(() => LocalizedSliderMessagesDirective)
      }],
      selector: "[kendoSliderLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PRESSED$1 = "k-pressed";
var SliderComponent = class _SliderComponent extends SliderBase {
  localization;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Changes the `title` attribute of the drag handle. Use this property to localize the drag handle title.
   */
  dragHandleTitle;
  /**
   * Sets the title of the **Increase** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
   */
  incrementTitle;
  /**
   * Determines if the component animates when the value changes.
   * The component does not animate during initial rendering.
   * @default true
   */
  animate = true;
  /**
   * Sets the title of the **Decrease** button of the Slider ([see example]({% slug sidebuttons_slider %}#toc-titles)).
   */
  decrementTitle;
  /**
   * Shows or hides the arrow side buttons of the Slider ([see example]({% slug sidebuttons_slider %}#toc-hidden-state)).
   * When you set `showButtons` to `false`, the component does not display the buttons.
   * @default true
   */
  showButtons = true;
  /**
   * Sets the current value of the Slider when it first appears.
   * Use either `ngModel` or the `value` binding, but not both at the same time.
   * @default 0
   */
  value = this.min;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  get currentValue() {
    return isPresent3(this.value) ? this.value.toString() : "";
  }
  /**
   * @hidden
   */
  arrowUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  arrowLeftIcon = caretAltLeftIcon;
  /**
   * @hidden
   */
  arrowRightIcon = caretAltRightIcon;
  draghandle;
  decreaseButton;
  increaseButton;
  focusChangedProgrammatically = false;
  isInvalid;
  constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
    super(localization, injector, renderer, ngZone, changeDetector, hostElement);
    this.localization = localization;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
  }
  /**
   * Focuses the Slider.
   */
  focus() {
    if (!this.disabled) {
      this.focusChangedProgrammatically = true;
      invokeElementMethod(this.draghandle, "focus");
      this.focusChangedProgrammatically = false;
    }
  }
  /**
   * Blurs the Slider.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    invokeElementMethod(this.draghandle, "blur");
    this.handleBlur();
    this.focusChangedProgrammatically = false;
  }
  ngOnChanges(changes) {
    if (anyChanged(["value", "fixedTickWidth", "tickPlacement"], changes, true)) {
      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        this.sizeComponent(false);
      });
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.showButtons) {
      this.setValueChangeInterval(this.increaseButton.nativeElement, () => this.increaseValue());
      this.setValueChangeInterval(this.decreaseButton.nativeElement, () => this.decreaseValue());
    }
    this.sizeComponent(false);
    if (this.ticks) {
      this.ticks.tickElements.changes.subscribe(() => this.sizeComponent(false));
    }
    this.attachElementEventHandlers();
    this.isSliderInvalid();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get incrementMessage() {
    return this.incrementTitle || this.localizationService.get("increment");
  }
  /**
   * @hidden
   */
  get decrementMessage() {
    return this.decrementTitle || this.localizationService.get("decrement");
  }
  /**
   * @hidden
   */
  get dragHandleMessage() {
    return this.dragHandleTitle || this.localizationService.get("dragHandle");
  }
  /**
   * @hidden
   */
  onWrapClick = (args) => {
    const target = args.target;
    if (!this.isDisabled && !target.closest(".k-button")) {
      const value = eventValue(args, this.track.nativeElement, this.getProps());
      this.changeValue(value);
    }
    invokeElementMethod(this.draghandle, "focus");
  };
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (args.originalEvent) {
      args.originalEvent.preventDefault();
    }
    this.renderer.removeClass(this.hostElement.nativeElement, "k-slider-transitions");
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    this.dragging = true;
    this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
  }
  /**
   * @hidden
   */
  onKeyDown = (e) => {
    const options = this.getProps();
    const {
      max,
      min
    } = options;
    const handler = this.keyBinding[e.keyCode];
    if (this.isDisabled || !handler) {
      return;
    }
    const value = handler(options);
    this.changeValue(trimValue(max, min, value));
    e.preventDefault();
  };
  /**
   * @hidden
   */
  onHandleRelease() {
    this.dragging = false;
    this.renderer.addClass(this.hostElement.nativeElement, "k-slider-transitions");
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value) {
    this.changeDetector.markForCheck();
    this.value = value;
    this.sizeComponent(this.animate);
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  changeValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.sizeComponent(this.animate);
        this.changeDetector.markForCheck();
      });
    }
    this.isSliderInvalid();
  }
  /**
   * @hidden
   */
  sizeComponent(animate2) {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const track = this.track.nativeElement;
    const selectionEl = this.sliderSelection.nativeElement;
    const dragHandleEl = this.draghandle.nativeElement;
    const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
    if (!animate2) {
      this.renderer.removeClass(this.hostElement.nativeElement, "k-slider-transitions");
    }
    this.resetStyles([track, selectionEl, dragHandleEl, ticks, this.hostElement.nativeElement]);
    const props = this.getProps();
    const model = new SliderModel(props, wrapper, track, this.renderer, this.increaseButton);
    model.resizeTrack();
    if (this.ticks) {
      model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map((element) => element.nativeElement));
    }
    model.positionHandle(dragHandleEl);
    model.positionSelection(selectionEl);
    if (!animate2) {
      this.hostElement.nativeElement.getBoundingClientRect();
      this.renderer.addClass(this.hostElement.nativeElement, "k-slider-transitions");
    }
    if (this.fixedTickWidth) {
      model.resizeWrapper();
    }
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      this.isFocused = value;
    }
  }
  set dragging(value) {
    if (this.isDragged !== value && this.sliderSelection && this.draghandle) {
      const sliderSelection = this.sliderSelection.nativeElement;
      const draghandle = this.draghandle.nativeElement;
      if (value) {
        this.renderer.addClass(sliderSelection, PRESSED$1);
        this.renderer.addClass(draghandle, PRESSED$1);
      } else {
        this.renderer.removeClass(sliderSelection, PRESSED$1);
        this.renderer.removeClass(draghandle, PRESSED$1);
      }
      this.isDragged = value;
    }
  }
  setValueChangeInterval(element, callback) {
    this.ngZone.runOutsideAngular(() => {
      const pointerdown = fromEvent(element, "pointerdown");
      const pointerup = fromEvent(element, "pointerup");
      const pointerout = fromEvent(element, "pointerout");
      const subscription = pointerdown.pipe(tap((e) => e.preventDefault()), filter((e) => e.button === 0 && !this.isDisabled), concatMap(() => interval(150).pipe(startWith(-1), takeUntil(merge(pointerup, pointerout))))).subscribe(() => {
        if (!this.isFocused) {
          invokeElementMethod(this.draghandle, "focus");
        }
        callback();
      });
      this.subscriptions.add(subscription);
    });
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  decreaseValue = () => {
    this.changeValue(decreaseValueToStep(this.value, this.getProps()));
  };
  increaseValue = () => {
    this.changeValue(increaseValueToStep(this.value, this.getProps()));
  };
  getProps() {
    return {
      buttons: this.showButtons,
      disabled: this.disabled,
      fixedTickWidth: this.fixedTickWidth,
      largeStep: this.largeStep,
      max: this.max,
      min: this.min,
      readonly: this.readonly,
      reverse: this.reverse,
      rtl: this.localizationService.rtl,
      smallStep: this.smallStep,
      value: trimValue(this.max, this.min, this.value),
      vertical: this.vertical
    };
  }
  isSliderInvalid() {
    const sliderClasses = this.hostElement.nativeElement.classList;
    this.isInvalid = sliderClasses.contains("ng-invalid") ? true : false;
    this.renderer.setAttribute(this.draghandle.nativeElement, "aria-invalid", `${this.isInvalid}`);
  }
  attachElementEventHandlers() {
    const hostElement = this.hostElement.nativeElement;
    let tabbing = false;
    let cursorInsideWrapper = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        if (!this.isFocused) {
          this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
              this.onFocus.emit();
            }
            this.focused = true;
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          if (args.relatedTarget !== this.draghandle.nativeElement) {
            this.handleBlur();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper) {
            this.handleBlur();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        if (!this.focusChangedProgrammatically) {
          this.onBlur.emit();
        }
      });
    }
  };
  get decreaseButtonArrowIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? "caret-alt-left" : "caret-alt-right" : "caret-alt-down";
    return icon;
  }
  get increaseButtonArrowIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? "caret-alt-right" : "caret-alt-left" : "caret-alt-up";
    return icon;
  }
  get decreaseButtonArrowSVGIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? this.arrowLeftIcon : this.arrowRightIcon : this.arrowDownIcon;
    return icon;
  }
  get increaseButtonArrowSVGIcon() {
    const icon = !this.vertical ? this.direction === "ltr" ? this.arrowRightIcon : this.arrowLeftIcon : this.arrowUpIcon;
    return icon;
  }
  static ɵfac = function SliderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderComponent,
    selectors: [["kendo-slider"]],
    viewQuery: function SliderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c6, 7);
        ɵɵviewQuery(_c7, 5, ElementRef);
        ɵɵviewQuery(_c8, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandle = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.decreaseButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.increaseButton = _t.first);
      }
    },
    inputs: {
      focusableId: "focusableId",
      dragHandleTitle: "dragHandleTitle",
      incrementTitle: "incrementTitle",
      animate: "animate",
      decrementTitle: "decrementTitle",
      showButtons: "showButtons",
      value: "value",
      tabIndex: "tabIndex"
    },
    exportAs: ["kendoSlider"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.slider"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SliderComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _SliderComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 13,
    vars: 23,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_0 = goog.getMsg("increment");
        i18n_0 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.slider.increment|The title of the **Increase** button of the Slider.:increment`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_1 = goog.getMsg("decrement");
        i18n_1 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.slider.decrement|The title of the **Decrease** button of the Slider.:decrement`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_2 = goog.getMsg("Drag");
        i18n_2 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.slider.dragHandle|The title of the drag handle of the Slider.:Drag`;
      }
      return [["wrap", ""], ["track", ""], ["sliderSelection", ""], ["draghandle", ""], ["decreaseButton", ""], ["ticks", ""], ["increaseButton", ""], ["kendoSliderLocalizedMessages", "", "increment", i18n_0, "decrement", i18n_1, "dragHandle", i18n_2], ["kendoButton", "", "type", "button", "rounded", "full", "class", "k-button-decrease", "aria-hidden", "true", 3, "icon", "svgIcon", "title", 4, "ngIf"], [1, "k-slider-track-wrap", 3, "kendoEventsOutsideAngular"], ["kendoSliderTicks", "", "aria-hidden", "true", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], [1, "k-slider-selection"], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", "k-draghandle-end", 3, "kendoPress", "kendoDrag", "kendoRelease", "title", "id"], ["kendoButton", "", "type", "button", "rounded", "full", "class", "k-button-increase", "aria-hidden", "true", 3, "icon", "svgIcon", "title", 4, "ngIf"], [3, "resize"], ["kendoButton", "", "type", "button", "rounded", "full", "aria-hidden", "true", 1, "k-button-decrease", 3, "icon", "svgIcon", "title"], ["kendoSliderTicks", "", "aria-hidden", "true", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"], ["kendoButton", "", "type", "button", "rounded", "full", "aria-hidden", "true", 1, "k-button-increase", 3, "icon", "svgIcon", "title"]];
    },
    template: function SliderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 7);
        ɵɵtemplate(1, SliderComponent_button_1_Template, 2, 4, "button", 8);
        ɵɵelementStart(2, "div", 9, 0);
        ɵɵtemplate(4, SliderComponent_ul_4_Template, 2, 7, "ul", 10);
        ɵɵelementStart(5, "div", 11, 1);
        ɵɵelement(7, "div", 12, 2);
        ɵɵelementStart(9, "span", 13, 3);
        ɵɵlistener("kendoPress", function SliderComponent_Template_span_kendoPress_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function SliderComponent_Template_span_kendoDrag_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function SliderComponent_Template_span_kendoRelease_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd()()();
        ɵɵtemplate(11, SliderComponent_button_11_Template, 2, 4, "button", 14);
        ɵɵelementStart(12, "kendo-resize-sensor", 15);
        ɵɵlistener("resize", function SliderComponent_Template_kendo_resize_sensor_resize_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sizeComponent(false));
        });
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showButtons);
        ɵɵadvance();
        ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(20, _c9, ctx.onWrapClick, ctx.onKeyDown));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵɵadvance(5);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("title", ctx.dragHandleMessage)("id", ctx.focusableId);
        ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.currentValue)("aria-valuetext", ctx.currentValue)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal")("tabindex", ctx.disabled ? "-1" : ctx.tabIndex);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showButtons);
      }
    },
    dependencies: [LocalizedSliderMessagesDirective, NgIf, ButtonComponent, EventsOutsideAngularDirective, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSlider",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.slider"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SliderComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => SliderComponent)
      }],
      selector: "kendo-slider",
      template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-increment="kendo.slider.increment|The title of the **Increase** button of the Slider."
            increment="increment"
            i18n-decrement="kendo.slider.decrement|The title of the **Decrease** button of the Slider."
            decrement="decrement"
            i18n-dragHandle="kendo.slider.dragHandle|The title of the drag handle of the Slider."
            dragHandle="Drag"
        >
        <button
            kendoButton
            #decreaseButton
            *ngIf="showButtons"
            type="button"
            rounded="full"
            [icon]="decreaseButtonArrowIcon"
            [svgIcon]="decreaseButtonArrowSVGIcon"
            class="k-button-decrease"
            [title]="decrementMessage"
            aria-hidden="true"
            [attr.tabindex]="-1"
        ></button>
        <div
            #wrap
            class="k-slider-track-wrap"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
        >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                aria-hidden="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <span #draghandle
                    role="slider"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="currentValue"
                    [attr.aria-valuetext]="currentValue"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle k-draghandle-end"
                    [title]="dragHandleMessage"
                    [attr.tabindex]="disabled ? '-1' : tabIndex"
                    [id]="focusableId"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress, $event)"
                    (kendoDrag)="ifEnabled(onHandleDrag, $event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
            </div>
        </div>
        <button
            kendoButton
            #increaseButton
            *ngIf="showButtons"
            type="button"
            rounded="full"
            [icon]="increaseButtonArrowIcon"
            [svgIcon]="increaseButtonArrowSVGIcon"
            class="k-button-increase"
            [title]="incrementMessage"
            [attr.tabindex]="-1"
            aria-hidden="true"
        ></button>
        <kendo-resize-sensor (resize)="sizeComponent(false)"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedSliderMessagesDirective, NgIf, ButtonComponent, EventsOutsideAngularDirective, SliderTicksComponent, DraggableDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    dragHandleTitle: [{
      type: Input
    }],
    incrementTitle: [{
      type: Input
    }],
    animate: [{
      type: Input
    }],
    decrementTitle: [{
      type: Input
    }],
    showButtons: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    draghandle: [{
      type: ViewChild,
      args: ["draghandle", {
        static: true
      }]
    }],
    decreaseButton: [{
      type: ViewChild,
      args: ["decreaseButton", {
        read: ElementRef
      }]
    }],
    increaseButton: [{
      type: ViewChild,
      args: ["increaseButton", {
        read: ElementRef
      }]
    }]
  });
})();
var RangeSliderModel = class extends SliderModelBase {
  startHandlePosition;
  endHandlePosition;
  positionHandle(dragHandle) {
    if (!dragHandle.id) {
      return;
    }
    const {
      max,
      min,
      reverse,
      vertical
    } = this.props;
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const trackWidth = this.trackWidth();
    const value = isStartHandle(dragHandle) ? trimValueRange(max, min, this.props.value)[0] : trimValueRange(max, min, this.props.value)[1];
    if (isStartHandle(dragHandle)) {
      this.startHandlePosition = calculateHandlePosition({
        min,
        max,
        reverse,
        value,
        trackWidth
      });
      this.renderer.setStyle(dragHandle, position, `${this.startHandlePosition}px`);
    } else {
      this.endHandlePosition = calculateHandlePosition({
        min,
        max,
        reverse,
        value,
        trackWidth
      });
      this.renderer.setStyle(dragHandle, position, `${this.endHandlePosition}px`);
    }
  }
  positionSelection(dragHandle, selection) {
    const {
      reverse,
      vertical
    } = this.props;
    const dimension = vertical ? "height" : "width";
    const position = vertical ? "bottom" : reverse ? "right" : "left";
    const size = Math.abs(this.endHandlePosition - this.startHandlePosition);
    const currentSelectionPosition = vertical ? dragHandle.style.bottom : reverse ? dragHandle.style.right : dragHandle.style.left;
    this.renderer.setStyle(selection, dimension, `${size}px`);
    this.renderer.setStyle(selection, position, parseFloat(currentSelectionPosition) + "px");
  }
};
var RangeSliderMessages = class _RangeSliderMessages extends ComponentMessages {
  /**
   * The title of the range `start` drag handle.
   */
  dragHandleStart;
  /**
   * The title of the range `end` drag handle.
   */
  dragHandleEnd;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵRangeSliderMessages_BaseFactory;
    return function RangeSliderMessages_Factory(__ngFactoryType__) {
      return (ɵRangeSliderMessages_BaseFactory || (ɵRangeSliderMessages_BaseFactory = ɵɵgetInheritedFactory(_RangeSliderMessages)))(__ngFactoryType__ || _RangeSliderMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _RangeSliderMessages,
    selectors: [["kendo-rangeslider-messages-base"]],
    inputs: {
      dragHandleStart: "dragHandleStart",
      dragHandleEnd: "dragHandleEnd"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-rangeslider-messages-base"
    }]
  }], null, {
    dragHandleStart: [{
      type: Input
    }],
    dragHandleEnd: [{
      type: Input
    }]
  });
})();
var LocalizedRangeSliderMessagesDirective = class _LocalizedRangeSliderMessagesDirective extends RangeSliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedRangeSliderMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedRangeSliderMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedRangeSliderMessagesDirective,
    selectors: [["", "kendoSliderLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: RangeSliderMessages,
      useExisting: forwardRef(() => _LocalizedRangeSliderMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedRangeSliderMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: RangeSliderMessages,
        useExisting: forwardRef(() => LocalizedRangeSliderMessagesDirective)
      }],
      selector: "[kendoSliderLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PRESSED = "k-pressed";
var RangeSliderComponent = class _RangeSliderComponent extends SliderBase {
  localization;
  injector;
  renderer;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * Sets the range value of the RangeSlider.
   * Use either `ngModel` or the `value` binding, but not both at the same time.
   */
  value;
  draghandleStart;
  draghandleEnd;
  /**
   * @hidden
   */
  startHandleId = `k-start-handle-${guid()}`;
  /**
   * @hidden
   */
  endHandleId = `k-end-handle-${guid()}`;
  /**
   * @hidden
   */
  focusableId = this.startHandleId;
  draggedHandle;
  lastHandlePosition;
  activeHandle = "startHandle";
  focusChangedProgrammatically = false;
  isInvalid;
  constructor(localization, injector, renderer, ngZone, changeDetector, hostElement) {
    super(localization, injector, renderer, ngZone, changeDetector, hostElement);
    this.localization = localization;
    this.injector = injector;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
  }
  /**
   * Focuses the RangeSlider.
   *
   */
  focus() {
    this.focusChangedProgrammatically = true;
    invokeElementMethod(this.draghandleStart, "focus");
    this.focusChangedProgrammatically = false;
  }
  /**
   * Removes focus from the RangeSlider.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const activeHandle = this.activeHandle === "startHandle" ? this.draghandleStart : this.draghandleEnd;
    invokeElementMethod(activeHandle, "blur");
    this.handleBlur();
    this.focusChangedProgrammatically = false;
  }
  ngOnInit() {
    if (!this.value) {
      this.value = [this.min, this.max];
    }
    super.ngOnInit();
  }
  ngOnChanges(changes) {
    if (anyChanged(["value", "fixedTickWidth", "tickPlacement"], changes, true)) {
      if (changes["value"] && changes["value"].currentValue) {
        validateValue(changes["value"].currentValue);
      }
      this.ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => {
        this.sizeComponent();
      });
    }
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.sizeComponent();
    if (this.ticks) {
      this.ticks.tickElements.changes.subscribe(() => this.sizeComponent());
    }
    this.isRangeSliderInvalid();
    this.attachElementEventHandlers();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  get valueText() {
    return this.value ? `${this.value[0]} - ${this.value[1]}` : "";
  }
  /**
   * @hidden
   */
  onWrapClick = (args) => {
    if (!this.isDisabled) {
      this.value = this.value || [this.min, this.min];
      const trackValue = eventValue(args, this.track.nativeElement, this.getProps());
      let newRangeValue;
      const [startValue, endValue] = newRangeValue = this.value;
      if (trackValue <= startValue) {
        newRangeValue = [trackValue, endValue];
        this.activeHandle = "startHandle";
      } else if (startValue < trackValue && trackValue < endValue) {
        if (trackValue < (startValue + endValue) / 2) {
          newRangeValue = [trackValue, endValue];
          this.activeHandle = "startHandle";
        } else {
          newRangeValue = [startValue, trackValue];
          this.activeHandle = "endHandle";
        }
      } else if (trackValue >= endValue) {
        newRangeValue = [startValue, trackValue];
        this.activeHandle = "endHandle";
      }
      const activeHandle = this.activeHandle === "startHandle" ? this.draghandleStart : this.draghandleEnd;
      invokeElementMethod(activeHandle, "focus");
      this.changeValue(newRangeValue);
    }
  };
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (args.originalEvent) {
      args.originalEvent.preventDefault();
    }
    const target = args.originalEvent.target;
    this.draggedHandle = target;
    const nonDraggedHandle = this.draghandleStart.nativeElement === this.draggedHandle ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;
    this.renderer.removeStyle(nonDraggedHandle, "zIndex");
    this.renderer.setStyle(target, "zIndex", 1);
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    this.value = this.value || [this.min, this.min];
    const target = args.originalEvent.target;
    const lastCoords = this.draggedHandle.getBoundingClientRect();
    this.lastHandlePosition = {
      x: lastCoords.left,
      y: lastCoords.top
    };
    this.dragging = {
      value: true,
      target
    };
    const mousePos = {
      x: args.pageX - 0.5 - lastCoords.width / 2,
      y: args.pageY - lastCoords.width / 2
    };
    const left = mousePos.x < this.lastHandlePosition.x;
    const right = mousePos.x > this.lastHandlePosition.x;
    const up = mousePos.y > this.lastHandlePosition.y;
    const moveStartHandle = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), this.value[1]]);
    const moveEndHandle = () => this.changeValue([this.value[0], eventValue(args, this.track.nativeElement, this.getProps())]);
    const moveBothHandles = () => this.changeValue([eventValue(args, this.track.nativeElement, this.getProps()), eventValue(args, this.track.nativeElement, this.getProps())]);
    const activeStartHandle = isStartHandle(this.draggedHandle);
    const vertical = this.vertical;
    const horizontal = !vertical;
    const forward = vertical && up || (this.reverse ? horizontal && right : horizontal && left);
    const incorrectValueState = this.value[0] > this.value[1];
    if (this.value[0] === this.value[1] || incorrectValueState) {
      if (forward) {
        activeStartHandle ? moveStartHandle() : moveBothHandles();
      } else {
        activeStartHandle ? moveBothHandles() : moveEndHandle();
      }
    } else {
      activeStartHandle ? moveStartHandle() : moveEndHandle();
    }
  }
  /**
   * @hidden
   */
  onKeyDown = (e) => {
    this.value = this.value || [this.min, this.min];
    const options = this.getProps();
    const {
      max,
      min
    } = options;
    const handler = this.keyBinding[e.keyCode];
    if (this.isDisabled || !handler) {
      return;
    }
    const startHandleIsActive = isStartHandle(e.target);
    const nonDraggedHandle = startHandleIsActive ? this.draghandleEnd.nativeElement : this.draghandleStart.nativeElement;
    this.renderer.removeStyle(nonDraggedHandle, "zIndex");
    this.renderer.setStyle(e.target, "zIndex", 1);
    const value = handler(__spreadProps(__spreadValues({}, options), {
      value: startHandleIsActive ? this.value[0] : this.value[1]
    }));
    if (startHandleIsActive) {
      if (value > this.value[1]) {
        this.value[1] = value;
      }
    } else {
      if (value < this.value[0]) {
        this.value[0] = value;
      }
    }
    const trimmedValue = trimValue(max, min, value);
    const newValue = startHandleIsActive ? [trimmedValue, this.value[1]] : [this.value[0], trimmedValue];
    this.changeValue(newValue);
    e.preventDefault();
  };
  /**
   * @hidden
   */
  onHandleRelease(args) {
    this.dragging = {
      value: false,
      target: args.originalEvent.target
    };
    this.draggedHandle = void 0;
  }
  //ngModel binding
  /**
   * @hidden
   */
  writeValue(value) {
    validateValue(value);
    this.value = value;
    this.sizeComponent();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  changeValue(value) {
    if (!this.value || !isSameRange(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        if (this.value) {
          this.valueChange.emit(value);
        }
        this.sizeComponent();
      });
    }
    this.isRangeSliderInvalid();
  }
  /**
   * @hidden
   */
  sizeComponent() {
    if (!isDocumentAvailable()) {
      return;
    }
    const wrapper = this.wrapper.nativeElement;
    const track = this.track.nativeElement;
    const selectionEl = this.sliderSelection.nativeElement;
    const dragHandleStartEl = this.draghandleStart.nativeElement;
    const dragHandleEndEl = this.draghandleEnd.nativeElement;
    const ticks = this.ticks ? this.ticksContainer.nativeElement : null;
    this.resetStyles([track, selectionEl, dragHandleStartEl, dragHandleEndEl, ticks, this.hostElement.nativeElement]);
    const props = this.getProps();
    const model = new RangeSliderModel(props, wrapper, track, this.renderer);
    model.resizeTrack();
    if (this.ticks) {
      model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map((element) => element.nativeElement));
    }
    model.positionHandle(dragHandleStartEl);
    model.positionHandle(dragHandleEndEl);
    model.positionSelection(dragHandleStartEl, selectionEl);
    if (this.fixedTickWidth) {
      model.resizeWrapper();
    }
  }
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      this.isFocused = value;
    }
  }
  set dragging(data) {
    if (this.isDragged !== data.value && this.sliderSelection && this.draghandleStart && this.draghandleEnd) {
      const sliderSelection = this.sliderSelection.nativeElement;
      const draghandle = data.target;
      if (data.value) {
        this.renderer.addClass(sliderSelection, PRESSED);
        this.renderer.addClass(draghandle, PRESSED);
      } else {
        this.renderer.removeClass(sliderSelection, PRESSED);
        this.renderer.removeClass(draghandle, PRESSED);
      }
      this.isDragged = data.value;
    }
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  getProps() {
    return {
      disabled: this.disabled,
      fixedTickWidth: this.fixedTickWidth,
      largeStep: this.largeStep,
      max: this.max,
      min: this.min,
      readonly: this.readonly,
      reverse: this.reverse,
      rtl: this.localizationService.rtl,
      smallStep: this.smallStep,
      value: trimValueRange(this.max, this.min, this.value),
      vertical: this.vertical,
      buttons: false
    };
  }
  isRangeSliderInvalid() {
    const rangeSliderClasses = this.hostElement.nativeElement.classList;
    this.isInvalid = rangeSliderClasses.contains("ng-invalid") ? true : false;
    this.renderer.setAttribute(this.draghandleStart.nativeElement, "aria-invalid", `${this.isInvalid}`);
    this.renderer.setAttribute(this.draghandleEnd.nativeElement, "aria-invalid", `${this.isInvalid}`);
  }
  attachElementEventHandlers() {
    const hostElement = this.hostElement.nativeElement;
    let tabbing = false;
    let cursorInsideWrapper = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        if (!this.isFocused) {
          this.ngZone.run(() => {
            if (!this.focusChangedProgrammatically) {
              this.onFocus.emit();
            }
            this.focused = true;
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          if (args.relatedTarget !== this.draghandleStart.nativeElement && args.relatedTarget !== this.draghandleEnd.nativeElement) {
            this.handleBlur();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper) {
            this.handleBlur();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        if (!this.focusChangedProgrammatically) {
          this.onBlur.emit();
        }
      });
    }
  };
  static ɵfac = function RangeSliderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RangeSliderComponent,
    selectors: [["kendo-rangeslider"]],
    viewQuery: function RangeSliderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c10, 7);
        ɵɵviewQuery(_c11, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandleStart = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.draghandleEnd = _t.first);
      }
    },
    inputs: {
      value: "value"
    },
    exportAs: ["kendoRangeSlider"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.rangeslider"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RangeSliderComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RangeSliderComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 13,
    vars: 33,
    consts: () => {
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_3 = goog.getMsg("Drag");
        i18n_3 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider.:Drag`;
      }
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_4 = goog.getMsg("Drag");
        i18n_4 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider.:Drag`;
      }
      return [["wrap", ""], ["track", ""], ["sliderSelection", ""], ["draghandleStart", ""], ["draghandleEnd", ""], ["ticks", ""], ["kendoSliderLocalizedMessages", "", "dragHandleStart", i18n_3, "dragHandleEnd", i18n_4], [1, "k-slider-track-wrap", 3, "kendoEventsOutsideAngular"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate", 4, "ngIf"], [1, "k-slider-track"], [1, "k-slider-selection"], ["role", "slider", "kendoDraggable", "", 1, "k-draghandle", 3, "kendoPress", "kendoDrag", "kendoRelease", "id", "title"], [3, "resize"], ["kendoSliderTicks", "", 3, "tickTitle", "vertical", "step", "largeStep", "min", "max", "labelTemplate"]];
    },
    template: function RangeSliderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 6);
        ɵɵelementStart(1, "div", 7, 0);
        ɵɵtemplate(3, RangeSliderComponent_ul_3_Template, 2, 8, "ul", 8);
        ɵɵelementStart(4, "div", 9, 1);
        ɵɵelement(6, "div", 10, 2);
        ɵɵelementStart(8, "span", 11, 3);
        ɵɵlistener("kendoPress", function RangeSliderComponent_Template_span_kendoPress_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function RangeSliderComponent_Template_span_kendoDrag_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function RangeSliderComponent_Template_span_kendoRelease_8_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(10, "span", 11, 4);
        ɵɵlistener("kendoPress", function RangeSliderComponent_Template_span_kendoPress_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.handleDragPress, $event));
        })("kendoDrag", function RangeSliderComponent_Template_span_kendoDrag_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleDrag, $event));
        })("kendoRelease", function RangeSliderComponent_Template_span_kendoRelease_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.ifEnabled(ctx.onHandleRelease, $event));
        });
        ɵɵelementEnd()()();
        ɵɵelementStart(12, "kendo-resize-sensor", 12);
        ɵɵlistener("resize", function RangeSliderComponent_Template_kendo_resize_sensor_resize_12_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.sizeComponent());
        });
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassProp("k-slider-topleft", ctx.tickPlacement === "before")("k-slider-bottomright", ctx.tickPlacement === "after");
        ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction2(30, _c9, ctx.onWrapClick, ctx.onKeyDown));
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.tickPlacement !== "none");
        ɵɵadvance(5);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("id", ctx.startHandleId)("title", ctx.textFor("dragHandleStart"));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[0] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵɵadvance(2);
        ɵɵstyleProp("touch-action", ctx.isDisabled ? "" : "none");
        ɵɵproperty("id", ctx.endHandleId)("title", ctx.textFor("dragHandleEnd"));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value ? ctx.value[1] : null)("aria-valuetext", ctx.valueText)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
      }
    },
    dependencies: [LocalizedRangeSliderMessagesDirective, EventsOutsideAngularDirective, NgIf, SliderTicksComponent, DraggableDirective, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRangeSlider",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.rangeslider"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RangeSliderComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RangeSliderComponent)
      }],
      selector: "kendo-rangeslider",
      template: `
        <ng-container kendoSliderLocalizedMessages
            i18n-dragHandleStart="kendo.rangeslider.dragHandleStart|The title of the **Start** drag handle of the Slider."
            dragHandleStart="Drag"
            i18n-dragHandleEnd="kendo.rangeslider.dragHandleEnd|The title of the **End** drag handle of the Slider."
            dragHandleEnd="Drag"
        >

        <div
            #wrap
            class="k-slider-track-wrap"
            [class.k-slider-topleft]="tickPlacement === 'before'"
            [class.k-slider-bottomright]="tickPlacement === 'after'"
            [kendoEventsOutsideAngular]="{ click: onWrapClick, keydown: onKeyDown }"
        >
            <ul kendoSliderTicks
                #ticks
                *ngIf="tickPlacement !== 'none'"
                [tickTitle]="title"
                [vertical]="vertical"
                [step]="smallStep"
                [largeStep]="largeStep"
                [min]="min"
                [max]="max"
                [labelTemplate]="labelTemplate?.templateRef"
                [attr.aria-hidden]="true"
            >
            </ul>
            <div #track class="k-slider-track">
                <div #sliderSelection class="k-slider-selection">
                </div>
                <span #draghandleStart
                    role="slider"
                    [id]="startHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[0] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleStart')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
                <span #draghandleEnd
                    role="slider"
                    [id]="endHandleId"
                    [attr.tabindex]="disabled ? undefined : tabindex"
                    [attr.aria-valuemin]="min"
                    [attr.aria-valuemax]="max"
                    [attr.aria-valuenow]="value ? value[1] : null"
                    [attr.aria-valuetext]="valueText"
                    [attr.aria-disabled]="disabled ? true : undefined"
                    [attr.aria-readonly]="readonly ? true : undefined"
                    [attr.aria-orientation]="vertical ? 'vertical' : 'horizontal'"
                    [style.touch-action]="isDisabled ? '' : 'none'"
                    class="k-draghandle"
                    [title]="textFor('dragHandleEnd')"
                    kendoDraggable
                    (kendoPress)="ifEnabled(handleDragPress ,$event)"
                    (kendoDrag)="ifEnabled(onHandleDrag ,$event)"
                    (kendoRelease)="ifEnabled(onHandleRelease, $event)"
                ></span>
            </div>
        </div>
        <kendo-resize-sensor (resize)="sizeComponent()"></kendo-resize-sensor>
  `,
      standalone: true,
      imports: [LocalizedRangeSliderMessagesDirective, EventsOutsideAngularDirective, NgIf, SliderTicksComponent, DraggableDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    value: [{
      type: Input
    }],
    draghandleStart: [{
      type: ViewChild,
      args: ["draghandleStart", {
        static: true
      }]
    }],
    draghandleEnd: [{
      type: ViewChild,
      args: ["draghandleEnd", {
        static: true
      }]
    }]
  });
})();
var Messages = class _Messages extends ComponentMessages {
  /**
   * The title of the **On** button of the Switch.
   */
  on;
  /**
   * The title of the **Off** button of the Switch.
   */
  off;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    selectors: [["kendo-switch-messages-base"]],
    inputs: {
      on: "on",
      off: "off"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-switch-messages-base"
    }]
  }], null, {
    on: [{
      type: Input
    }],
    off: [{
      type: Input
    }]
  });
})();
var LocalizedSwitchMessagesDirective = class _LocalizedSwitchMessagesDirective extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSwitchMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSwitchMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSwitchMessagesDirective,
    selectors: [["", "kendoSwitchLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _LocalizedSwitchMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSwitchMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => LocalizedSwitchMessagesDirective)
      }],
      selector: "[kendoSwitchLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var FOCUSED$5 = "k-focus";
var DEFAULT_SIZE$e = "medium";
var DEFAULT_THUMB_ROUNDED = "full";
var DEFAULT_TRACK_ROUNDED = "full";
var SwitchComponent = class _SwitchComponent {
  renderer;
  hostElement;
  localizationService;
  injector;
  changeDetector;
  ngZone;
  /**
   * @hidden
   */
  get focusableId() {
    if (this.hostElement.nativeElement.hasAttribute("id")) {
      return this.hostElement.nativeElement.getAttribute("id");
    }
    return `k-${guid()}`;
  }
  /**
   * Set the **On** label.
   * This label takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).
   * [See example]({% slug labels_switch %}).
   */
  onLabel;
  /**
   * Set the **Off** label.
   * This label takes precedence over the [custom messages component]({% slug api_inputs_switchcustommessagescomponent %}).
   * [See example]({% slug labels_switch %}).
   */
  offLabel;
  /**
   * Sets the value of the Switch when it first appears.
   */
  set checked(value) {
    this.setHostClasses(value);
    this._checked = value;
  }
  get checked() {
    return this._checked;
  }
  /**
   * When `true`, disables the Switch.
   * [See example]({% slug disabled_switch %}).
   * To disable the component in reactive forms, see [Forms Support](slug:formssupport_switch#toc-managing-the-switch-disabled-state-in-reactive-forms).
   * @default false
   */
  disabled = false;
  /**
   * When `true`, sets the Switch to read-only.
   * [See example]({% slug readonly_switch %}).
   * @default false
   */
  readonly = false;
  /**
   * Set the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Switch.
   * @default 0
   */
  tabindex = 0;
  /**
   * Sets the size of the Switch.
   *
   * @default "medium"
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$e;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the Switch.
   *
   * @default "full"
   */
  set thumbRounded(thumbRounded) {
    const newThumbRounded = thumbRounded || DEFAULT_THUMB_ROUNDED;
    this.handleThumbClasses(newThumbRounded);
    this._thumbRounded = newThumbRounded;
  }
  get thumbRounded() {
    return this._thumbRounded;
  }
  /**
   * Sets the border radius of the Switch track.
   *
   * @default "full"
   */
  set trackRounded(trackRounded) {
    const newTrackRounded = trackRounded || DEFAULT_TRACK_ROUNDED;
    this.handleTrackClasses(newTrackRounded);
    this._trackRounded = newTrackRounded;
  }
  get trackRounded() {
    return this._trackRounded;
  }
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Fires when the user focuses the Switch.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the user blurs the Switch.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the value of the Switch changes.
   */
  valueChange = new EventEmitter();
  direction;
  hostRole = "switch";
  get hostId() {
    return this.focusableId;
  }
  get ariaChecked() {
    return this.checked;
  }
  get ariaInvalid() {
    return this.isControlInvalid ? true : void 0;
  }
  get hostTabIndex() {
    return this.disabled ? void 0 : this.tabIndex;
  }
  get ariaDisabled() {
    return this.disabled ? true : void 0;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  hostClasses = true;
  get disabledClass() {
    return this.disabled;
  }
  track;
  thumb;
  /**
   * @hidden
   */
  initialized = false;
  localizationChangeSubscription;
  isFocused;
  control;
  domSubscriptions = [];
  _checked = false;
  _size = "medium";
  _trackRounded = "full";
  _thumbRounded = "full";
  constructor(renderer, hostElement, localizationService, injector, changeDetector, ngZone) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.localizationService = localizationService;
    this.injector = injector;
    this.changeDetector = changeDetector;
    this.ngZone = ngZone;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
    this.keyDownHandler = this.keyDownHandler.bind(this);
    this.clickHandler = this.clickHandler.bind(this);
  }
  /**
   * @hidden
   */
  get onLabelMessage() {
    return this.onLabel !== void 0 ? this.onLabel : this.localizationService.get("on");
  }
  /**
   * @hidden
   */
  get offLabelMessage() {
    return this.offLabel !== void 0 ? this.offLabel : this.localizationService.get("off");
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  get isEnabled() {
    return !this.disabled && !this.readonly;
  }
  ngOnInit() {
    if (this.hostElement) {
      const wrapper = this.hostElement.nativeElement;
      this.renderer.removeAttribute(wrapper, "tabindex");
    }
    this.localizationChangeSubscription = this.localizationService.changes.pipe(skip(1)).subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.control = this.injector.get(NgControl, null);
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.initialized = true);
  }
  ngAfterViewInit() {
    const wrapper = this.hostElement.nativeElement;
    if (!this.checked && !wrapper.classList.contains("k-switch-off")) {
      this.renderer.addClass(wrapper, "k-switch-off");
    }
    this.handleClasses(this.size, "size");
    this.handleTrackClasses(this.trackRounded);
    this.handleThumbClasses(this.thumbRounded);
    this.attachHostHandlers();
  }
  ngOnDestroy() {
    if (this.localizationChangeSubscription) {
      this.localizationChangeSubscription.unsubscribe();
    }
    this.domSubscriptions.forEach((subscription) => subscription());
    const wrapper = this.hostElement.nativeElement;
    wrapper.removeEventListener("focus", this.handleFocus, true);
    wrapper.removeEventListener("blur", this.handleBlur, true);
  }
  /**
   * Focuses the Switch.
   *
   */
  focus() {
    if (!this.hostElement) {
      return;
    }
    this.hostElement.nativeElement.focus();
  }
  /**
   * Blurs the Switch.
   */
  blur() {
    if (!this.hostElement) {
      return;
    }
    this.hostElement.nativeElement.blur();
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  handleFocus = (event) => {
    if (this.isFocused) {
      return;
    }
    event.stopImmediatePropagation();
    this.focused = true;
    if (hasObservers(this.onFocus)) {
      this.ngZone.run(() => {
        const eventArgs = {
          originalEvent: event
        };
        this.onFocus.emit(eventArgs);
      });
    }
  };
  /**
   * @hidden
   */
  handleBlur = (event) => {
    const relatedTarget = event && event.relatedTarget;
    if (this.hostElement.nativeElement.contains(relatedTarget)) {
      return;
    }
    event.stopImmediatePropagation();
    this.changeDetector.markForCheck();
    this.focused = false;
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        const eventArgs = {
          originalEvent: event
        };
        this.onBlur.emit(eventArgs);
      });
    }
  };
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.checked = value === null ? false : value;
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  keyDownHandler(e) {
    const keyCode = e.keyCode;
    if (this.isEnabled && (keyCode === Keys.Space || keyCode === Keys.Enter)) {
      this.changeValue(!this.checked);
      e.preventDefault();
    }
  }
  /**
   * @hidden
   */
  clickHandler() {
    if (this.isEnabled) {
      this.changeValue(!this.checked);
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  changeValue(value) {
    if (this.checked !== value) {
      this.ngZone.run(() => {
        this.checked = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const wrapper = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(wrapper, FOCUSED$5);
      } else {
        this.renderer.removeClass(wrapper, FOCUSED$5);
      }
      this.isFocused = value;
    }
  }
  attachHostHandlers() {
    this.ngZone.runOutsideAngular(() => {
      const wrapper = this.hostElement.nativeElement;
      this.domSubscriptions.push(this.renderer.listen(wrapper, "click", this.clickHandler), this.renderer.listen(wrapper, "keydown", this.keyDownHandler));
      wrapper.addEventListener("focus", this.handleFocus, true);
      wrapper.addEventListener("blur", this.handleBlur, true);
    });
  }
  setHostClasses(value) {
    const wrapper = this.hostElement.nativeElement;
    if (value) {
      this.renderer.removeClass(wrapper, "k-switch-off");
      this.renderer.addClass(wrapper, "k-switch-on");
    } else {
      this.renderer.removeClass(wrapper, "k-switch-on");
      this.renderer.addClass(wrapper, "k-switch-off");
    }
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("switch", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  handleTrackClasses(value) {
    const track = this.track?.nativeElement;
    if (!track) {
      return;
    }
    const classes = getStylingClasses("switch", "rounded", this.trackRounded, value);
    if (classes.toRemove) {
      this.renderer.removeClass(track, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(track, classes.toAdd);
    }
  }
  handleThumbClasses(value) {
    const thumb = this.thumb?.nativeElement;
    if (!thumb) {
      return;
    }
    const classes = getStylingClasses("switch", "rounded", this.thumbRounded, value);
    if (classes.toRemove) {
      this.renderer.removeClass(thumb, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(thumb, classes.toAdd);
    }
  }
  static ɵfac = function SwitchComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SwitchComponent,
    selectors: [["kendo-switch"]],
    viewQuery: function SwitchComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c1, 7);
        ɵɵviewQuery(_c12, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.track = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.thumb = _t.first);
      }
    },
    hostVars: 14,
    hostBindings: function SwitchComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.hostRole)("id", ctx.hostId)("aria-checked", ctx.ariaChecked)("aria-invalid", ctx.ariaInvalid)("tabindex", ctx.hostTabIndex)("aria-disabled", ctx.ariaDisabled)("aria-readonly", ctx.ariaReadonly);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-switch", ctx.hostClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      onLabel: "onLabel",
      offLabel: "offLabel",
      checked: "checked",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      size: "size",
      thumbRounded: "thumbRounded",
      trackRounded: "trackRounded",
      tabIndex: "tabIndex"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoSwitch"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.switch"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SwitchComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _SwitchComponent)
    }]), ɵɵStandaloneFeature],
    decls: 10,
    vars: 8,
    consts: () => {
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_5 = goog.getMsg("ON");
        i18n_5 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.switch.on|The **On** label of the Switch.:ON`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_6 = goog.getMsg("OFF");
        i18n_6 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.switch.off|The **Off** label of the Switch.:OFF`;
      }
      return [["track", ""], ["thumb", ""], ["kendoSwitchLocalizedMessages", "", "on", i18n_5, "off", i18n_6], [1, "k-switch-track"], [1, "k-switch-label-on"], [1, "k-switch-label-off"], [1, "k-switch-thumb-wrap"], [1, "k-switch-thumb"]];
    },
    template: function SwitchComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainerStart(0, 2);
        ɵɵelementStart(1, "span", 3, 0)(3, "span", 4);
        ɵɵtext(4);
        ɵɵelementEnd();
        ɵɵelementStart(5, "span", 5);
        ɵɵtext(6);
        ɵɵelementEnd()();
        ɵɵelementStart(7, "span", 6);
        ɵɵelement(8, "span", 7, 1);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
        ɵɵadvance(2);
        ɵɵattribute("aria-hidden", true);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.onLabelMessage);
        ɵɵadvance();
        ɵɵattribute("aria-hidden", true);
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.offLabelMessage);
        ɵɵadvance();
        ɵɵstyleProp("transition-duration", ctx.initialized ? "200ms" : "0ms");
      }
    },
    dependencies: [LocalizedSwitchMessagesDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSwitch",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.switch"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SwitchComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => SwitchComponent)
      }],
      selector: "kendo-switch",
      template: `
        <ng-container kendoSwitchLocalizedMessages
            i18n-on="kendo.switch.on|The **On** label of the Switch."
            on="ON"
            i18n-off="kendo.switch.off|The **Off** label of the Switch."
            off="OFF"
        >

        <span
            #track
            class="k-switch-track"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'"
        >
            <span class="k-switch-label-on" [attr.aria-hidden]="true" >{{onLabelMessage}}</span>
            <span class="k-switch-label-off" [attr.aria-hidden]="true">{{offLabelMessage}}</span>
        </span>
        <span
            class="k-switch-thumb-wrap"
            [style.transitionDuration]="initialized ? '200ms' : '0ms'">
            <span #thumb class="k-switch-thumb"></span>
        </span>
  `,
      standalone: true,
      imports: [LocalizedSwitchMessagesDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    onLabel: [{
      type: Input
    }],
    offLabel: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    thumbRounded: [{
      type: Input
    }],
    trackRounded: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hostId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    ariaChecked: [{
      type: HostBinding,
      args: ["attr.aria-checked"]
    }],
    ariaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-switch"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    track: [{
      type: ViewChild,
      args: ["track", {
        static: true
      }]
    }],
    thumb: [{
      type: ViewChild,
      args: ["thumb", {
        static: true
      }]
    }]
  });
})();
var TextBoxDirective = class _TextBoxDirective {
  renderer;
  inputElement;
  ngZone;
  hostClasses = true;
  /**
   * @hidden
   */
  onFocus = new EventEmitter();
  /**
   * @hidden
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  onValueChange = new EventEmitter();
  /**
   * @hidden
   */
  autoFillStart = new EventEmitter();
  /**
   * @hidden
   */
  autoFillEnd = new EventEmitter();
  /**
   * @hidden
   */
  set value(text) {
    if (!this.inputElement) {
      return;
    }
    this.inputElement.nativeElement.value = text === void 0 || text === null ? "" : text;
    this.onValueChange.emit();
  }
  /**
   * @hidden
   */
  get value() {
    return this.inputElement.nativeElement.value;
  }
  get id() {
    return this.inputElement.nativeElement.id;
  }
  set id(id2) {
    this.renderer.setAttribute(this.inputElement.nativeElement, "id", id2);
  }
  listeners = [];
  constructor(renderer, inputElement, ngZone) {
    this.renderer = renderer;
    this.inputElement = inputElement;
    this.ngZone = ngZone;
  }
  ngAfterViewInit() {
    const input = this.inputElement.nativeElement;
    this.listeners = [this.renderer.listen(input, "focus", () => this.onFocus.emit()), this.renderer.listen(input, "blur", () => this.onBlur.emit())];
    this.ngZone.runOutsideAngular(() => {
      this.renderer.listen(input, "animationstart", (e) => {
        if (e.animationName === "autoFillStart") {
          this.autoFillStart.emit();
        } else if (e.animationName === "autoFillEnd") {
          this.autoFillEnd.emit();
        }
      });
    });
  }
  ngOnDestroy() {
    this.listeners.forEach((listener) => listener());
  }
  static ɵfac = function TextBoxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxDirective,
    selectors: [["input", "kendoTextBox", ""]],
    hostVars: 10,
    hostBindings: function TextBoxDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses)("k-input-md", ctx.hostClasses)("k-rounded-md", ctx.hostClasses)("k-input-solid", ctx.hostClasses);
      }
    },
    inputs: {
      value: "value"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: KendoInput,
      useExisting: forwardRef(() => _TextBoxDirective)
    }])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoTextBox]",
      providers: [{
        provide: KendoInput,
        useExisting: forwardRef(() => TextBoxDirective)
      }],
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textbox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-input-md"]
    }, {
      type: HostBinding,
      args: ["class.k-rounded-md"]
    }, {
      type: HostBinding,
      args: ["class.k-input-solid"]
    }],
    value: [{
      type: Input
    }]
  });
})();
var TextAreaDirective = class _TextAreaDirective {
  renderer;
  element;
  zone;
  changeDetector;
  injector;
  elementClasses = true;
  autofillClass = true;
  direction;
  /**
   * Fires when the TextArea value changes.
   */
  valueChange = new EventEmitter();
  /**
   * Sets whether the `textarea` element resizes its height automatically
   * ([see example](slug:textarea_sizing#toc-auto-resizing)).
   *
   * @default false
   */
  autoSize = false;
  /**
   * Sets the textarea value.
   */
  value;
  /**
   * @hidden
   */
  onFocus = new EventEmitter();
  /**
   * @hidden
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  onValueChange = new EventEmitter();
  /**
   * @hidden
   */
  autoFillStart = new EventEmitter();
  /**
   * @hidden
   */
  autoFillEnd = new EventEmitter();
  get id() {
    return this.element.nativeElement.id;
  }
  set id(id2) {
    this.renderer.setAttribute(this.element.nativeElement, "id", id2);
  }
  listeners = [];
  inputSubscription;
  initialHeight;
  control;
  resizeSubscription;
  constructor(renderer, element, zone, changeDetector, injector, rtl) {
    this.renderer = renderer;
    this.element = element;
    this.zone = zone;
    this.changeDetector = changeDetector;
    this.injector = injector;
    this.direction = rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.elementValue = value;
    this.resize();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.setElementProperty("disabled", isDisabled2);
  }
  ngOnInit() {
    const element = this.element.nativeElement;
    this.zone.runOutsideAngular(() => {
      this.listeners = [this.renderer.listen(element, "focus", this.handleFocus.bind(this)), this.renderer.listen(element, "blur", this.handleBlur.bind(this)), this.renderer.listen(element, "animationstart", (e) => {
        if (e.animationName === "autoFillStart") {
          this.autoFillStart.emit();
        } else if (e.animationName === "autoFillEnd") {
          this.autoFillEnd.emit();
        }
      })];
      if (isDocumentAvailable() && this.autoSize) {
        this.resizeSubscription = fromEvent(window, "resize").pipe(debounceTime(50)).subscribe(() => this.resize());
      }
      this.inputSubscription = fromEvent(element, "input").subscribe(this.handleInput.bind(this));
    });
    this.control = this.injector.get(NgControl, null);
  }
  ngOnChanges(changes) {
    const element = this.element.nativeElement;
    if (changes.value) {
      this.elementValue = this.value;
    }
    if (changes.autoSize) {
      if (this.autoSize) {
        this.initialHeight = element.offsetHeight;
        this.renderer.setStyle(element, "resize", "none");
      } else {
        this.renderer.setStyle(element, "overflow-y", "auto");
        this.renderer.setStyle(element, "resize", "both");
        element.style.height = `${this.initialHeight}px`;
      }
    }
    this.zone.onStable.pipe(take(1)).subscribe(() => this.resize());
  }
  ngOnDestroy() {
    this.listeners.forEach((listener) => listener());
    if (this.inputSubscription) {
      this.inputSubscription.unsubscribe();
    }
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  get elementValue() {
    if (this.element) {
      return this.element.nativeElement.value;
    }
    return "";
  }
  set elementValue(value) {
    this.setElementProperty("value", value === void 0 || value === null ? "" : value);
  }
  setElementProperty(name, value) {
    if (this.element) {
      this.renderer.setProperty(this.element.nativeElement, name, value);
    }
  }
  resize() {
    if (!this.autoSize) {
      return;
    }
    const element = this.element.nativeElement;
    this.renderer.setStyle(element, "overflow-y", "hidden");
    element.style.height = `${this.initialHeight}px`;
    const scrollHeight = element.scrollHeight;
    if (scrollHeight > this.initialHeight) {
      element.style.height = `${scrollHeight}px`;
    }
  }
  handleInput() {
    const value = this.elementValue;
    this.value = value;
    if (this.control || hasObservers(this.onValueChange) || hasObservers(this.valueChange)) {
      this.zone.run(() => {
        this.ngChange(value);
        this.onValueChange.emit(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
    this.resize();
  }
  handleFocus() {
    if (hasObservers(this.onFocus)) {
      this.zone.run(() => {
        this.onFocus.emit();
      });
    }
  }
  handleBlur() {
    if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.control)) {
      this.zone.run(() => {
        this.ngTouched();
        this.onBlur.emit();
        this.changeDetector.markForCheck();
      });
    }
  }
  static ɵfac = function TextAreaDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(RTL, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextAreaDirective,
    selectors: [["textarea", "kendoTextArea", ""]],
    hostVars: 13,
    hostBindings: function TextAreaDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-textarea", ctx.elementClasses)("k-input", ctx.elementClasses)("k-input-md", ctx.elementClasses)("k-rounded-md", ctx.elementClasses)("k-input-solid", ctx.elementClasses)("k-autofill", ctx.autofillClass);
      }
    },
    inputs: {
      autoSize: "autoSize",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextAreaDirective),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextAreaDirective)
    }]), ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextAreaDirective),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextAreaDirective)
      }],
      selector: "textarea[kendoTextArea]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, {
    elementClasses: [{
      type: HostBinding,
      args: ["class.k-textarea"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-input-md"]
    }, {
      type: HostBinding,
      args: ["class.k-rounded-md"]
    }, {
      type: HostBinding,
      args: ["class.k-input-solid"]
    }],
    autofillClass: [{
      type: HostBinding,
      args: ["class.k-autofill"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    valueChange: [{
      type: Output
    }],
    autoSize: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var createMaxValidator = (maxValue) => {
  return (c) => {
    if (!isPresent3(maxValue) || !isPresent3(c.value) || c.value <= maxValue) {
      return null;
    }
    return {
      maxError: {
        maxValue,
        value: c.value
      }
    };
  };
};
var createMinValidator = (minValue) => {
  return (c) => {
    if (!isPresent3(minValue) || !isPresent3(c.value) || c.value >= minValue) {
      return null;
    }
    return {
      minError: {
        minValue,
        value: c.value
      }
    };
  };
};
var MIN_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-min";
var MAX_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/inputs/api/NumericTextBoxComponent/#toc-max";
var POINT = ".";
var INITIAL_SPIN_DELAY = 500;
var SPIN_DELAY = 50;
var EXPONENT_REGEX = /[eE][\-+]?([0-9]+)/;
var numericRegex = (options) => {
  const {
    autoCorrect,
    decimals,
    min
  } = options;
  let separator = options.separator;
  if (separator === POINT) {
    separator = "\\" + separator;
  }
  const signPattern = autoCorrect && min !== null && min >= 0 ? "" : "-?";
  let numberPattern;
  if (decimals === 0) {
    numberPattern = "\\d*";
  } else {
    numberPattern = `(?:(?:\\d+(${separator}\\d*)?)|(?:${separator}\\d*))?`;
  }
  return new RegExp(`^${signPattern}${numberPattern}$`);
};
var decimalPart = (value) => {
  return value >= 0 ? Math.floor(value) : Math.ceil(value);
};
var noop$1 = (_) => {
};
var defined = (value) => {
  return typeof value !== "undefined";
};
var isNumber = (value) => {
  return !isNaN(value) && value !== null;
};
function pad(value, digits) {
  const count = digits - String(value).length;
  let result = value;
  if (count > 0) {
    const padString = new Array(count + 1).join("0");
    result = parseFloat(value + padString);
  }
  return result;
}
var getDeltaFromMouseWheel = (e) => {
  let delta = 0;
  if (e.wheelDelta) {
    delta = e.wheelDelta / 120;
    delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  } else if (e.detail) {
    delta = Math.round(-e.detail / 3);
  }
  return delta;
};
var getCaretPosition = (element) => element.selectionStart;
var extractSignificantNumericChars = (formattedString, separator) => {
  const significantCharacters = `${separator}0123456789-`;
  return formattedString.split("").reduce((acc, curr) => significantCharacters.includes(curr) ? ++acc : acc, 0);
};
var isRightClick = (event) => {
  const isRightClickIE = event.button && event.button === 2;
  const isRightClickOther = event.which && event.which === 3;
  return isRightClickIE || isRightClickOther;
};
var ArrowDirection;
(function(ArrowDirection2) {
  ArrowDirection2[ArrowDirection2["Down"] = -1] = "Down";
  ArrowDirection2[ArrowDirection2["None"] = 0] = "None";
  ArrowDirection2[ArrowDirection2["Up"] = 1] = "Up";
})(ArrowDirection || (ArrowDirection = {}));
var InputSeparatorComponent = class _InputSeparatorComponent {
  /**
   * Sets the orientation of the separator. Use this for the adornments of the [`TextAreaComponent`](slug:api_inputs_textareacomponent).
   *
   * @default 'vertical'
   */
  orientation = "vertical";
  get vertical() {
    return this.orientation === "vertical";
  }
  get horizontal() {
    return this.orientation === "horizontal";
  }
  hostClass = true;
  static ɵfac = function InputSeparatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputSeparatorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _InputSeparatorComponent,
    selectors: [["kendo-input-separator"], ["kendo-textbox-separator"]],
    hostVars: 6,
    hostBindings: function InputSeparatorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-separator-vertical", ctx.vertical)("k-input-separator-horizontal", ctx.horizontal)("k-input-separator", ctx.hostClass);
      }
    },
    inputs: {
      orientation: "orientation"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function InputSeparatorComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputSeparatorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-input-separator, kendo-textbox-separator",
      template: ``,
      standalone: true
    }]
  }], null, {
    orientation: [{
      type: Input
    }],
    vertical: [{
      type: HostBinding,
      args: ["class.k-input-separator-vertical"]
    }],
    horizontal: [{
      type: HostBinding,
      args: ["class.k-input-separator-horizontal"]
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-separator"]
    }]
  });
})();
var SharedInputEventsDirective = class _SharedInputEventsDirective {
  ngZone;
  renderer;
  cdr;
  hostElement;
  clearButtonClicked;
  isFocused;
  isFocusedChange = new EventEmitter();
  onFocus = new EventEmitter();
  handleBlur = new EventEmitter();
  subscriptions = new Subscription();
  constructor(ngZone, renderer, cdr) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
  }
  ngAfterViewInit() {
    const hostElement = this.hostElement.nativeElement;
    let cursorInsideWrapper = false;
    let tabbing = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.cdr.detectChanges();
        if (!this.isFocused) {
          this.ngZone.run(() => {
            this.onFocus.emit();
            this.isFocused = true;
            this.isFocusedChange.emit(this.isFocused);
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          const closestTextbox = closest2(args.relatedTarget, (element) => element === hostElement);
          if (!closestTextbox) {
            this.handleBlur.emit();
          }
          tabbing = false;
        } else {
          if (!cursorInsideWrapper && !this?.clearButtonClicked) {
            this.handleBlur.emit();
          }
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static ɵfac = function SharedInputEventsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedInputEventsDirective)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SharedInputEventsDirective,
    selectors: [["", "kendoInputSharedEvents", ""]],
    inputs: {
      hostElement: "hostElement",
      clearButtonClicked: "clearButtonClicked",
      isFocused: "isFocused"
    },
    outputs: {
      isFocusedChange: "isFocusedChange",
      onFocus: "onFocus",
      handleBlur: "handleBlur"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedInputEventsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoInputSharedEvents]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hostElement: [{
      type: Input
    }],
    clearButtonClicked: [{
      type: Input
    }],
    isFocused: [{
      type: Input
    }],
    isFocusedChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    handleBlur: [{
      type: Output
    }]
  });
})();
var NumericTextBoxMessages = class _NumericTextBoxMessages extends ComponentMessages {
  /**
   * Sets the title of the **Decrement** button in the NumericTextBox.
   */
  decrement;
  /**
   * Sets the title of the **Increment** button in the NumericTextBox.
   */
  increment;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵNumericTextBoxMessages_BaseFactory;
    return function NumericTextBoxMessages_Factory(__ngFactoryType__) {
      return (ɵNumericTextBoxMessages_BaseFactory || (ɵNumericTextBoxMessages_BaseFactory = ɵɵgetInheritedFactory(_NumericTextBoxMessages)))(__ngFactoryType__ || _NumericTextBoxMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _NumericTextBoxMessages,
    selectors: [["kendo-numerictextbox-messages-base"]],
    inputs: {
      decrement: "decrement",
      increment: "increment"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-numerictextbox-messages-base"
    }]
  }], null, {
    decrement: [{
      type: Input
    }],
    increment: [{
      type: Input
    }]
  });
})();
var LocalizedNumericTextBoxMessagesDirective = class _LocalizedNumericTextBoxMessagesDirective extends NumericTextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedNumericTextBoxMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedNumericTextBoxMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedNumericTextBoxMessagesDirective,
    selectors: [["", "kendoNumericTextBoxLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NumericTextBoxMessages,
      useExisting: forwardRef(() => _LocalizedNumericTextBoxMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedNumericTextBoxMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: NumericTextBoxMessages,
        useExisting: forwardRef(() => LocalizedNumericTextBoxMessagesDirective)
      }],
      selector: "[kendoNumericTextBoxLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var PARSABLE_OPTIONS = ["min", "max", "step", "decimals"];
var PARSABLE_DEFAULTS = {
  decimals: null,
  max: null,
  min: null,
  step: 1
};
var FOCUSED$4 = "k-focus";
var DEFAULT_SIZE$d = "medium";
var DEFAULT_ROUNDED$8 = "medium";
var DEFAULT_FILL_MODE$6 = "solid";
var NumericTextBoxComponent = class _NumericTextBoxComponent {
  intl;
  renderer;
  localizationService;
  injector;
  ngZone;
  changeDetector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * When `true`, disables the `NumericTextBox`.
   * To disable the component in reactive forms, see [Forms Support](slug:formssupport_numerictextbox#toc-managing-the-numerictextbox-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * When `true`, makes the NumericTextBox read-only.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the `title` attribute of the input element.
   */
  title = "";
  /**
   * When `true`, the value is automatically corrected based on the minimum and maximum values ([see example]({% slug precision_numerictextbox %})).
   */
  autoCorrect = false;
  /**
   * Specifies the number format used when the NumericTextBox is not focused ([see example]({% slug formats_numerictextbox %})).
   * If `format` is `null` or `undefined`, the default format is used.
   */
  get format() {
    const format = this._format;
    return format !== null && format !== void 0 ? format : "n2";
  }
  set format(value) {
    this._format = value;
  }
  /**
   * Sets the maximum valid value ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).
   */
  max;
  /**
   * Sets the minimum valid value ([see example]({% slug precision_numerictextbox %}#toc-value-ranges)).
   */
  min;
  /**
   * Specifies the number of decimals the user can enter when the input is focused ([see example]({% slug precision_numerictextbox %})).
   */
  decimals = null;
  /**
   * Sets the input placeholder.
   */
  placeholder;
  /**
   * Specifies the value used to increment or decrement the component value ([see example]({% slug predefinedsteps_numerictextbox %})).
   *
   * @default 1
   */
  step = 1;
  /**
   * When `true`, renders the **Up** and **Down** spin buttons ([see example]({% slug spinbuttons_numerictextbox %})).
   *
   * @default true
   */
  spinners = true;
  /**
   * Enforces the built-in minimum and maximum validators during form validation.
   *
   * @default true
   */
  rangeValidation = true;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * When `true`, enables changing the value with the mouse wheel.
   *
   * @default true
   */
  changeValueOnScroll = true;
  /**
   * When `true`, enables selecting the entire value on click.
   *
   * @default true
   */
  selectOnFocus = true;
  /**
   * Sets the value of the NumericTextBox ([see example]({% slug formats_numerictextbox %})).
   */
  value = null;
  /**
   * Sets the maximum number of characters the user can type or paste in the input.
   * The locale-specific decimal separator and negative sign (`-`) count toward the length.
   * The `maxlength` does not apply to the formatted value when the component is not focused.
   */
  maxlength;
  /**
   * Sets the padding of the internal input element ([see example]({% slug appearance_numerictextbox %}#toc-size)).
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$d;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the NumericTextBox ([see example](slug:appearance_numerictextbox#toc-roundness)).
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded || DEFAULT_ROUNDED$8;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the background and border styles of the NumericTextBox ([see example](slug:appearance_numerictextbox#toc-fill-mode)).
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode || DEFAULT_FILL_MODE$6;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets HTML attributes on the inner input element.
   * The component ignores attributes that are essential for its functionality.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.numericInput.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires when the user selects a new value ([see example](slug:events_numerictextbox)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the NumericTextBox element is focused ([see example](slug:events_numerictextbox)).
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the `NumericTextBox` component gets blurred ([see example](slug:events_numerictextbox)).
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the input element is focused.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires when the input element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * @hidden
   */
  numericInput;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  direction;
  /**
   * @hidden
   */
  ArrowDirection = ArrowDirection;
  /**
   * @hidden
   */
  arrowDirection = ArrowDirection.None;
  get disableClass() {
    return this.disabled;
  }
  hostClasses = true;
  /**
   * @hidden
   */
  arrowUpIcon = caretAltUpIcon;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  subscriptions;
  inputValue = "";
  spinTimeout;
  isFocused;
  minValidateFn = noop$1;
  maxValidateFn = noop$1;
  numericRegex;
  _format = "n2";
  previousSelection;
  pressedKey;
  control;
  isPasted = false;
  mouseDown = false;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  ngChange = noop$1;
  ngTouched = noop$1;
  ngValidatorChange = noop$1;
  domEvents = [];
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.tabIndex,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      "aria-valuemin": this.min,
      "aria-valuemax": this.max,
      "aria-valuenow": this.value,
      required: this.isControlRequired ? "" : null,
      "aria-invalid": this.isControlInvalid
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      autocorrect: "off",
      role: "spinbutton"
    };
  }
  constructor(intl, renderer, localizationService, injector, ngZone, changeDetector, hostElement) {
    this.intl = intl;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.injector = injector;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.subscriptions.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
    this.ngZone.runOutsideAngular(() => {
      this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, "mousewheel", this.handleWheel.bind(this)));
      this.domEvents.push(this.renderer.listen(this.hostElement.nativeElement, "DOMMouseScroll", this.handleWheel.bind(this)));
    });
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  /**
   * @hidden
   */
  increasePress = (e) => {
    this.arrowPress(ArrowDirection.Up, e);
  };
  /**
   * @hidden
   */
  decreasePress = (e) => {
    this.arrowPress(ArrowDirection.Down, e);
  };
  /**
   * @hidden
   */
  releaseArrow = () => {
    clearTimeout(this.spinTimeout);
    if (this.arrowDirection !== ArrowDirection.None) {
      this.arrowDirection = ArrowDirection.None;
      this.changeDetector.detectChanges();
    }
  };
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(PARSABLE_OPTIONS, changes, false)) {
      this.parseOptions(PARSABLE_OPTIONS.filter((option) => changes[option]));
    }
    this.verifySettings();
    if (anyChanged(["min", "max", "rangeValidation"], changes, false)) {
      this.minValidateFn = this.rangeValidation ? createMinValidator(this.min) : noop$1;
      this.maxValidateFn = this.rangeValidation ? createMaxValidator(this.max) : noop$1;
      this.ngValidatorChange();
    }
    if (anyChanged(["autoCorrect", "decimals", "min"], changes)) {
      delete this.numericRegex;
    }
    if (anyChanged(["value", "format"], changes, false)) {
      this.verifyValue(this.value);
      this.value = this.restrictModelValue(this.value);
      if (!this.focused || this.intl.parseNumber(this.elementValue) !== this.value) {
        this.setInputValue();
      }
    }
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
    clearTimeout(this.spinTimeout);
    this.domEvents.forEach((unbindHandler) => unbindHandler());
  }
  /**
   * @hidden
   */
  validate(control) {
    return this.minValidateFn(control) || this.maxValidateFn(control);
  }
  /**
   * @hidden
   */
  registerOnValidatorChange(fn) {
    this.ngValidatorChange = fn;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.verifyValue(value);
    const restrictedValue = this.restrictModelValue(value);
    this.value = restrictedValue;
    this.setInputValue();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * Focuses the NumericTextBox.
   */
  focus() {
    invokeElementMethod(this.numericInput, "focus");
  }
  /**
   * Blurs the NumericTextBox.
   */
  blur() {
    invokeElementMethod(this.numericInput, "blur");
  }
  /**
   * Notifies the NumericTextBoxComponent that the input value should be changed.
   * Can be used to update the input after setting the component properties directly.
   */
  notifyValueChange() {
    this.setInputValue();
  }
  /**
   * @hidden
   */
  handlePaste = () => {
    this.isPasted = true;
  };
  /**
   * @hidden
   */
  handleInput = () => {
    const input = this.numericInput.nativeElement;
    let {
      selectionStart,
      selectionEnd,
      value: inputValue
    } = input;
    if (this.pressedKey === Keys.NumpadDecimal) {
      inputValue = this.replaceNumpadDotValue();
    }
    if (this.isPasted) {
      inputValue = this.formatInputValue(this.intl.parseNumber(inputValue));
    }
    if (!this.isValid(inputValue)) {
      input.value = this.inputValue;
      this.setSelection(selectionStart - 1, selectionEnd - 1);
      return;
    }
    const parsedValue = this.intl.parseNumber(inputValue);
    let value = this.restrictDecimals(parsedValue);
    if (this.autoCorrect) {
      const limited = this.limitInputValue(value);
      value = limited.value;
      selectionStart = limited.selectionStart;
      selectionEnd = limited.selectionEnd;
    }
    if (parsedValue !== value || this.hasTrailingZeros(inputValue) || !this.focused) {
      this.setInputValue(value);
      this.setSelection(selectionStart, selectionEnd);
    } else {
      this.inputValue = inputValue;
    }
    if (this.isPasted) {
      input.value = this.inputValue;
    }
    this.updateValue(value);
    this.previousSelection = null;
    this.isPasted = false;
  };
  /**
   * @hidden
   */
  handleDragEnter = () => {
    if (!this.focused && !this.isDisabled) {
      this.setInputValue(this.value, true);
    }
  };
  /**
   * @hidden
   */
  handleMouseDown = () => {
    this.mouseDown = true;
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.focused) {
      this.focused = true;
      if (!this.isDisabled) {
        const shouldSelectAll = this.selectOnFocus || !this.mouseDown;
        this.ngZone.runOutsideAngular(() => {
          setTimeout(() => {
            if (shouldSelectAll) {
              this.selectAll();
            } else {
              this.selectCaret();
            }
          }, 0);
        });
      }
      if (hasObservers(this.onFocus)) {
        this.ngZone.run(() => {
          this.onFocus.emit();
        });
      }
    }
    this.mouseDown = false;
    if (hasObservers(this.inputFocus)) {
      this.ngZone.run(() => {
        this.inputFocus.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.focused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    if (this.inputValue !== this.elementValue) {
      this.handleInput();
    }
    this.setInputValue();
    if (hasObservers(this.onBlur)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.onBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (this.inputValue !== this.elementValue) {
      this.handleInput();
    }
    this.setInputValue();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleKeyDown = (e) => {
    if (this.isDisabled) {
      return;
    }
    let step;
    if (e.keyCode === Keys.ArrowDown) {
      step = -1;
    } else if (e.keyCode === Keys.ArrowUp) {
      step = 1;
    }
    if (step && this.step) {
      e.preventDefault();
      this.addStep(step);
    }
    const input = this.numericInput.nativeElement;
    this.previousSelection = {
      end: input.selectionEnd,
      start: input.selectionStart
    };
    this.pressedKey = e.keyCode;
  };
  /**
   * @hidden
   */
  handleWheel = (e) => {
    if (this.focused && !this.isDisabled && this.changeValueOnScroll) {
      e.preventDefault();
      const delta = getDeltaFromMouseWheel(e);
      this.addStep(delta);
    }
  };
  /**
   * @hidden
   */
  get incrementTitle() {
    return this.localizationService.get("increment");
  }
  /**
   * @hidden
   */
  get decrementTitle() {
    return this.localizationService.get("decrement");
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  /**
   * @hidden
   */
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const wrap = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(wrap, FOCUSED$4);
      } else {
        this.renderer.removeClass(wrap, FOCUSED$4);
      }
      this.isFocused = value;
    }
  }
  get decimalSeparator() {
    const numberSymbols = this.intl.numberSymbols();
    return numberSymbols.decimal;
  }
  get elementValue() {
    return this.numericInput.nativeElement.value;
  }
  set elementValue(value) {
    this.renderer.setProperty(this.numericInput.nativeElement, "value", value);
  }
  get hasDecimals() {
    return this.decimals !== null && this.decimals >= 0;
  }
  get isDisabled() {
    return this.disabled || this.readonly;
  }
  arrowPress(direction, e) {
    e.preventDefault();
    if (this.isDisabled || isRightClick(e)) {
      return;
    }
    if (!mobileOS) {
      this.focus();
      this.focused = true;
    }
    if (this.arrowDirection !== direction) {
      this.arrowDirection = direction;
      this.changeDetector.detectChanges();
    }
    if (this.step) {
      this.spin(direction, INITIAL_SPIN_DELAY);
    } else {
      this.setInputValue();
    }
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  replaceNumpadDotValue() {
    let value = this.inputValue || "";
    if (this.previousSelection) {
      const input = this.numericInput.nativeElement;
      const {
        selectionStart,
        selectionEnd
      } = input;
      const {
        start,
        end
      } = this.previousSelection;
      input.value = value = value.substring(0, start) + this.decimalSeparator + value.substring(end);
      this.setSelection(selectionStart, selectionEnd);
    }
    return value;
  }
  isValid(value) {
    if (!this.numericRegex) {
      this.numericRegex = numericRegex({
        autoCorrect: this.autoCorrect,
        decimals: this.decimals,
        min: this.min,
        separator: this.decimalSeparator
      });
    }
    return this.numericRegex.test(value);
  }
  spin(step, timeout) {
    clearTimeout(this.spinTimeout);
    this.spinTimeout = window.setTimeout(() => {
      this.spin(step, SPIN_DELAY);
    }, timeout);
    this.addStep(step);
  }
  addStep(step) {
    let value = add(this.value || 0, this.step * step);
    value = this.limitValue(value);
    value = this.restrictDecimals(value);
    this.setInputValue(value);
    this.updateValue(value);
  }
  setSelection(start, end) {
    if (this.focused) {
      invokeElementMethod(this.numericInput, "setSelectionRange", start, end);
    }
  }
  limitValue(value) {
    let result = value;
    if (!this.isInRange(value)) {
      if (isNumber(this.max) && value > this.max) {
        result = this.max;
      }
      if (isNumber(this.min) && value < this.min) {
        result = this.min;
      }
    }
    return result;
  }
  limitInputValue(value) {
    const {
      selectionStart,
      selectionEnd,
      value: enteredValue
    } = this.numericInput.nativeElement;
    let limitedValue = value;
    let selectToEnd = false;
    if (!this.isInRange(value)) {
      const lengthChange = enteredValue.length - String(this.inputValue).length;
      const {
        min,
        max
      } = this;
      const hasMax = isNumber(max);
      const hasMin = isNumber(min);
      let padLimit, replaceNext;
      let correctedValue = value;
      if (selectionStart === 0 && this.inputValue.substr(1) === enteredValue) {
        return {
          selectionEnd,
          selectionStart,
          value: null
        };
      }
      if (hasMax && value > max) {
        if (value > 0) {
          replaceNext = true;
        } else {
          padLimit = max;
        }
      } else if (hasMin && value < min) {
        if (value > 0) {
          padLimit = min;
        } else {
          replaceNext = true;
        }
      }
      if (padLimit) {
        const paddedValue = this.tryPadValue(value, padLimit);
        if (paddedValue && decimalPart(value) !== decimalPart(padLimit)) {
          correctedValue = paddedValue;
          selectToEnd = true;
        }
      } else if (replaceNext) {
        if (this.inputValue && selectionStart !== enteredValue.length) {
          correctedValue = parseFloat(enteredValue.substr(0, selectionStart) + enteredValue.substr(selectionStart + lengthChange));
        }
      }
      limitedValue = this.limitValue(correctedValue);
      selectToEnd = (selectToEnd || limitedValue !== correctedValue) && this.previousSelection && this.previousSelection.end - this.previousSelection.start + lengthChange > 0;
    }
    return {
      selectionEnd: selectToEnd ? String(limitedValue).length : selectionEnd,
      selectionStart,
      value: limitedValue
    };
  }
  tryPadValue(value, limit) {
    const limitLength = String(Math.floor(limit)).length;
    const zeroPadded = pad(value, limitLength);
    const zeroPaddedNext = pad(value, limitLength + 1);
    let result;
    if (this.isInRange(zeroPadded)) {
      result = zeroPadded;
    } else if (this.isInRange(zeroPaddedNext)) {
      result = zeroPaddedNext;
    }
    return result;
  }
  isInRange(value) {
    return !isNumber(value) || (!isNumber(this.min) || this.min <= value) && (!isNumber(this.max) || value <= this.max);
  }
  restrictModelValue(value) {
    let result = this.restrictDecimals(value, true);
    if (this.autoCorrect && this.limitValue(result) !== result) {
      result = null;
    }
    return result;
  }
  restrictDecimals(value, round) {
    let result = value;
    if (value && this.hasDecimals) {
      const decimals = this.decimals;
      const stringValue = String(value);
      if (round || EXPONENT_REGEX.test(stringValue)) {
        result = toFixedPrecision(value, decimals);
      } else {
        const parts = stringValue.split(POINT);
        let fraction = parts[1];
        if (fraction && fraction.length > decimals) {
          fraction = fraction.substr(0, decimals);
          result = parseFloat(`${parts[0]}${POINT}${fraction}`);
        }
      }
    }
    return result;
  }
  formatInputValue(value) {
    let stringValue = Object.is(value, -0) ? "-0" : String(value);
    const exponentMatch = EXPONENT_REGEX.exec(stringValue);
    if (exponentMatch) {
      stringValue = value.toFixed(limitPrecision(parseInt(exponentMatch[1], 10)));
    }
    return stringValue.replace(POINT, this.decimalSeparator);
  }
  formatValue(value, focused) {
    let formattedValue;
    if (value === null || !defined(value) || value === "") {
      formattedValue = "";
    } else if (focused && !this.readonly) {
      formattedValue = this.formatInputValue(value);
    } else {
      formattedValue = this.intl.formatNumber(value, this.format);
    }
    return formattedValue;
  }
  setInputValue(value = this.value, focused = this.focused) {
    const formattedValue = this.formatValue(value, focused);
    this.elementValue = formattedValue;
    this.inputValue = formattedValue;
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.min !== null && this.max !== null && this.min > this.max) {
      throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
    }
  }
  verifyValue(value) {
    if (isDevMode() && value && typeof value !== "number") {
      throw new Error(`The NumericTextBox component requires value of type Number and ${JSON.stringify(value)} was set.`);
    }
  }
  parseOptions(options) {
    for (let idx = 0; idx < options.length; idx++) {
      const name = options[idx];
      const value = this[name];
      if (typeof value === "string") {
        const parsed = parseFloat(value);
        const valid = !isNaN(parsed);
        if (isDevMode() && !valid && value !== "") {
          throw new Error(`The NumericTextBox component requires value of type Number or a String representing a number for the ${name} property and ${JSON.stringify(value)} was set.`);
        }
        this[name] = valid ? parsed : PARSABLE_DEFAULTS[name];
      }
    }
  }
  intlChange() {
    delete this.numericRegex;
    if (this.numericInput && (!this.focused || !this.isValid(this.elementValue))) {
      this.setInputValue();
    }
  }
  hasTrailingZeros(inputValue) {
    if (this.hasDecimals && this.focused) {
      const fraction = inputValue.split(this.decimalSeparator)[1];
      return fraction && fraction.length > this.decimals && fraction.lastIndexOf("0") === fraction.length - 1;
    }
  }
  selectAll() {
    this.setInputValue();
    this.setSelection(0, this.inputValue.length);
  }
  selectCaret() {
    const caretPosition = getCaretPosition(this.numericInput.nativeElement);
    const formattedValue = this.elementValue;
    const partialValue = formattedValue.substring(0, caretPosition);
    this.setInputValue();
    if (partialValue.length) {
      const significantCharsInFormattedValue = extractSignificantNumericChars(partialValue, this.decimalSeparator);
      const adjustedSignificantChars = this.adjustSignificantChars(formattedValue, significantCharsInFormattedValue);
      this.setSelection(adjustedSignificantChars, adjustedSignificantChars);
    } else {
      this.setSelection(0, 0);
    }
  }
  numberOfLeadingZeroes(formattedValue) {
    const separatorIndex = formattedValue.indexOf(this.decimalSeparator);
    const matchedLeadingZeroes = formattedValue.match(/^[^1-9]*?(0+)/);
    if (matchedLeadingZeroes) {
      const lengthOfMatch = matchedLeadingZeroes[0].length;
      const lengthOfLeadingZeroesMatch = matchedLeadingZeroes[1].length;
      return lengthOfMatch === separatorIndex ? lengthOfLeadingZeroesMatch - 1 : lengthOfLeadingZeroesMatch;
    }
    return 0;
  }
  adjustSignificantChars(formattedValue, significantChars) {
    const leadingZeroes = this.numberOfLeadingZeroes(formattedValue);
    if (leadingZeroes > 0) {
      return Math.max(0, significantChars - leadingZeroes);
    }
    return significantChars;
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.numericInput.nativeElement, this.ngZone);
  }
  static ɵfac = function NumericTextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxComponent)(ɵɵdirectiveInject(IntlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericTextBoxComponent,
    selectors: [["kendo-numerictextbox"]],
    contentQueries: function NumericTextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function NumericTextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c13, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.numericInput = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function NumericTextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disableClass)("k-input", ctx.hostClasses)("k-numerictextbox", ctx.hostClasses);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      autoCorrect: "autoCorrect",
      format: "format",
      max: "max",
      min: "min",
      decimals: "decimals",
      placeholder: "placeholder",
      step: "step",
      spinners: "spinners",
      rangeValidation: "rangeValidation",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      changeValueOnScroll: "changeValueOnScroll",
      selectOnFocus: "selectOnFocus",
      value: "value",
      maxlength: "maxlength",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    exportAs: ["kendoNumericTextBox"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.numerictextbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _NumericTextBoxComponent),
      multi: true
    }, {
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _NumericTextBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _NumericTextBoxComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 9,
    vars: 28,
    consts: () => {
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_7 = goog.getMsg("Increase value");
        i18n_7 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox:Increase value`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_8 = goog.getMsg("Decrease value");
        i18n_8 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox:Decrease value`;
      }
      return [["numericInput", ""], ["kendoNumericTextBoxLocalizedMessages", "", "increment", i18n_7, "decrement", i18n_8], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["role", "spinbutton", "autocomplete", "off", "autocorrect", "off", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["class", "k-input-spinner k-spin-button", 3, "kendoEventsOutsideAngular", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [1, "k-input-spinner", "k-spin-button", 3, "kendoEventsOutsideAngular"], ["type", "button", "tabindex", "-1", 1, "k-spinner-increase", "k-button", "k-button-md", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], ["name", "caret-alt-up", "innerCssClass", "k-button-icon", 3, "svgIcon"], ["type", "button", "tabindex", "-1", 1, "k-spinner-decrease", "k-button", "k-button-md", "k-icon-button", "k-button-solid", "k-button-solid-base", 3, "kendoEventsOutsideAngular", "title"], ["name", "caret-alt-down", "innerCssClass", "k-button-icon", 3, "svgIcon"]];
    },
    template: function NumericTextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 1);
        ɵɵelementContainerStart(1, 2);
        ɵɵtwoWayListener("isFocusedChange", function NumericTextBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.focused, $event) || (ctx.focused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function NumericTextBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function NumericTextBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, NumericTextBoxComponent_span_2_Template, 2, 1, "span", 3)(3, NumericTextBoxComponent_kendo_input_separator_3_Template, 1, 0, "kendo-input-separator", 4);
        ɵɵelement(4, "input", 5, 0);
        ɵɵtemplate(6, NumericTextBoxComponent_kendo_input_separator_6_Template, 1, 0, "kendo-input-separator", 4)(7, NumericTextBoxComponent_span_7_Template, 2, 1, "span", 6)(8, NumericTextBoxComponent_span_8_Template, 5, 22, "span", 7);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.focused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction7(20, _c14, ctx.handleMouseDown, ctx.handleDragEnter, ctx.handleKeyDown, ctx.handleInput, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handlePaste));
        ɵɵattribute("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.value)("title", ctx.title)("placeholder", ctx.placeholder)("maxLength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffixTemplate && (ctx.suffixTemplate == null ? null : ctx.suffixTemplate.showSeparator));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spinners);
      }
    },
    dependencies: [LocalizedNumericTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoNumericTextBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.numerictextbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => NumericTextBoxComponent),
        multi: true
      }, {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => NumericTextBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => NumericTextBoxComponent)
      }],
      selector: "kendo-numerictextbox",
      template: `
        <ng-container kendoNumericTextBoxLocalizedMessages
            i18n-increment="kendo.numerictextbox.increment|The title for the **Increment** button in the NumericTextBox"
            increment="Increase value"
            i18n-decrement="kendo.numerictextbox.decrement|The title for the **Decrement** button in the NumericTextBox"
            decrement="Decrease value"
        >
        </ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="focused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-input-separator>
            <input #numericInput
                class="k-input-inner"
                role="spinbutton"
                autocomplete="off"
                autocorrect="off"
                [id]="focusableId"
                [attr.aria-valuemin]="min"
                [attr.aria-valuemax]="max"
                [attr.aria-valuenow]="value"
                [attr.title]="title"
                [attr.placeholder]="placeholder"
                [attr.maxLength]="maxlength"
                [tabindex]="tabIndex"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    mousedown: handleMouseDown,
                    dragenter: handleDragEnter,
                    keydown: handleKeyDown,
                    input: handleInput,
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    paste: handlePaste
                }"/>
            <kendo-input-separator *ngIf="suffixTemplate && suffixTemplate?.showSeparator"></kendo-input-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <span
                class="k-input-spinner k-spin-button" *ngIf="spinners"
                [kendoEventsOutsideAngular]="{ mouseup: releaseArrow, mouseleave: releaseArrow }"
            >
            <button
                type="button"
                [kendoEventsOutsideAngular]="{ mousedown: increasePress }"
                [attr.aria-hidden]="true"
                [attr.aria-label]="incrementTitle"
                [title]="incrementTitle"
                class="k-spinner-increase k-button k-button-md k-icon-button k-button-solid k-button-solid-base"
                [class.k-active]="arrowDirection === ArrowDirection.Up"
                tabindex="-1"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    innerCssClass="k-button-icon"
                    [svgIcon]="arrowUpIcon"
                >
                </kendo-icon-wrapper>
            </button>
            <button
                type="button"
                [kendoEventsOutsideAngular]="{ mousedown: decreasePress }"
                [attr.aria-hidden]="true"
                [attr.aria-label]="decrementTitle"
                [title]="decrementTitle"
                [class.k-active]="arrowDirection === ArrowDirection.Down"
                class="k-spinner-decrease k-button k-button-md k-icon-button k-button-solid k-button-solid-base"
                tabindex="-1"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    innerCssClass="k-button-icon"
                    [svgIcon]="arrowDownIcon"
                >
                    </kendo-icon-wrapper>
                </button>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [LocalizedNumericTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: IntlService
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    autoCorrect: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    decimals: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    spinners: [{
      type: Input
    }],
    rangeValidation: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    changeValueOnScroll: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    numericInput: [{
      type: ViewChild,
      args: ["numericInput", {
        static: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    disableClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-numerictextbox"]
    }]
  });
})();
var NumericTextBoxCustomMessagesComponent = class _NumericTextBoxCustomMessagesComponent extends NumericTextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function NumericTextBoxCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _NumericTextBoxCustomMessagesComponent,
    selectors: [["kendo-numerictextbox-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: NumericTextBoxMessages,
      useExisting: forwardRef(() => _NumericTextBoxCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function NumericTextBoxCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: NumericTextBoxMessages,
        useExisting: forwardRef(() => NumericTextBoxCustomMessagesComponent)
      }],
      selector: "kendo-numerictextbox-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var ResultType2;
(function(ResultType3) {
  ResultType3[ResultType3["Literal"] = 0] = "Literal";
  ResultType3[ResultType3["Mask"] = 1] = "Mask";
  ResultType3[ResultType3["Undefined"] = 2] = "Undefined";
})(ResultType2 || (ResultType2 = {}));
var Result2 = class _Result {
  value;
  rest;
  type;
  constructor(value, rest, type = ResultType2.Undefined) {
    this.value = value;
    this.rest = rest;
    this.type = type;
  }
  //map :: Functor f => f a ~> (a -> b) -> f b
  map(fn) {
    return new _Result(fn(this.value), this.rest);
  }
  //chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(fn) {
    return fn(this.value, this.rest);
  }
  fold(s, _) {
    return s(this.value, this.rest);
  }
  concat(r) {
    return this.map((vs, _) => r.chain((v, __) => vs.concat([v])));
  }
  toString() {
    return `Result({ value: '${this.value}', rest: ${this.rest} })`;
  }
};
var Stream2 = class {
  input;
  control;
  inputCursor = 0;
  controlCursor = 0;
  constructor(input = [], control = []) {
    this.input = input;
    this.control = control;
  }
  eof() {
    return this.inputCursor >= this.input.length;
  }
  // Get the first value from the input.
  next() {
    return {
      char: this.input[this.inputCursor++],
      control: this.control[this.controlCursor++]
    };
  }
  peek() {
    return {
      char: this.input[this.inputCursor],
      control: this.control[this.controlCursor]
    };
  }
  eat_input() {
    this.inputCursor++;
  }
  eat_control() {
    this.controlCursor++;
  }
  eat() {
    this.inputCursor++;
    this.controlCursor++;
  }
};
var toArray2 = (value) => (value || "").split("");
var ESCAPE_CHARACTER2 = "\\";
var Parser2 = class _Parser {
  parse;
  constructor(parse) {
    this.parse = parse;
  }
  run(input, control = "") {
    if (input instanceof Stream2) {
      return this.parse(input);
    } else {
      return this.parse(new Stream2(toArray2(input), toArray2(control)));
    }
  }
  //map :: Functor f => f a ~> (a -> b) -> f b
  map(f) {
    return new _Parser((stream) => this.parse(stream).map(f));
  }
  //chain :: Chain m => m a ~> (a -> m b) -> m b
  chain(f) {
    return new _Parser((stream) => this.parse(stream).chain((v, s) => f(v).run(s)));
  }
  isLiteral(c) {
    return this.run(c).type === ResultType2.Literal;
  }
};
var mask2 = ({
  prompt,
  promptPlaceholder
}) => (rule) => new Parser2((stream) => {
  while (!stream.eof()) {
    const {
      char,
      control
    } = stream.peek();
    if (char === control && control === prompt) {
      stream.eat();
      return new Result2(prompt, stream, ResultType2.Mask);
    }
    if (rule.test(char)) {
      stream.eat();
      return new Result2(char, stream, ResultType2.Mask);
    }
    if (char === promptPlaceholder) {
      stream.eat();
      return new Result2(prompt, stream, ResultType2.Mask);
    }
    stream.eat_input();
  }
  stream.eat();
  return new Result2(prompt, stream, ResultType2.Mask);
});
var literal2 = (_token) => new Parser2((stream) => {
  const char = stream.peek().char;
  if (char === _token) {
    stream.eat();
    return new Result2(_token, stream, ResultType2.Literal);
  }
  return new Result2(_token, stream, ResultType2.Literal);
});
var unmask2 = (prompt) => (rule) => new Parser2((stream) => {
  while (!stream.eof()) {
    const {
      char,
      control
    } = stream.peek();
    if (char === prompt && control === prompt) {
      stream.eat();
      return new Result2(char, stream);
    }
    if (rule.test(char)) {
      stream.eat();
      return new Result2(char, stream);
    }
    stream.eat_input();
  }
  stream.eat();
  return new Result2("", stream);
});
var unliteral2 = (_token) => new Parser2((stream) => {
  if (stream.eof()) {
    return new Result2("", stream);
  }
  const {
    char
  } = stream.peek();
  if (char === _token) {
    stream.eat();
  }
  return new Result2(_token, stream);
});
var token2 = (rules, creator) => new Parser2((stream) => {
  let {
    char
  } = stream.next();
  const rule = rules[char];
  if (char === ESCAPE_CHARACTER2) {
    char = stream.next().char;
    return new Result2(creator.literal(char), stream);
  }
  if (!rule) {
    return new Result2(creator.literal(char), stream);
  }
  return new Result2(creator.mask(rule), stream);
});
var rawMask2 = ({
  prompt,
  promptPlaceholder
}) => new Parser2((stream) => {
  const {
    char
  } = stream.next();
  if (char === prompt) {
    return new Result2(promptPlaceholder, stream);
  }
  return new Result2(char, stream);
});
var rawLiteral2 = (includeLiterals) => new Parser2((stream) => {
  const {
    char
  } = stream.next();
  if (includeLiterals) {
    return new Result2(char, stream);
  }
  return new Result2("", stream);
});
var always2 = (value) => new Parser2((stream) => new Result2(value, stream));
var append2 = (p1, p2) => p1.chain((vs) => p2.map((v) => vs.concat([v])));
var sequence2 = (list) => list.reduce((acc, parser) => append2(acc, parser), always2([]));
var greedy2 = (parser) => new Parser2((stream) => {
  let result = new Result2([], stream);
  while (!stream.eof()) {
    result = result.concat(parser.run(stream));
  }
  return result;
});
var MaskingService2 = class _MaskingService {
  rules = {};
  prompt = "_";
  mask = "";
  promptPlaceholder = " ";
  includeLiterals = false;
  maskTokens = [];
  unmaskTokens = [];
  rawTokens = [];
  validationTokens = [];
  update({
    mask: mask3 = "",
    prompt = "",
    promptPlaceholder = " ",
    rules = {},
    includeLiterals = false
  }) {
    this.mask = mask3;
    this.prompt = prompt;
    this.promptPlaceholder = promptPlaceholder;
    this.rules = rules;
    this.includeLiterals = includeLiterals;
    this.tokenize();
  }
  validationValue(maskedValue = "") {
    let value = maskedValue;
    sequence2(this.validationTokens).run(maskedValue).fold((unmasked) => {
      value = unmasked.join("");
    });
    return value;
  }
  rawValue(maskedValue = "") {
    let value = maskedValue;
    if (!this.rawTokens.length) {
      return value;
    }
    sequence2(this.rawTokens).run(maskedValue).fold((unmasked) => {
      value = unmasked.join("");
    });
    return value;
  }
  /**
   * @hidden
   */
  maskRaw(rawValue = "") {
    let value = rawValue;
    if (!this.maskTokens.length) {
      return value;
    }
    sequence2(this.maskTokens).run(rawValue).fold((masked) => {
      value = masked.join("");
    });
    return value;
  }
  maskInput(input, control, splitPoint) {
    if (input.length < control.length) {
      return this.maskRemoved(input, control, splitPoint);
    }
    return this.maskInserted(input, control, splitPoint);
  }
  maskInRange(pasted, oldValue, start, end) {
    let value = "";
    const selection = end;
    const beforeChange = oldValue.split("").slice(0, start);
    const afterChange = oldValue.split("").slice(end);
    sequence2(this.maskTokens.slice(start, end)).run(pasted).fold((masked) => {
      value = beforeChange.concat(masked).concat(afterChange).join("");
    });
    return {
      selection,
      value
    };
  }
  maskRemoved(input, control, splitPoint) {
    let value = "";
    let selection = splitPoint;
    const unchanged = input.split("").slice(splitPoint);
    const changed = input.split("").slice(0, splitPoint).join("");
    const take2 = this.maskTokens.length - (input.length - splitPoint);
    sequence2(this.maskTokens.slice(0, take2)).run(changed, control).fold((masked) => {
      selection = this.adjustPosition(masked, selection);
      value = masked.concat(unchanged).join("");
    });
    return {
      selection,
      value
    };
  }
  adjustPosition(input, selection) {
    const caretChar = input[selection];
    const isLiteral = this.maskTokens[selection].isLiteral(caretChar);
    if (!isLiteral && caretChar !== this.prompt) {
      return selection + 1;
    }
    return selection;
  }
  maskInserted(input, control, splitPoint) {
    let value = "";
    let selection = splitPoint;
    const changed = input.slice(0, splitPoint);
    sequence2(this.unmaskTokens).run(changed, control).chain((unmasked) => {
      selection = unmasked.join("").length;
      const unchanged = control.slice(selection);
      return sequence2(this.maskTokens).run(unmasked.join("") + unchanged, control);
    }).fold((masked) => {
      value = masked.join("");
    });
    return {
      selection,
      value
    };
  }
  get maskTokenCreator() {
    const {
      prompt,
      promptPlaceholder
    } = this;
    return {
      literal: (rule) => literal2(rule),
      mask: (rule) => mask2({
        prompt,
        promptPlaceholder
      })(rule)
    };
  }
  get unmaskTokenCreator() {
    return {
      literal: (rule) => unliteral2(rule),
      mask: (rule) => unmask2(this.prompt)(rule)
    };
  }
  get rawTokenCreator() {
    const {
      prompt,
      promptPlaceholder,
      includeLiterals
    } = this;
    return {
      literal: (_) => rawLiteral2(includeLiterals),
      mask: (_) => rawMask2({
        prompt,
        promptPlaceholder
      })
    };
  }
  get validationTokenCreator() {
    const {
      prompt
    } = this;
    return {
      literal: (_) => rawLiteral2(false),
      mask: (_) => rawMask2({
        prompt,
        promptPlaceholder: ""
      })
    };
  }
  tokenize() {
    greedy2(token2(this.rules, this.maskTokenCreator)).run(this.mask).fold((tokens, _) => {
      this.maskTokens = tokens;
    });
    greedy2(token2(this.rules, this.unmaskTokenCreator)).run(this.mask).fold((tokens, _) => {
      this.unmaskTokens = tokens;
    });
    greedy2(token2(this.rules, this.rawTokenCreator)).run(this.mask).fold((tokens, _) => {
      this.rawTokens = tokens;
    });
    greedy2(token2(this.rules, this.validationTokenCreator)).run(this.mask).fold((tokens, _) => {
      this.validationTokens = tokens;
    });
  }
  static ɵfac = function MaskingService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskingService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MaskingService,
    factory: _MaskingService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskingService2, [{
    type: Injectable
  }], null, null);
})();
var resolvedPromise = Promise.resolve(null);
var FOCUSED$3 = "k-focus";
var DEFAULT_SIZE$c = "medium";
var DEFAULT_ROUNDED$7 = "medium";
var DEFAULT_FILL_MODE$5 = "solid";
var MaskedTextBoxComponent = class _MaskedTextBoxComponent {
  service;
  renderer;
  hostElement;
  ngZone;
  injector;
  changeDetector;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Disables the MaskedTextBox when you set it to `true` ([see example]({% slug disabled_maskedtextbox %})).
   * To disable the component in reactive forms, see [Forms Support](slug:formssupport_maskedtextbox#toc-managing-the-maskedtextbox-disabled-state-in-reactive-forms).
   * @default false
   */
  disabled = false;
  /**
   * When `true`, sets the MaskedTextBox to read-only mode ([see example]({% slug readonly_maskedtextbox %})).
   * @default false
   */
  readonly = false;
  /**
   * Sets the `title` attribute of the input element.
   */
  title;
  /**
   * Sets the padding size of the MaskedTextBox input element ([see example]({% slug appearance_maskedtextbox %}#toc-size)).
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$c;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the MaskedTextBox ([see example](slug:appearance_maskedtextbox#toc-roundness)).
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded || DEFAULT_ROUNDED$7;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the background and border style of the MaskedTextBox ([see example]({% slug appearance_maskedtextbox %}#toc-fill-mode)).
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode || DEFAULT_FILL_MODE$5;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the mask pattern for the MaskedTextBox ([see example]({% slug value_maskedtextbox %})).
   * If you do not set a mask, the component acts as a standard `type="text"` input.
   *
   * If the mask allows spaces, set the [`promptPlaceholder`]({% slug api_inputs_maskedtextboxcomponent %}#toc-promptplaceholder)
   * to a character that the mask does not accept.
   */
  mask;
  /**
   * Sets the value of the MaskedTextBox.
   */
  value;
  /**
   * Sets the RegExp-based mask validation rules ([see example]({% slug masks_maskedtextbox %})).
   */
  set rules(value) {
    this._rules = __spreadValues(__spreadValues({}, this.defaultRules), value);
  }
  get rules() {
    return this._rules || this.defaultRules;
  }
  /**
   * Sets the prompt character for the masked value.
   * @default `_`
   */
  prompt = "_";
  /**
   * Sets the character that represents an empty position in the raw value.
   * @default ' '
   */
  promptPlaceholder = " ";
  /**
   * When `true` includes literals in the raw value ([see example]({% slug value_maskedtextbox %})).
   * @default false
   */
  includeLiterals = false;
  /**
   * Shows the mask on focus when the value is empty.
   */
  maskOnFocus = false;
  /**
   * Enables the built-in mask validator when you set it to `true` ([see example]({% slug validation_maskedtextbox %})).
   * @default true
   */
  maskValidation = true;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) attribute of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets HTML attributes for the inner input element.
   * You cannot change attributes that are essential for component functionality.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.tabIndex,
      "aria-invalid": this.isControlInvalid,
      title: this.title,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      "aria-placeholder": this.mask,
      autocomplete: "off",
      autocorrect: "off",
      autocapitalize: "off",
      spellcheck: "false"
    };
  }
  /**
   * Fires when the MaskedTextBox gets focused.
   *
   * To subscribe programmatically, use the `onFocus` property.
   *
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the MaskedTextBox gets blurred.
   *
   * To subscribe programmatically, use the `onBlur` property.
   *
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the input element gets focused.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires when the input element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires when the value changes.
   */
  valueChange = new EventEmitter();
  direction;
  hostClasses = true;
  get hostDisabledClass() {
    return this.disabled;
  }
  /**
   * Returns the `ElementRef` of the visible `input` element.
   */
  input;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  isFocused;
  maskedValue;
  focusClick = false;
  defaultRules = {
    "#": /[\d\s\+\-]/,
    "&": /[\S]/,
    "0": /[\d]/,
    "9": /[\d\s]/,
    "?": /[a-zA-Z\s]/,
    "A": /[a-zA-Z0-9]/,
    "C": /./,
    "L": /[a-zA-Z]/,
    "a": /[a-zA-Z0-9\s]/
  };
  _rules;
  isPasted = false;
  selection = [0, 0];
  control;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _inputAttributes;
  parsedAttributes = {};
  constructor(service, renderer, hostElement, ngZone, injector, changeDetector, rtl) {
    this.service = service;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.ngZone = ngZone;
    this.injector = injector;
    this.changeDetector = changeDetector;
    validatePackage(packageMetadata2);
    this.direction = rtl ? "rtl" : "ltr";
    this.updateService();
  }
  ngOnInit() {
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the MaskedTextBox is empty.
   */
  isEmpty() {
    if (this.input) {
      return !this.input.nativeElement.value;
    }
  }
  /**
   * @hidden
   */
  handleFocus = () => {
    this.ngZone.run(() => {
      if (!this.focused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.focused = true;
    });
    if (this.maskOnFocus && this.emptyMask) {
      this.updateInput(this.service.maskRaw(this.value));
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.setSelection(0, 0);
        }, 0);
      });
    }
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this.ngZone.run(() => {
        this.inputFocus.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleClick = () => {
    if (this.focused && !this.focusClick) {
      this.focusClick = true;
    }
    if (this.promptPlaceholder === null || this.promptPlaceholder === "") {
      const {
        selectionStart,
        selectionEnd
      } = this.input.nativeElement;
      if (selectionStart === selectionEnd) {
        this.setFocusSelection();
      }
    }
  };
  /**
   * @hidden
   */
  handleBlur = () => {
    this.changeDetector.markForCheck();
    this.focused = false;
    this.focusClick = false;
    if (this.maskOnFocus && this.emptyMask) {
      this.updateInput(this.maskedValue);
    }
    if (hasObservers(this.onBlur)) {
      this.ngZone.run(() => {
        this.onBlur.emit();
      });
    }
    this.ngZone.run(() => {
      if (this.control) {
        this.control && !this.control.touched && this.onTouched();
      }
    });
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleDragDrop() {
    return false;
  }
  /**
   * Focuses the MaskedTextBox.
   *
   * @example
   * ```ts-no-run
   * _@Component({
   * selector: 'my-app',
   * template: `
   *  <button (click)="maskedinput.focus()">Focus the input</button>
   *  <kendo-maskedtextbox #maskedinput></kendo-maskedtextbox>
   * `
   * })
   * class AppComponent { }
   * ```
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.input.nativeElement.focus();
    this.focused = true;
    this.setFocusSelection();
  }
  /**
   * Blurs the MaskedTextBox.
   */
  blur() {
    if (!this.input) {
      return;
    }
    this.input.nativeElement.blur();
    this.focused = false;
  }
  /**
   * @hidden
   */
  pasteHandler(e) {
    const {
      selectionStart,
      selectionEnd
    } = e.target;
    if (selectionEnd === selectionStart) {
      return;
    }
    this.isPasted = true;
    this.selection = [selectionStart, selectionEnd];
  }
  /**
   * @hidden
   */
  inputHandler(e) {
    const value = e.target.value;
    const [start, end] = this.selection;
    if (!this.mask) {
      this.updateValueWithEvents(value);
      this.isPasted = false;
      return;
    }
    let result;
    if (this.isPasted) {
      this.isPasted = false;
      const rightPart = this.maskedValue.length - end;
      const to = value.length - rightPart;
      result = this.service.maskInRange(value.slice(start, to), this.maskedValue, start, end);
    } else {
      result = this.service.maskInput(value, this.maskedValue || "", e.target.selectionStart);
    }
    this.updateInput(result.value, result.selection);
    this.updateValueWithEvents(result.value);
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (changes["value"]) {
      this.value = this.normalizeValue(this.value);
    }
    const next = this.extractChanges(changes);
    this.updateService(next);
    if (!this.mask) {
      this.updateInput(this.value);
      return;
    }
    const maskedValue = this.service.maskRaw(this.value);
    this.updateInput(maskedValue, null, true);
    if (changes["includeLiterals"] || isChanged("promptPlaceholder", changes)) {
      resolvedPromise.then(() => {
        this.updateValueWithEvents(this.maskedValue, false);
      });
    }
  }
  /**
   * @hidden
   * Writes a new value to the element.
   */
  writeValue(value) {
    this.value = this.normalizeValue(value);
    this.updateInput(this.service.maskRaw(this.value));
    if (this.includeLiterals) {
      this.updateValue(this.maskedValue, false);
    }
  }
  /**
   * @hidden
   * Sets the function that will be called when a `change` event is triggered.
   */
  registerOnChange(fn) {
    this.onChange = fn;
  }
  /**
   * @hidden
   * Sets the function that will be called when a `touch` event is triggered.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  validate(_) {
    if (this.maskValidation === false || !this.mask) {
      return null;
    }
    if (!this.service.validationValue(this.maskedValue)) {
      return null;
    }
    if (this.maskedValue.indexOf(this.prompt) !== -1) {
      return {
        patternError: {
          mask: this.mask,
          maskedValue: this.maskedValue,
          value: this.value
        }
      };
    }
    return null;
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && this.control.invalid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  updateValueWithEvents(maskedValue, callOnChange = true) {
    const previousValue = this.value;
    this.updateValue(maskedValue, callOnChange);
    const valueChanged = this.value !== previousValue;
    if (valueChanged && hasObservers(this.valueChange)) {
      this.valueChange.emit(this.value);
    }
  }
  onChange = (_) => {
  };
  onTouched = () => {
  };
  updateValue(value, callOnChange = true) {
    if (this.mask && !this.service.validationValue(value) && !this.includeLiterals) {
      this.value = "";
    } else {
      this.value = this.service.rawValue(value);
    }
    callOnChange && this.onChange(this.value);
  }
  updateInput(maskedValue = "", selection, isFromOnChanges) {
    if (isFromOnChanges && maskedValue === this.maskedValue) {
      return;
    }
    this.maskedValue = maskedValue;
    const value = this.maskOnFocus && !this.focused && this.emptyMask ? "" : maskedValue;
    this.renderer.setProperty(this.input.nativeElement, "value", value);
    if (selection !== void 0) {
      this.setSelection(selection, selection);
    }
  }
  extractChanges(changes) {
    return Object.keys(changes).filter((key) => key !== "rules").reduce((obj, key) => {
      obj[key] = changes[key].currentValue;
      return obj;
    }, {});
  }
  updateService(extra) {
    const config = Object.assign({
      includeLiterals: this.includeLiterals,
      mask: this.mask,
      prompt: this.prompt,
      promptPlaceholder: this.promptPlaceholder,
      rules: this.rules
    }, extra);
    this.service.update(config);
  }
  setSelection(start = this.selection[0], end = this.selection[1]) {
    if (this.focused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  get emptyMask() {
    return this.service.maskRaw() === this.maskedValue;
  }
  setFocusSelection() {
    const selectionStart = this.input.nativeElement.selectionStart;
    const index = this.maskedValue ? this.maskedValue.indexOf(this.prompt) : 0;
    if (index >= 0 && index < selectionStart) {
      this.selection = [index, index];
      this.setSelection();
    }
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  /**
   * @hidden
   */
  set focused(value) {
    if (this.isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value) {
        this.renderer.addClass(element, FOCUSED$3);
      } else {
        this.renderer.removeClass(element, FOCUSED$3);
      }
      this.isFocused = value;
    }
  }
  normalizeValue(value) {
    const present = isPresent3(value);
    if (present && typeof value !== "string") {
      if (isDevMode()) {
        throw new Error("The MaskedTextBox component supports only string values.");
      }
      return String(value);
    }
    return present ? value : "";
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function MaskedTextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskedTextBoxComponent)(ɵɵdirectiveInject(MaskingService2), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RTL, 8));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MaskedTextBoxComponent,
    selectors: [["kendo-maskedtextbox"]],
    contentQueries: function MaskedTextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function MaskedTextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c17, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function MaskedTextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("paste", function MaskedTextBoxComponent_paste_HostBindingHandler($event) {
          return ctx.pasteHandler($event);
        })("input", function MaskedTextBoxComponent_input_HostBindingHandler($event) {
          return ctx.inputHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-input", ctx.hostClasses)("k-maskedtextbox", ctx.hostClasses)("k-disabled", ctx.hostDisabledClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      disabled: "disabled",
      readonly: "readonly",
      title: "title",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      mask: "mask",
      value: "value",
      rules: "rules",
      prompt: "prompt",
      promptPlaceholder: "promptPlaceholder",
      includeLiterals: "includeLiterals",
      maskOnFocus: "maskOnFocus",
      maskValidation: "maskValidation",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoMaskedTextBox"],
    standalone: true,
    features: [ɵɵProvidersFeature([MaskingService2, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
      /* eslint-disable-line*/
    }, {
      multi: true,
      provide: NG_VALIDATORS,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MaskedTextBoxComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 7,
    vars: 21,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["autocomplete", "off", "autocorrect", "off", "autocapitalize", "off", "spellcheck", "false", 1, "k-input-inner", 3, "id", "tabindex", "disabled", "readonly", "kendoEventsOutsideAngular"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], [1, "k-input-suffix", "k-input-suffix-horizontal"]],
    template: function MaskedTextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function MaskedTextBoxComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.focused, $event) || (ctx.focused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MaskedTextBoxComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MaskedTextBoxComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(1, MaskedTextBoxComponent_span_1_Template, 2, 1, "span", 2)(2, MaskedTextBoxComponent_kendo_input_separator_2_Template, 1, 0, "kendo-input-separator", 3);
        ɵɵelement(3, "input", 4, 0);
        ɵɵtemplate(5, MaskedTextBoxComponent_kendo_input_separator_5_Template, 1, 0, "kendo-input-separator", 3)(6, MaskedTextBoxComponent_span_6_Template, 2, 1, "span", 5);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.focused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("tabindex", ctx.tabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction5(15, _c18, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleClick, ctx.handleDragDrop, ctx.handleDragDrop));
        ɵɵattribute("title", ctx.title)("aria-placeholder", ctx.mask)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
      }
    },
    dependencies: [SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskedTextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMaskedTextBox",
      providers: [MaskingService2, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
        /* eslint-disable-line*/
      }, {
        multi: true,
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MaskedTextBoxComponent)
      }],
      selector: "kendo-maskedtextbox",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="focused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-input-separator>
            <input #input
                class="k-input-inner"
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
                [id]="focusableId"
                [tabindex]="tabIndex"
                [attr.title]="title"
                [attr.aria-placeholder]="mask"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [disabled]="disabled"
                [readonly]="readonly"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    click: handleClick,
                    dragstart: handleDragDrop,
                    drop: handleDragDrop
                }"
            />
            <kendo-input-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-input-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: MaskingService2
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    title: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    mask: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    rules: [{
      type: Input
    }],
    prompt: [{
      type: Input
    }],
    promptPlaceholder: [{
      type: Input
    }],
    includeLiterals: [{
      type: Input
    }],
    maskOnFocus: [{
      type: Input
    }],
    maskValidation: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-input"]
    }, {
      type: HostBinding,
      args: ["class.k-maskedtextbox"]
    }],
    hostDisabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    pasteHandler: [{
      type: HostListener,
      args: ["paste", ["$event"]]
    }],
    inputHandler: [{
      type: HostListener,
      args: ["input", ["$event"]]
    }]
  });
})();
var FOCUSED$2 = "k-focus";
var DEFAULT_SIZE$b = "medium";
var RadioCheckBoxBase = class _RadioCheckBoxBase {
  componentType;
  hostElement;
  renderer;
  cdr;
  ngZone;
  injector;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the `title` attribute of the `input` element of the component.
   */
  title;
  /**
   * Sets the `name` attribute for the component.
   */
  name;
  /**
   * Sets the disabled state of the component.
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the `tabindex` of the component.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Provides a value for the component.
   */
  value;
  /**
   * The size property specifies the width and height of the component.
   *
   * @default 'medium'
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$b;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
  }
  /**
   * Fires each time the user focuses the component.
   *
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the component gets blurred.
   *
   */
  onBlur = new EventEmitter();
  /**
   * Focuses the component.
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the component.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.cdr.markForCheck();
    if (requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
      });
    }
  };
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.ngTouched();
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * Represents the visible `input` element.
   */
  input;
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.input) {
      const element = this.input.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED$2);
      } else {
        this.renderer.removeClass(element, FOCUSED$2);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  control;
  focusChangedProgrammatically = false;
  get defaultAttributes() {
    return null;
  }
  parsedAttributes = {};
  _inputAttributes;
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  _isFocused = false;
  _size = DEFAULT_SIZE$b;
  constructor(componentType, hostElement, renderer, cdr, ngZone, injector) {
    this.componentType = componentType;
    this.hostElement = hostElement;
    this.renderer = renderer;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
  }
  /**
   * @hidden
   */
  writeValue(_value) {
  }
  handleClasses(value, input) {
    if (!isPresent(this.input)) {
      return;
    }
    const inputElem = this.input.nativeElement;
    const classes = getStylingClasses(this.componentType, input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(inputElem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(inputElem, classes.toAdd);
    }
  }
  setInputAttributes() {
    setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function RadioCheckBoxBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioCheckBoxBase)(ɵɵdirectiveInject(COMPONENT_TYPE), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RadioCheckBoxBase,
    selectors: [["ng-component"]],
    viewQuery: function RadioCheckBoxBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c17, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    inputs: {
      focusableId: "focusableId",
      title: "title",
      name: "name",
      disabled: "disabled",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      value: "value",
      size: "size",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur"
    },
    decls: 0,
    vars: 0,
    template: function RadioCheckBoxBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioCheckBoxBase, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [COMPONENT_TYPE]
      }]
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }]
  });
})();
var DEFAULT_ROUNDED$6 = "medium";
var CheckBoxComponent = class _CheckBoxComponent extends RadioCheckBoxBase {
  renderer;
  hostElement;
  cdr;
  ngZone;
  injector;
  hostClass = true;
  /**
   * Sets the checked state of the component.
   *
   * Use `true`, `false`, or `'indeterminate'` to control the state.
   *
   * @default false
   */
  set checkedState(value) {
    this._checkedState = value;
    if (!isPresent(this.input)) {
      return;
    }
    this.input.nativeElement.indeterminate = value === "indeterminate";
  }
  get checkedState() {
    return this._checkedState;
  }
  /**
   * Sets the `rounded` property to specify the border radius of the CheckBox
   * ([see example](slug:appearance_checkboxdirective#toc-roundness)).
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded || DEFAULT_ROUNDED$6;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Fires when the inner input's checked state changes.
   * This event does not fire when you change the state programmatically using `ngModel` or `formControl`.
   * Use this event for two-way binding with the `checkedState` property.
   */
  checkedStateChange = new EventEmitter();
  /**
   * @hidden
   */
  get isChecked() {
    return typeof this.checkedState === "boolean" && this.checkedState;
  }
  /**
   * @hidden
   */
  get isIndeterminate() {
    return typeof this.checkedState === "string" && this.checkedState === "indeterminate";
  }
  get defaultAttributes() {
    return {
      type: "checkbox",
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      tabIndex: this.tabindex,
      disabled: this.disabled ? "" : null,
      value: this.value,
      checked: this.isChecked,
      "aria-invalid": this.isControlInvalid
    };
  }
  _rounded = DEFAULT_ROUNDED$6;
  _checkedState = false;
  constructor(renderer, hostElement, cdr, ngZone, injector) {
    super("checkbox", hostElement, renderer, cdr, ngZone, injector);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    validatePackage(packageMetadata2);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.input.nativeElement.indeterminate = this.checkedState === "indeterminate";
  }
  /**
   * @hidden
   */
  handleChange = ($event) => {
    this.ngZone.run(() => {
      this.checkedState = $event && $event.target && $event.target.checked;
      this.checkedStateChange.emit(this.checkedState);
      this.ngChange(this.checkedState);
      this.cdr.markForCheck();
    });
  };
  /**
   * @hidden
   */
  writeValue(value) {
    this.checkedState = value;
    this.cdr.markForCheck();
  }
  static ɵfac = function CheckBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CheckBoxComponent,
    selectors: [["kendo-checkbox"]],
    hostVars: 2,
    hostBindings: function CheckBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-checkbox-wrap", ctx.hostClass);
      }
    },
    inputs: {
      checkedState: "checkedState",
      rounded: "rounded"
    },
    outputs: {
      checkedStateChange: "checkedStateChange"
    },
    exportAs: ["kendoCheckBox"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.checkbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _CheckBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _CheckBoxComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 22,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["type", "checkbox", 1, "k-checkbox", 3, "id", "disabled", "value", "checked", "kendoEventsOutsideAngular"]],
    template: function CheckBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function CheckBoxComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function CheckBoxComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function CheckBoxComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵelement(1, "input", 2, 0);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled)("k-checked", ctx.isChecked)("k-indeterminate", ctx.isIndeterminate)("k-invalid", ctx.isControlInvalid);
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("value", ctx.value)("checked", ctx.isChecked)("kendoEventsOutsideAngular", ɵɵpureFunction2(19, _c19, ctx.handleInputBlur, ctx.handleChange));
        ɵɵattribute("title", ctx.title)("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
      }
    },
    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoCheckBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.checkbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => CheckBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => CheckBoxComponent)
      }],
      selector: "kendo-checkbox",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <input #input
                type="checkbox"
                class="k-checkbox"
                [id]="focusableId"
                [attr.title]="title"
                [disabled]="disabled"
                [class.k-disabled]="disabled"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [checked]="isChecked"
                [class.k-checked]="isChecked"
                [class.k-indeterminate]="isIndeterminate"
                [class.k-invalid]="isControlInvalid"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    blur: handleInputBlur,
                    change: handleChange
                }"
            />
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-checkbox-wrap"]
    }],
    checkedState: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    checkedStateChange: [{
      type: Output
    }]
  });
})();
var DEFAULT_SIZE$a = "medium";
var DEFAULT_ROUNDED$5 = "medium";
var CheckBoxDirective = class _CheckBoxDirective {
  renderer;
  hostElement;
  kendoClass = true;
  get isDisabled() {
    return this.hostElement.nativeElement.disabled;
  }
  /**
   * Sets the `size` property to specify the width and height of the CheckBox
   * ([see example]({% slug appearance_checkboxdirective %}#toc-size)).
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$a;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the `rounded` property to specify the border radius of the CheckBox
   * ([see example](slug:appearance_checkboxdirective#toc-roundness)).
   *
   * @default 'medium'
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$5;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  _size = "medium";
  _rounded = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("checkbox", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function CheckBoxDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckBoxDirective,
    selectors: [["input", "kendoCheckBox", ""]],
    hostVars: 4,
    hostBindings: function CheckBoxDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-checkbox", ctx.kendoClass)("k-disabled", ctx.isDisabled);
      }
    },
    inputs: {
      size: "size",
      rounded: "rounded"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoCheckBox]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    kendoClass: [{
      type: HostBinding,
      args: ["class.k-checkbox"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }]
  });
})();
var parseColor2 = (value, format, opacityEnabled = false, safe2 = true) => {
  const allowedFormats = ["hex", "rgba", "name"];
  if (allowedFormats.indexOf(format) === -1) {
    throw new Error(`Unsupported color output format '${format}'. The available options are 'hex', 'rgba' or 'name'.`);
  }
  if (!isPresent3(value)) {
    return;
  }
  if (format === "name") {
    return nameFormat(value, safe2);
  }
  const parsedColor = parseColor(value.trim(), safe2);
  if (!isPresent3(parsedColor)) {
    return;
  }
  const parsedColorResult = format === "hex" ? getHexValue(parsedColor, opacityEnabled) : parsedColor.toCssRgba();
  return parsedColorResult;
};
var getHSV = (value, safe2 = true) => {
  const parsed = parseColor(value, safe2);
  if (!isPresent3(parsed)) {
    return {};
  }
  return parsed.toHSV();
};
var getRGBA = (value, safe2 = true) => {
  const parsed = parseColor(value, safe2);
  if (!isPresent3(parsed)) {
    return {};
  }
  return parsed.toBytes();
};
var getColorFromHSV = (hsva, format = "rgba", opacityEnabled = false) => {
  const hue = fitIntoBounds(hsva.h, 0, 359.9);
  const saturation = fitIntoBounds(hsva.s, 0, 1);
  const value = fitIntoBounds(hsva.v, 0, 1);
  const alpha = fitIntoBounds(hsva.a, 0, 1);
  const color = color_default.fromHSV(hue, saturation, value, alpha);
  return format === "hex" ? getHexValue(color, opacityEnabled) : color.toCssRgba();
};
var getHexValue = (color, opacity) => {
  return opacity && color.a < 1 ? color.toCss({
    alpha: true
  }) : color.toCss();
};
var getColorFromHue = (hue) => {
  return getColorFromHSV({
    h: hue,
    s: 1,
    v: 1,
    a: 1
  });
};
var getColorFromRGBA = (rgba) => {
  const red = fitIntoBounds(rgba.r, 0, 255);
  const green = fitIntoBounds(rgba.g, 0, 255);
  const blue = fitIntoBounds(rgba.b, 0, 255);
  const alpha = fitIntoBounds(rgba.a, 0, 1);
  return color_default.fromBytes(red, green, blue, alpha).toCssRgba();
};
function nameFormat(value, safe2) {
  value = value.toLowerCase().trim();
  if (isPresent3(named_colors_default[value])) {
    return value;
  }
  if (parseColor(value, safe2)) {
    value = parseColor(value, safe2).toHex();
  }
  const key = Object.keys(named_colors_default).find((key2) => named_colors_default[key2] === value);
  if (!key && !safe2) {
    throw new Error(`The provided color ${value} is not supported for 'format="name"' property.To display ${value} color, the component 'format' property should be set to 'hex' or 'rgba' `);
  }
  return key;
}
var getRGBFromRGBA = (foregroundColor, backgroundColor) => {
  const r1 = fitIntoBounds(foregroundColor.r, 0, 255);
  const g1 = fitIntoBounds(foregroundColor.g, 0, 255);
  const b1 = fitIntoBounds(foregroundColor.b, 0, 255);
  const a1 = fitIntoBounds(foregroundColor.a, 0, 1);
  const r2 = fitIntoBounds(backgroundColor.r, 0, 255);
  const g2 = fitIntoBounds(backgroundColor.g, 0, 255);
  const b2 = fitIntoBounds(backgroundColor.b, 0, 255);
  return {
    r: Math.round((1 - a1) * r2 + a1 * r1),
    g: Math.round((1 - a1) * g2 + a1 * g1),
    b: Math.round((1 - a1) * b2 + a1 * b1)
  };
};
var getLuminance = (rgb) => {
  const a = [rgb.r, rgb.g, rgb.b].map(function(v) {
    v /= 255;
    return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722;
};
var getContrast = (luminance1, luminance2) => {
  const brightest = Math.max(luminance1, luminance2);
  const darkest = Math.min(luminance1, luminance2);
  return (brightest + 0.05) / (darkest + 0.05);
};
var getContrastFromTwoRGBAs = (a, b) => {
  return getContrast(getLuminance(getRGBFromRGBA(a, b)), getLuminance(getRGBFromRGBA(b, {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  })));
};
var bezierCommand = (controlPointCalc) => (point, i, a) => {
  const [cpsX, cpsY] = controlPointCalc(a[i - 1], a[i - 2], point);
  const [cpeX, cpeY] = controlPointCalc(point, a[i - 1], a[i + 1], true);
  return `C ${cpsX},${cpsY} ${cpeX},${cpeY} ${point[0]},${point[1]}`;
};
var controlPoint = (lineCalc) => (current, previous, next, reverse) => {
  const p = previous || current;
  const n = next || current;
  const smooth = 0.1;
  const l = lineCalc(p, n);
  const angle = l.angle + (reverse ? Math.PI : 0);
  const length = l.length * smooth;
  const x = current[0] + Math.cos(angle) * length;
  const y = current[1] + Math.sin(angle) * length;
  return [x, y];
};
var line = (pointA, pointB) => {
  const lengthX = pointB[0] - pointA[0];
  const lengthY = pointB[1] - pointA[1];
  return {
    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
    angle: Math.atan2(lengthY, lengthX)
  };
};
var svgPath = (points, command) => {
  if (points.length === 0) {
    return "";
  }
  const d = points.reduce((acc, point, i, a) => i === 0 ? (
    // if first point
    `M ${point[0]},${point[1]}`
  ) : (
    // else
    `${acc} ${command(point, i, a)}`
  ), "");
  return d;
};
var ColorPickerLocalizationService = class _ColorPickerLocalizationService extends LocalizationService {
  constructor(prefix, messageService, _rtl) {
    super(prefix, messageService, _rtl);
  }
  static ɵfac = function ColorPickerLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPickerLocalizationService,
    factory: _ColorPickerLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }];
  }, null);
})();
var FlatColorPickerLocalizationService = class _FlatColorPickerLocalizationService extends LocalizationService {
  colorPickerLocalization;
  constructor(prefix, messageService, _rtl, colorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.colorPickerLocalization = colorPickerLocalization;
  }
  get(shortKey) {
    if (this.colorPickerLocalization) {
      return this.colorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function FlatColorPickerLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(ColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FlatColorPickerLocalizationService,
    factory: _FlatColorPickerLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: ColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var ColorGradientLocalizationService = class _ColorGradientLocalizationService extends LocalizationService {
  flatColorPickerLocalization;
  constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.flatColorPickerLocalization = flatColorPickerLocalization;
  }
  get(shortKey) {
    if (this.flatColorPickerLocalization) {
      return this.flatColorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function ColorGradientLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorGradientLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(FlatColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorGradientLocalizationService,
    factory: _ColorGradientLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorGradientLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: FlatColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FlatColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var NumericLabelDirective = class _NumericLabelDirective {
  host;
  kendoAdditionalNumericLabel;
  localizationService;
  constructor(host) {
    this.host = host;
  }
  ngOnInit() {
    const localizationToken = `${this.kendoAdditionalNumericLabel}ChannelLabel`;
    this.host.numericInput.nativeElement.setAttribute("aria-label", this.localizationService.get(localizationToken));
  }
  static ɵfac = function NumericLabelDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericLabelDirective)(ɵɵdirectiveInject(NumericTextBoxComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NumericLabelDirective,
    selectors: [["", "kendoAdditionalNumericLabel", ""]],
    inputs: {
      kendoAdditionalNumericLabel: "kendoAdditionalNumericLabel",
      localizationService: "localizationService"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericLabelDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoAdditionalNumericLabel]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NumericTextBoxComponent
    }];
  }, {
    kendoAdditionalNumericLabel: [{
      type: Input
    }],
    localizationService: [{
      type: Input
    }]
  });
})();
var isJapanese = (input) => {
  const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
  return japaneseRegex.test(input);
};
var TextBoxSuffixTemplateDirective = class _TextBoxSuffixTemplateDirective {
  templateRef;
  /**
   * Determines whether a separator is shown before the suffix template.
   *
   * @default false
   */
  set showSeparator(value) {
    this._showSeparator = value;
  }
  get showSeparator() {
    return this._showSeparator;
  }
  _showSeparator = false;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TextBoxSuffixTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxSuffixTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxSuffixTemplateDirective,
    selectors: [["", "kendoTextBoxSuffixTemplate", ""]],
    inputs: {
      showSeparator: "showSeparator"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxSuffixTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextBoxSuffixTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSeparator: [{
      type: Input
    }]
  });
})();
var TextBoxPrefixTemplateDirective = class _TextBoxPrefixTemplateDirective {
  templateRef;
  /**
   * Determines whether a separator is shown after the prefix template.
   *
   * @default false
   */
  set showSeparator(value) {
    this._showSeparator = value;
  }
  get showSeparator() {
    return this._showSeparator;
  }
  _showSeparator = false;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TextBoxPrefixTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxPrefixTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxPrefixTemplateDirective,
    selectors: [["", "kendoTextBoxPrefixTemplate", ""]],
    inputs: {
      showSeparator: "showSeparator"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxPrefixTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextBoxPrefixTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    showSeparator: [{
      type: Input
    }]
  });
})();
var TextBoxMessages = class _TextBoxMessages extends ComponentMessages {
  /**
   * The title of the **Clear** button of the TextBox.
   */
  clear;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTextBoxMessages_BaseFactory;
    return function TextBoxMessages_Factory(__ngFactoryType__) {
      return (ɵTextBoxMessages_BaseFactory || (ɵTextBoxMessages_BaseFactory = ɵɵgetInheritedFactory(_TextBoxMessages)))(__ngFactoryType__ || _TextBoxMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TextBoxMessages,
    selectors: [["kendo-textbox-messages-base"]],
    inputs: {
      clear: "clear"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-textbox-messages-base"
    }]
  }], null, {
    clear: [{
      type: Input
    }]
  });
})();
var LocalizedTextBoxMessagesDirective = class _LocalizedTextBoxMessagesDirective extends TextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedTextBoxMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedTextBoxMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedTextBoxMessagesDirective,
    selectors: [["", "kendoTextBoxLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TextBoxMessages,
      useExisting: forwardRef(() => _LocalizedTextBoxMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedTextBoxMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TextBoxMessages,
        useExisting: forwardRef(() => LocalizedTextBoxMessagesDirective)
      }],
      selector: "[kendoTextBoxLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var FOCUSED$1 = "k-focus";
var DEFAULT_SIZE$9 = "medium";
var DEFAULT_ROUNDED$4 = "medium";
var DEFAULT_FILL_MODE$4 = "solid";
var iconsMap$1 = {
  checkIcon,
  exclamationCircleIcon,
  xIcon
};
var TextBoxComponent = class _TextBoxComponent {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the `title` attribute of the `input` element of the TextBox.
   */
  title;
  /**
   * Sets the `type` attribute of the `input` element of the TextBox.
   * @default 'text'
   */
  type = "text";
  /**
   * Sets the disabled state of the TextBox. To disable the component in reactive forms, see [Forms Support](slug:formssupport_textbox#toc-managing-the-textbox-disabled-state-in-reactive-forms).
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the component.
   * @default false
   */
  readonly = false;
  /**
   * Specifies the `tabindex` of the TextBox.
   * @default 0
   */
  tabindex = 0;
  /**
   * Provides a value for the TextBox.
   */
  value = null;
  /**
   * Highlights the whole value when you click the TextBox.
   * @default false
   */
  selectOnFocus = false;
  /**
   * Specifies when to show the Success icon ([see example]({% slug validation_textbox %})).
   *
   * @default false
   */
  showSuccessIcon = false;
  /**
   * Specifies when to show the Error icon ([see example]({% slug validation_textbox %})).
   *
   * @default false
   */
  showErrorIcon = false;
  /**
   * Shows a **Clear** button in the TextBox.
   * @default false
   */
  clearButton = false;
  /**
   * Sets a custom icon for valid user input.
   */
  successIcon;
  /**
   * Sets a custom SVG icon for valid user input.
   */
  successSvgIcon;
  /**
   * Sets a custom icon for invalid user input.
   */
  errorIcon;
  /**
   * Sets a custom SVG icon for invalid user input.
   */
  errorSvgIcon;
  /**
   * Sets a custom icon for the **Clear** button.
   */
  clearButtonIcon;
  /**
   * Sets a custom SVG icon for the **Clear** button.
   */
  clearButtonSvgIcon;
  /**
   * Sets the padding of the TextBox internal input element ([see example]({% slug appearance_textbox %}#toc-size)).
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$9;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the TextBox ([see example](slug:appearance_textbox#toc-roundness)).
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$4;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the background and border styles of the TextBox ([see example]({% slug appearance_textbox %}#toc-fill-mode)).
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$4;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the placeholder text displayed when the component is empty.
   */
  placeholder;
  /**
   * Sets the maximum length of the TextBox value.
   */
  maxlength;
  /**
   * Sets the HTML attributes of the inner focusable input element. You cannot change attributes that are essential for component functionality.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires when the value changes—when the component is blurred or the value is cleared through the **Clear** button ([see example](slug:events_textbox)).
   * Does not fire when you change the value programmatically through `ngModel` or `formControl`.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires when the `input` element is blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires when the user focuses the TextBox component.
   *
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the TextBox component is blurred.
   *
   */
  onBlur = new EventEmitter();
  /**
   * Gets a reference to the visible `input` element of the TextBox.
   */
  input;
  /**
   * @hidden
   */
  textBoxSuffixTemplate;
  /**
   * @hidden
   */
  textBoxPrefixTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  get disabledClass() {
    return this.disabled;
  }
  hostClasses = true;
  direction;
  /**
   * @hidden
   */
  showClearButton;
  /**
   * @hidden
   */
  clearButtonClicked;
  /**
   * @hidden
   */
  suffix;
  /**
   * @hidden
   */
  prefix;
  control;
  subscriptions;
  _isFocused = false;
  focusChangedProgrammatically = false;
  _inputAttributes;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.disabled ? void 0 : this.tabindex,
      type: this.type,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      "aria-invalid": this.isControlInvalid,
      required: this.isControlRequired ? "" : null
    };
  }
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
    this.checkClearButton();
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  ngAfterContentInit() {
    this.configureAdornments();
    this.subscriptions.add(this.textBoxPrefixTemplate.changes.subscribe(this.configureAdornments.bind(this)));
    this.subscriptions.add(this.textBoxSuffixTemplate.changes.subscribe(this.configureAdornments.bind(this)));
  }
  ngOnChanges(changes) {
    if (changes["disabled"] || changes["readonly"] || changes["value"]) {
      this.checkClearButton();
    }
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  svgIcon(name) {
    return iconsMap$1[name];
  }
  /**
   * Focuses the TextBox.
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Removes focus from the TextBox.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.disabled) {
      if (this.selectOnFocus && this.value) {
        this.ngZone.run(() => {
          setTimeout(() => {
            this.selectAll();
          });
        });
      }
      if (!this.isFocused) {
        this.handleFocus();
      }
      if (hasObservers(this.inputFocus)) {
        if (!this.focusChangedProgrammatically || this.focusChangedProgrammatically && this.clearButtonClicked) {
          this.ngZone.run(() => {
            this.inputFocus.emit();
          });
        }
      }
    }
  };
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   */
  handleInput = (ev) => {
    const target = ev.target;
    const isBrowserSafari = isSafari(navigator.userAgent);
    const incomingValue = isBrowserSafari && isJapanese(target.value) ? ev.data : target.value;
    const [caretStart, caretEnd] = [target.selectionStart, target.selectionEnd];
    this.updateValue(incomingValue);
    if (isBrowserSafari) {
      target.setSelectionRange(caretStart, caretEnd);
    }
  };
  /**
   * @hidden
   */
  clearTitle() {
    return this.localizationService.get("clear");
  }
  /**
   * @hidden
   */
  checkClearButton() {
    this.showClearButton = !this.disabled && !this.readonly && this.clearButton && !!this.value;
  }
  /**
   * @hidden
   */
  clearValue(ev) {
    if (ev) {
      ev.preventDefault();
    }
    this.clearButtonClicked = true;
    this.input.nativeElement.value = "";
    this.input.nativeElement.focus();
    this.updateValue("");
    this.checkClearButton();
    this.clearButtonClicked = false;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.checkClearButton();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  showErrorsInitial() {
    if (!this.control) {
      return false;
    }
    const {
      invalid,
      dirty,
      touched
    } = this.control;
    return invalid && (dirty || touched);
  }
  /**
   * @hidden
   */
  showSuccessInitial() {
    if (!this.control) {
      return false;
    }
    const {
      valid,
      dirty,
      touched
    } = this.control;
    return valid && (dirty || touched);
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get successIconClasses() {
    if (!this.successIcon) {
      return `check`;
    }
  }
  /**
   * @hidden
   */
  get customSuccessIconClasses() {
    if (this.successIcon) {
      return this.successIcon;
    }
  }
  /**
   * @hidden
   */
  get errorIconClasses() {
    if (!this.errorIcon) {
      return `exclamation-circle`;
    }
  }
  /**
   * @hidden
   */
  get customIconClasses() {
    if (this.errorIcon) {
      return this.errorIcon;
    }
  }
  /**
   * @hidden
   */
  get customClearButtonClasses() {
    if (this.clearButtonIcon) {
      return this.clearButtonIcon;
    }
  }
  /**
   * @hidden
   */
  get clearButtonClass() {
    if (!this.clearButtonIcon) {
      return "x";
    }
  }
  /**
   * @hidden
   */
  get hasErrors() {
    return this.showErrorIcon === "initial" ? this.showErrorsInitial() : this.showErrorIcon;
  }
  /**
   * @hidden
   */
  get isSuccessful() {
    return this.showSuccessIcon === "initial" ? this.showSuccessInitial() : this.showSuccessIcon;
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED$1);
      } else {
        this.renderer.removeClass(element, FOCUSED$1);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  setSelection(start, end) {
    if (this.isFocused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  selectAll() {
    if (this.value) {
      this.setSelection(0, this.value.length);
    }
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.checkClearButton();
        this.changeDetector.markForCheck();
      });
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  configureAdornments() {
    this.prefix = this.textBoxPrefixTemplate.first || this.prefixTemplate;
    this.suffix = this.textBoxSuffixTemplate.first || this.suffixTemplate;
  }
  setInputAttributes() {
    setHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function TextBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextBoxComponent,
    selectors: [["kendo-textbox"]],
    contentQueries: function TextBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TextBoxSuffixTemplateDirective, 4);
        ɵɵcontentQuery(dirIndex, TextBoxPrefixTemplateDirective, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textBoxSuffixTemplate = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textBoxPrefixTemplate = _t);
      }
    },
    viewQuery: function TextBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c17, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 9,
    hostBindings: function TextBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disabledClass)("k-textbox", ctx.hostClasses)("k-input", ctx.hostClasses);
      }
    },
    inputs: {
      focusableId: "focusableId",
      title: "title",
      type: "type",
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      value: "value",
      selectOnFocus: "selectOnFocus",
      showSuccessIcon: "showSuccessIcon",
      showErrorIcon: "showErrorIcon",
      clearButton: "clearButton",
      successIcon: "successIcon",
      successSvgIcon: "successSvgIcon",
      errorIcon: "errorIcon",
      errorSvgIcon: "errorSvgIcon",
      clearButtonIcon: "clearButtonIcon",
      clearButtonSvgIcon: "clearButtonSvgIcon",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      tabIndex: "tabIndex",
      placeholder: "placeholder",
      maxlength: "maxlength",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoTextBox"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.textbox"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextBoxComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextBoxComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 12,
    vars: 26,
    consts: () => {
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_9 = goog.getMsg("Clear");
        i18n_9 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.textbox.clear|The title for the **Clear** button in the TextBox.:Clear`;
      }
      return [["input", ""], ["kendoTextBoxLocalizedMessages", "", "clear", i18n_9], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused", "clearButtonClicked"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], [1, "k-input-inner", 3, "id", "disabled", "readonly", "value", "kendoEventsOutsideAngular"], ["role", "button", "class", "k-clear-value", 3, "tabindex", "title", "click", "mousedown", "keydown.enter", "keydown.space", 4, "ngIf"], ["innerCssClass", "k-input-validation-icon", 3, "name", "customFontClass", "svgIcon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", 1, "k-clear-value", 3, "click", "mousedown", "keydown.enter", "keydown.space", "tabindex", "title"], [3, "name", "customFontClass", "svgIcon"], ["innerCssClass", "k-input-validation-icon", 3, "name", "customFontClass", "svgIcon"], [1, "k-input-suffix", "k-input-suffix-horizontal"]];
    },
    template: function TextBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 1);
        ɵɵelementContainerStart(1, 2);
        ɵɵtwoWayListener("isFocusedChange", function TextBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function TextBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function TextBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, TextBoxComponent_span_2_Template, 2, 1, "span", 3)(3, TextBoxComponent_kendo_input_separator_3_Template, 1, 0, "kendo-input-separator", 4);
        ɵɵelement(4, "input", 5, 0);
        ɵɵtemplate(6, TextBoxComponent_span_6_Template, 2, 6, "span", 6)(7, TextBoxComponent_kendo_icon_wrapper_7_Template, 1, 3, "kendo-icon-wrapper", 7)(8, TextBoxComponent_kendo_icon_wrapper_8_Template, 1, 3, "kendo-icon-wrapper", 7)(9, TextBoxComponent_kendo_input_separator_9_Template, 1, 0, "kendo-input-separator", 4)(10, TextBoxComponent_span_10_Template, 2, 1, "span", 8);
        ɵɵelementContainer(11);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵproperty("clearButtonClicked", ctx.clearButtonClicked);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefix);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefix && ctx.prefix.showSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("readonly", ctx.readonly)("value", ctx.value)("kendoEventsOutsideAngular", ɵɵpureFunction3(22, _c20, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵɵattribute("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("type", ctx.type)("placeholder", ctx.placeholder)("title", ctx.title)("maxlength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showClearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasErrors);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isSuccessful);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffix && ctx.suffix.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffix);
      }
    },
    dependencies: [LocalizedTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextBox",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.textbox"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextBoxComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextBoxComponent)
      }],
      selector: "kendo-textbox",
      template: `
        <ng-container kendoTextBoxLocalizedMessages
            i18n-clear="kendo.textbox.clear|The title for the **Clear** button in the TextBox."
            clear="Clear">
        </ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
            [clearButtonClicked]="clearButtonClicked"
        >
            <span *ngIf="prefix" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefix?.templateRef">
                </ng-template>
            </span>
            <kendo-input-separator *ngIf="prefix && prefix.showSeparator"></kendo-input-separator>
            <input #input
                class="k-input-inner"
                [id]="focusableId"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [attr.type]="type"
                [attr.placeholder]="placeholder"
                [attr.title]="title"
                [attr.maxlength]="maxlength"
                [attr.aria-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    input: handleInput}"
            />
            <span
                role="button"
                class="k-clear-value"
                *ngIf="showClearButton"
                (click)="clearValue()"
                (mousedown)="$event.preventDefault()"
                [tabindex]="tabIndex"
                [attr.aria-label]="clearTitle()"
                [title]="clearTitle()"
                (keydown.enter)="clearValue($event)"
                (keydown.space)="clearValue($event)">
                    <kendo-icon-wrapper
                        [name]="clearButtonClass"
                        [customFontClass]="customClearButtonClasses"
                        [svgIcon]="clearButtonSvgIcon || svgIcon('xIcon')"
                    >
                    </kendo-icon-wrapper>
            </span>
            <kendo-icon-wrapper
                *ngIf="hasErrors"
                innerCssClass="k-input-validation-icon"
                [name]="errorIconClasses"
                [customFontClass]="customIconClasses"
                [svgIcon]="errorSvgIcon || svgIcon('exclamationCircleIcon')"
            >
            </kendo-icon-wrapper>
            <kendo-icon-wrapper
                *ngIf="isSuccessful"
                innerCssClass="k-input-validation-icon"
                [name]="successIconClasses"
                [customFontClass]="customSuccessIconClasses"
                [svgIcon]="successSvgIcon || svgIcon('checkIcon')"
            >
            </kendo-icon-wrapper>
            <kendo-input-separator *ngIf="suffix && suffix.showSeparator"></kendo-input-separator>
            <span *ngIf="suffix" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffix?.templateRef">
                </ng-template>
            </span>
        <ng-container>
    `,
      standalone: true,
      imports: [LocalizedTextBoxMessagesDirective, SharedInputEventsDirective, NgIf, NgTemplateOutlet, InputSeparatorComponent, EventsOutsideAngularDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    showSuccessIcon: [{
      type: Input
    }],
    showErrorIcon: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    successIcon: [{
      type: Input
    }],
    successSvgIcon: [{
      type: Input
    }],
    errorIcon: [{
      type: Input
    }],
    errorSvgIcon: [{
      type: Input
    }],
    clearButtonIcon: [{
      type: Input
    }],
    clearButtonSvgIcon: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    textBoxSuffixTemplate: [{
      type: ContentChildren,
      args: [TextBoxSuffixTemplateDirective, {
        descendants: false
      }]
    }],
    textBoxPrefixTemplate: [{
      type: ContentChildren,
      args: [TextBoxPrefixTemplateDirective, {
        descendants: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textbox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var TextLabelDirective = class _TextLabelDirective {
  textBox;
  renderer;
  focusableId;
  constructor(textBox, renderer) {
    this.textBox = textBox;
    this.renderer = renderer;
  }
  ngOnInit() {
    this.renderer.setAttribute(this.textBox.input.nativeElement, "id", this.focusableId);
  }
  static ɵfac = function TextLabelDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextLabelDirective)(ɵɵdirectiveInject(TextBoxComponent), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TextLabelDirective,
    selectors: [["", "kendoTextLabel", ""]],
    inputs: {
      focusableId: "focusableId"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextLabelDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTextLabel]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TextBoxComponent
    }, {
      type: Renderer2
    }];
  }, {
    focusableId: [{
      type: Input
    }]
  });
})();
var DEFAULT_SIZE$8 = "medium";
var ColorInputComponent = class _ColorInputComponent {
  host;
  renderer;
  cdr;
  localizationService;
  /**
   * Sets the `id` of the hex input.
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the color format view.
   */
  formatView;
  /**
   * Sets the size of the ColorInput.
   *
   * @default 'medium'
   */
  size = DEFAULT_SIZE$8;
  /**
   * Sets the `tabindex` of the inputs.
   * @default -1
   */
  tabindex = -1;
  /**
   * Sets the color value to parse and populate the hex and RGBA inputs.
   */
  value;
  /**
   * Shows or hides the alpha slider.
   *
   * @default true
   */
  opacity = true;
  /**
   * Disables the ColorInput.
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorInput.
   *
   * @default false
   */
  readonly = false;
  /**
   * Emits a parsed RGBA string color.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the user tabs out of the last focusable input.
   */
  tabOut = new EventEmitter();
  colorInputClass = true;
  opacityInput;
  hexInput;
  blueInput;
  toggleFormatButton;
  /**
   * Holds the RGBA input values.
   */
  rgba = {};
  /*
   * Holds the hex input value.
   */
  hex;
  /**
   * Returns `true` if any of the inputs are focused.
   */
  get isFocused() {
    if (!(isDocumentAvailable() && isPresent3(this.host))) {
      return false;
    }
    const activeElement = document.activeElement;
    return this.host.nativeElement.contains(activeElement);
  }
  /**
   * Returns `true` if all RGBA inputs have values.
   */
  get rgbaInputValid() {
    return Object.keys(this.rgba).every((key) => isPresent3(this.rgba[key]));
  }
  /**
   * @hidden
   */
  caretAltExpandIcon = caretAltExpandIcon;
  subscriptions = new Subscription();
  constructor(host, renderer, cdr, localizationService) {
    this.host = host;
    this.renderer = renderer;
    this.cdr = cdr;
    this.localizationService = localizationService;
  }
  ngAfterViewInit() {
    this.initDomEvents();
  }
  ngOnDestroy() {
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
    }
  }
  ngOnChanges(changes) {
    if (isPresent3(changes["value"]) && !this.isFocused) {
      this.hex = parseColor2(this.value, "hex", this.opacity);
      this.rgba = getRGBA(this.value);
      this.rgba.a = parseColor2(this.value, "rgba", this.opacity) ? this.rgba.a : 1;
    }
  }
  get formatButtonTitle() {
    return this.localizationService.get("formatButton");
  }
  handleRgbaValueChange() {
    const color = getColorFromRGBA(this.rgba);
    if (!this.rgbaInputValid || color === this.value) {
      return;
    }
    this.value = color;
    this.rgba = getRGBA(this.value);
    this.hex = parseColor2(color, "hex", this.opacity);
    this.valueChange.emit(color);
  }
  focusDragHandle(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    this.tabOut.emit();
  }
  handleHexValueChange(hex) {
    this.hex = hex;
    const color = parseColor2(hex, "rgba", this.opacity);
    if (!isPresent3(color) || color === this.value) {
      return;
    }
    this.value = color;
    this.rgba = getRGBA(color);
    this.valueChange.emit(color);
  }
  handleRgbaInputBlur() {
    if (!this.rgbaInputValid) {
      this.rgba = getRGBA(this.value);
    }
  }
  handleHexInputBlur() {
    this.hex = parseColor2(this.value, "hex", this.opacity);
  }
  focusLast() {
    this.lastInput().focus();
  }
  onTab() {
    if (this.opacity) {
      return;
    }
  }
  toggleFormatView() {
    this.formatView = this.formatView === "hex" ? "rgba" : "hex";
    this.cdr.markForCheck();
  }
  initDomEvents() {
    if (!this.host) {
      return;
    }
    this.subscriptions.add(this.renderer.listen(this.toggleFormatButton.nativeElement, "click", () => this.toggleFormatView()));
  }
  lastInput() {
    return this.hexInput?.nativeElement || this.opacityInput || this.blueInput;
  }
  static ɵfac = function ColorInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorInputComponent,
    selectors: [["kendo-colorinput"]],
    viewQuery: function ColorInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c21, 5);
        ɵɵviewQuery(_c22, 5);
        ɵɵviewQuery(_c23, 5);
        ɵɵviewQuery(_c24, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.opacityInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hexInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.blueInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.toggleFormatButton = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function ColorInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-colorgradient-inputs", ctx.colorInputClass)("k-hstack", ctx.colorInputClass);
      }
    },
    inputs: {
      focusableId: "focusableId",
      formatView: "formatView",
      size: "size",
      tabindex: "tabindex",
      value: "value",
      opacity: "opacity",
      disabled: "disabled",
      readonly: "readonly"
    },
    outputs: {
      valueChange: "valueChange",
      tabOut: "tabOut"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 8,
    consts: [["toggleFormatButton", ""], ["hexInput", ""], ["red", ""], ["green", ""], ["blue", ""], ["opacityInput", "", "alpha", ""], [1, "k-vstack"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "caret-alt-expand", 1, "k-colorgradient-toggle-mode", 3, "svgIcon", "size", "disabled", "tabindex"], ["class", "k-vstack k-flex-1", 4, "ngIf"], [4, "ngIf"], [1, "k-vstack", "k-flex-1"], ["kendoTextLabel", "", 1, "k-hex-value", 3, "blur", "input", "keydown.tab", "focusableId", "size", "disabled", "readonly", "value", "tabindex"], [1, "k-colorgradient-input-label", 3, "for"], ["kendoAdditionalNumericLabel", "red", 3, "valueChange", "blur", "localizationService", "disabled", "size", "readonly", "tabindex", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["kendoAdditionalNumericLabel", "green", 3, "valueChange", "blur", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["kendoAdditionalNumericLabel", "blue", 3, "valueChange", "blur", "keydown.tab", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "format", "decimals"], ["class", "k-vstack", 4, "ngIf"], ["kendoAdditionalNumericLabel", "alpha", 3, "valueChange", "blur", "keydown.tab", "localizationService", "disabled", "readonly", "tabindex", "size", "min", "max", "value", "autoCorrect", "spinners", "step", "format", "decimals"]],
    template: function ColorInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 6);
        ɵɵelement(1, "button", 7, 0);
        ɵɵelementEnd();
        ɵɵtemplate(3, ColorInputComponent_div_3_Template, 5, 9, "div", 8)(4, ColorInputComponent_ng_container_4_Template, 17, 40, "ng-container", 9);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("svgIcon", ctx.caretAltExpandIcon)("size", ctx.size)("disabled", ctx.disabled)("tabindex", ctx.tabindex.toString());
        ɵɵattribute("aria-label", ctx.formatButtonTitle)("title", ctx.formatButtonTitle);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.formatView === "hex");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.formatView === "rgba");
      }
    },
    dependencies: [ButtonComponent, NgIf, NumericTextBoxComponent, NumericLabelDirective, TextBoxComponent, TextLabelDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorInputComponent, [{
    type: Component,
    args: [{
      selector: "kendo-colorinput",
      template: `
        <div class="k-vstack">
            <button
                kendoButton
                type="button"
                fillMode="flat"
                #toggleFormatButton
                icon="caret-alt-expand"
                [svgIcon]="caretAltExpandIcon"
                [size]="size"
                class="k-colorgradient-toggle-mode"
                [attr.aria-label]="formatButtonTitle"
                [attr.title]="formatButtonTitle"
                [disabled]="disabled"
                [tabindex]="tabindex.toString()"
            >
            </button>
        </div>
        <div *ngIf="formatView === 'hex'" class="k-vstack k-flex-1">
            <kendo-textbox
                #hexInput
                kendoTextLabel
                [focusableId]="focusableId"
                class="k-hex-value"
                [size]="size"
                [class.k-readonly]="readonly"
                [disabled]="disabled"
                [readonly]="readonly"
                [value]="hex || ''"
                (blur)="handleHexInputBlur()"
                (input)="handleHexValueChange(hexInput.value)"
                [tabindex]="tabindex"
                (keydown.tab)="focusDragHandle($event)">
            </kendo-textbox>
            <label [for]="focusableId" class="k-colorgradient-input-label">HEX</label>
        </div>
        <ng-container *ngIf="formatView === 'rgba'">
            <div class="k-vstack">
                <kendo-numerictextbox
                    #red
                    kendoAdditionalNumericLabel="red"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [size]="size"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.r"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="red.focusableId" class="k-colorgradient-input-label">R</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #green
                    kendoAdditionalNumericLabel="green"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.g"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()">
                </kendo-numerictextbox>
                <label [for]="green.focusableId" class="k-colorgradient-input-label">G</label>
            </div>
            <div class="k-vstack">
                <kendo-numerictextbox
                    #blue
                    kendoAdditionalNumericLabel="blue"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="255"
                    [(value)]="rgba.b"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [format]="'n'"
                    [decimals]="0"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()"
                    (keydown.tab)="onTab()">
                </kendo-numerictextbox>
                <label [for]="blue.focusableId" class="k-colorgradient-input-label">B</label>
            </div>
            <div class="k-vstack" *ngIf="opacity">
                <kendo-numerictextbox #opacityInput
                    #alpha
                    kendoAdditionalNumericLabel="alpha"
                    [localizationService]="localizationService"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [tabindex]="tabindex"
                    [size]="size"
                    [min]="0"
                    [max]="1"
                    [(value)]="rgba.a"
                    [autoCorrect]="true"
                    [spinners]="false"
                    [step]="0.01"
                    [format]="'n2'"
                    [decimals]="2"
                    (blur)="handleRgbaInputBlur()"
                    (valueChange)="handleRgbaValueChange()"
                    (keydown.tab)="focusDragHandle($event)">
                </kendo-numerictextbox>
                <label [for]="alpha.focusableId" class="k-colorgradient-input-label">A</label>
            </div>
        </ng-container>
    `,
      standalone: true,
      imports: [ButtonComponent, NgIf, NumericTextBoxComponent, NumericLabelDirective, TextBoxComponent, TextLabelDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    formatView: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    colorInputClass: [{
      type: HostBinding,
      args: ["class.k-colorgradient-inputs"]
    }, {
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    opacityInput: [{
      type: ViewChild,
      args: ["opacityInput"]
    }],
    hexInput: [{
      type: ViewChild,
      args: ["hexInput"]
    }],
    blueInput: [{
      type: ViewChild,
      args: ["blue"]
    }],
    toggleFormatButton: [{
      type: ViewChild,
      args: ["toggleFormatButton", {
        static: false,
        read: ElementRef
      }]
    }]
  });
})();
var DEFAULT_OUTPUT_FORMAT = "rgba";
var DEFAULT_GRADIENT_BACKGROUND_COLOR = "rgba(255, 0, 0, 1)";
var DRAGHANDLE_MOVE_SPEED = 5;
var DRAGHANDLE_MOVE_SPEED_SMALL_STEP = 2;
var AAA_RATIO = 7;
var AA_RATIO = 4.5;
var DEFAULT_PRESET$1 = "office";
var DEFAULT_ACCESSIBLE_PRESET$1 = "accessible";
var STEP_COUNT = 16;
var ContrastValidationComponent = class _ContrastValidationComponent {
  localization;
  type;
  pass;
  value;
  checkIcon = checkIcon;
  xCircleIcon = xCircleIcon;
  constructor(localization) {
    this.localization = localization;
  }
  get passMessage() {
    return this.localization.get("passContrast");
  }
  get failMessage() {
    return this.localization.get("failContrast");
  }
  get contrastText() {
    const ratio = this.type === "AA" ? AA_RATIO : AAA_RATIO;
    return `${this.type}: ${ratio.toFixed(1)}`;
  }
  static ɵfac = function ContrastValidationComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContrastValidationComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContrastValidationComponent,
    selectors: [["", "kendoContrastValidation", ""]],
    inputs: {
      type: "type",
      pass: "pass",
      value: "value"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c25,
    decls: 3,
    vars: 2,
    consts: [[4, "ngIf"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], ["name", "check", 3, "svgIcon"], [1, "k-contrast-validation", "k-text-error"], ["name", "x", 3, "svgIcon"]],
    template: function ContrastValidationComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span");
        ɵɵtext(1);
        ɵɵelementEnd();
        ɵɵtemplate(2, ContrastValidationComponent_ng_container_2_Template, 3, 2, "ng-container", 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵtextInterpolate(ctx.contrastText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value);
      }
    },
    dependencies: [NgIf, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContrastValidationComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoContrastValidation]",
      template: `
        <span>{{contrastText}}</span>
        <ng-container *ngIf="value">
            <span class="k-contrast-validation k-text-success" *ngIf="pass">
                {{passMessage}}
                <kendo-icon-wrapper name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
            </span>
            <span class="k-contrast-validation k-text-error" *ngIf="!pass">
                {{failMessage}}
                <kendo-icon-wrapper name="x" [svgIcon]="xCircleIcon"></kendo-icon-wrapper>
            </span>
        </ng-container>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    type: [{
      type: Input
    }],
    pass: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var ContrastComponent = class _ContrastComponent {
  localization;
  value;
  ratio;
  checkIcon = checkIcon;
  xCircleIcon = xCircleIcon;
  constructor(localization) {
    this.localization = localization;
  }
  get formatedRatio() {
    return this.contrastRatio.toFixed(2);
  }
  get contrastRatioText() {
    return `${this.localization.get("contrastRatio")}: ${this.value ? this.formatedRatio : "n/a"}`;
  }
  get satisfiesAACondition() {
    return this.contrastRatio >= AA_RATIO;
  }
  get satisfiesAAACondition() {
    return this.contrastRatio >= AAA_RATIO;
  }
  get contrastRatio() {
    const contrast = getContrastFromTwoRGBAs(getRGBA(this.value), getRGBA(this.ratio));
    return contrast;
  }
  static ɵfac = function ContrastComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContrastComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ContrastComponent,
    selectors: [["", "kendoContrastTool", ""]],
    inputs: {
      value: "value",
      ratio: "ratio"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c26,
    decls: 6,
    vars: 6,
    consts: [[1, "k-contrast-ratio"], [1, "k-contrast-ratio-text"], [4, "ngIf"], ["kendoContrastValidation", "", "type", "AA", 3, "value", "pass"], ["kendoContrastValidation", "", "type", "AAA", 3, "value", "pass"], ["class", "k-contrast-validation k-text-success", 4, "ngIf"], ["class", "k-contrast-validation k-text-error", 4, "ngIf"], [1, "k-contrast-validation", "k-text-success"], ["name", "check", 3, "svgIcon"], ["name", "check", 3, "svgIcon", 4, "ngIf"], [1, "k-contrast-validation", "k-text-error"], ["name", "x", 3, "svgIcon"]],
    template: function ContrastComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "span", 1);
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵtemplate(3, ContrastComponent_ng_container_3_Template, 3, 2, "ng-container", 2);
        ɵɵelementEnd();
        ɵɵelement(4, "div", 3)(5, "div", 4);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.contrastRatioText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.value);
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAACondition);
        ɵɵadvance();
        ɵɵproperty("value", ctx.value)("pass", ctx.satisfiesAAACondition);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, ContrastValidationComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContrastComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoContrastTool]",
      template: `
        <div class="k-contrast-ratio">
            <span class="k-contrast-ratio-text">{{contrastRatioText}}</span>
            <ng-container *ngIf="value">
                <span class="k-contrast-validation k-text-success" *ngIf="satisfiesAACondition">
                    <kendo-icon-wrapper name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
                    <kendo-icon-wrapper *ngIf="satisfiesAAACondition" name="check" [svgIcon]="checkIcon"></kendo-icon-wrapper>
                </span>
                <span class="k-contrast-validation k-text-error" *ngIf="!satisfiesAACondition">
                    <kendo-icon-wrapper name="x" [svgIcon]="xCircleIcon"></kendo-icon-wrapper>
                </span>
            </ng-container>
        </div>
        <div kendoContrastValidation
            type="AA"
            [value]="value"
            [pass]="satisfiesAACondition">
        </div>
        <div kendoContrastValidation
            type="AAA"
            [value]="value"
            [pass]="satisfiesAAACondition">
        </div>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, ContrastValidationComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    value: [{
      type: Input
    }],
    ratio: [{
      type: Input
    }]
  });
})();
var ColorContrastSvgComponent = class _ColorContrastSvgComponent {
  hostClass = true;
  wrapper;
  hsva;
  backgroundColor;
  paths;
  oldHsva;
  oldH;
  oldA;
  metrics;
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.metrics = this.wrapper.getBoundingClientRect();
    this.oldA = this.hsva.value.a;
    this.oldH = this.hsva.value.h;
    this.hsva.subscribe((value) => {
      if (value.h !== this.oldH || value.a !== this.oldA) {
        this.oldH = value.h;
        this.oldA = value.a;
        this.setPaths();
      }
    });
  }
  ngOnChanges(changes) {
    if (isPresent3(changes["backgroundColor"]) && this.metrics) {
      this.setPaths();
    }
  }
  setPaths() {
    const bezierCommandCalc = bezierCommand(controlPoint(line));
    this.paths = [svgPath(this.getPaths(AA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AA_RATIO, STEP_COUNT, true), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT), bezierCommandCalc), svgPath(this.getPaths(AAA_RATIO, STEP_COUNT, true), bezierCommandCalc)];
  }
  findValue(contrast, saturation, low, high, comparer) {
    const mid = (low + high) / 2;
    const hsva = __spreadProps(__spreadValues({}, this.hsva.value), {
      s: saturation / this.metrics.width,
      v: 1 - mid / this.metrics.height
    });
    const currentContrast = getContrastFromTwoRGBAs(getRGBA(getColorFromHSV(hsva)), getRGBA(this.backgroundColor || ""));
    if (low + 0.5 > high) {
      if (currentContrast < contrast + 1 && currentContrast > contrast - 1) {
        return mid;
      } else {
        return null;
      }
    }
    if (comparer(currentContrast, contrast)) {
      return this.findValue(contrast, saturation, low, high - (high - low) / 2, comparer);
    }
    return this.findValue(contrast, saturation, low + (high - low) / 2, high, comparer);
  }
  getPaths(contrast, stepCount, reversed = false) {
    const points = [];
    for (let i = 0; i <= this.metrics.width; i += this.metrics.width / stepCount) {
      const value = this.findValue(contrast, i, 0, this.metrics.height, reversed ? (a, b) => a < b : (a, b) => a > b);
      if (value !== null) {
        points.push([i, value]);
      }
    }
    return points;
  }
  static ɵfac = function ColorContrastSvgComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorContrastSvgComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorContrastSvgComponent,
    selectors: [["", "kendoColorContrastSvg", ""]],
    hostVars: 2,
    hostBindings: function ColorContrastSvgComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-color-contrast-svg", ctx.hostClass);
      }
    },
    inputs: {
      wrapper: "wrapper",
      hsva: "hsva",
      backgroundColor: "backgroundColor"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c27,
    decls: 1,
    vars: 1,
    consts: [["fill", "none", "stroke", "white", "stroke-width", "1", 4, "ngFor", "ngForOf"], ["fill", "none", "stroke", "white", "stroke-width", "1"]],
    template: function ColorContrastSvgComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, ColorContrastSvgComponent__svg_path_0_Template, 1, 1, "path", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.paths);
      }
    },
    dependencies: [NgForOf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorContrastSvgComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoColorContrastSvg]",
      template: `
        <svg:path *ngFor="let path of paths" [attr.d]="path" fill="none" stroke="white" stroke-width="1"></svg:path>
    `,
      standalone: true,
      imports: [NgForOf]
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-color-contrast-svg"]
    }],
    wrapper: [{
      type: Input
    }],
    hsva: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }]
  });
})();
var ColorPickerMessages = class _ColorPickerMessages extends ComponentMessages {
  /**
   * Sets the `aria-label` for the ColorPalette component when the value is empty.
   */
  colorPaletteNoColor;
  /**
   * Sets the `aria-label` for the ColorGradient component when the value is empty.
   */
  colorGradientNoColor;
  /**
   * Sets the `aria-label` for the FlatColorPicker component when the value is empty.
   */
  flatColorPickerNoColor;
  /**
   * Sets the `aria-label` for the ColorPicker component when the value is empty.
   */
  colorPickerNoColor;
  /**
   * Sets the title for the gradient color drag handle chooser.
   */
  colorGradientHandle;
  /**
   * Sets the title for the clear button.
   */
  clearButton;
  /**
   * Sets the title for the hue slider handle.
   */
  hueSliderHandle;
  /**
   * Sets the title for the opacity slider handle.
   */
  opacitySliderHandle;
  /**
   * Sets the placeholder for the HEX color input.
   */
  hexInputPlaceholder;
  /**
   * Sets the placeholder for the red color input.
   */
  redInputPlaceholder;
  /**
   * Sets the placeholder for the green color input.
   */
  greenInputPlaceholder;
  /**
   * Sets the placeholder for the blue color input.
   */
  blueInputPlaceholder;
  /**
   * Sets the placeholder for the alpha input.
   */
  alphaInputPlaceholder;
  /**
   * Sets the `aria-label` for the red color input.
   */
  redChannelLabel;
  /**
   * Sets the `aria-label` for the green color input.
   */
  greenChannelLabel;
  /**
   * Sets the `aria-label` for the blue color input.
   */
  blueChannelLabel;
  /**
   * Sets the `aria-label` for the alpha color input.
   */
  alphaChannelLabel;
  /**
   * Sets the "Pass" message for the contrast tool.
   */
  passContrast;
  /**
   * Sets the "Fail" message for the contrast tool.
   */
  failContrast;
  /**
   * Sets the "Contrast ratio" message for the contrast tool.
   */
  contrastRatio;
  /**
   * Sets the message for the color preview pane.
   */
  previewColor;
  /**
   * Sets the message for the selected color pane.
   */
  revertSelection;
  /**
   * Sets the message for the gradient view button.
   */
  gradientView;
  /**
   * Sets the message for the palette view button.
   */
  paletteView;
  /**
   * Sets the message for the input format toggle button.
   */
  formatButton;
  /**
   * Sets the message for the **Apply** action button.
   */
  applyButton;
  /**
   * Sets the message for the **Cancel** action button.
   */
  cancelButton;
  /**
   * Sets the title of the **Close** button for the ActionSheet in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  /**
   * Sets the title for the ActionSheet in adaptive mode.
   */
  adaptiveTitle;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵColorPickerMessages_BaseFactory;
    return function ColorPickerMessages_Factory(__ngFactoryType__) {
      return (ɵColorPickerMessages_BaseFactory || (ɵColorPickerMessages_BaseFactory = ɵɵgetInheritedFactory(_ColorPickerMessages)))(__ngFactoryType__ || _ColorPickerMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _ColorPickerMessages,
    selectors: [["kendo-colorpicker-messages-base"]],
    inputs: {
      colorPaletteNoColor: "colorPaletteNoColor",
      colorGradientNoColor: "colorGradientNoColor",
      flatColorPickerNoColor: "flatColorPickerNoColor",
      colorPickerNoColor: "colorPickerNoColor",
      colorGradientHandle: "colorGradientHandle",
      clearButton: "clearButton",
      hueSliderHandle: "hueSliderHandle",
      opacitySliderHandle: "opacitySliderHandle",
      hexInputPlaceholder: "hexInputPlaceholder",
      redInputPlaceholder: "redInputPlaceholder",
      greenInputPlaceholder: "greenInputPlaceholder",
      blueInputPlaceholder: "blueInputPlaceholder",
      alphaInputPlaceholder: "alphaInputPlaceholder",
      redChannelLabel: "redChannelLabel",
      greenChannelLabel: "greenChannelLabel",
      blueChannelLabel: "blueChannelLabel",
      alphaChannelLabel: "alphaChannelLabel",
      passContrast: "passContrast",
      failContrast: "failContrast",
      contrastRatio: "contrastRatio",
      previewColor: "previewColor",
      revertSelection: "revertSelection",
      gradientView: "gradientView",
      paletteView: "paletteView",
      formatButton: "formatButton",
      applyButton: "applyButton",
      cancelButton: "cancelButton",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle",
      adaptiveTitle: "adaptiveTitle"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-colorpicker-messages-base"
    }]
  }], null, {
    colorPaletteNoColor: [{
      type: Input
    }],
    colorGradientNoColor: [{
      type: Input
    }],
    flatColorPickerNoColor: [{
      type: Input
    }],
    colorPickerNoColor: [{
      type: Input
    }],
    colorGradientHandle: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    hueSliderHandle: [{
      type: Input
    }],
    opacitySliderHandle: [{
      type: Input
    }],
    hexInputPlaceholder: [{
      type: Input
    }],
    redInputPlaceholder: [{
      type: Input
    }],
    greenInputPlaceholder: [{
      type: Input
    }],
    blueInputPlaceholder: [{
      type: Input
    }],
    alphaInputPlaceholder: [{
      type: Input
    }],
    redChannelLabel: [{
      type: Input
    }],
    greenChannelLabel: [{
      type: Input
    }],
    blueChannelLabel: [{
      type: Input
    }],
    alphaChannelLabel: [{
      type: Input
    }],
    passContrast: [{
      type: Input
    }],
    failContrast: [{
      type: Input
    }],
    contrastRatio: [{
      type: Input
    }],
    previewColor: [{
      type: Input
    }],
    revertSelection: [{
      type: Input
    }],
    gradientView: [{
      type: Input
    }],
    paletteView: [{
      type: Input
    }],
    formatButton: [{
      type: Input
    }],
    applyButton: [{
      type: Input
    }],
    cancelButton: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }]
  });
})();
var LocalizedColorPickerMessagesDirective = class _LocalizedColorPickerMessagesDirective extends ColorPickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedColorPickerMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedColorPickerMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedColorPickerMessagesDirective,
    selectors: [["", "kendoColorPickerLocalizedMessages", ""], ["", "kendoFlatColorPickerLocalizedMessages", ""], ["", "kendoColorGradientLocalizedMessages", ""], ["", "kendoColorPaletteLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColorPickerMessages,
      useExisting: forwardRef(() => _LocalizedColorPickerMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedColorPickerMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: ColorPickerMessages,
        useExisting: forwardRef(() => LocalizedColorPickerMessagesDirective)
      }],
      selector: "[kendoColorPickerLocalizedMessages], [kendoFlatColorPickerLocalizedMessages], [kendoColorGradientLocalizedMessages], [kendoColorPaletteLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var serial$3 = 0;
var DEFAULT_SIZE$7 = "medium";
var ColorGradientComponent = class _ColorGradientComponent {
  host;
  ngZone;
  renderer;
  cdr;
  localizationService;
  injector;
  hostClasses = true;
  get readonlyAttribute() {
    return this.readonly;
  }
  get disabledClass() {
    return this.disabled;
  }
  get gradientId() {
    return this.id;
  }
  direction;
  get hostTabindex() {
    return this.tabindex?.toString() || "0";
  }
  ariaRole = "textbox";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  get isDisabled() {
    return this.disabled?.toString() || void 0;
  }
  /**
   * @hidden
   */
  enterHandler(event) {
    if (event.target !== this.host.nativeElement) {
      return;
    }
    this.internalNavigation = true;
    this.gradientDragHandle.nativeElement.focus();
  }
  /**
   * @hidden
   */
  escapeHandler(event) {
    if (!this.host.nativeElement.matches(":focus")) {
      event.stopImmediatePropagation();
    }
    this.internalNavigation = false;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    this.internalNavigation = ev.target !== this.host.nativeElement;
  }
  /**
   * @hidden
   */
  adaptiveMode = false;
  /**
   * @hidden
   */
  id = `k-colorgradient-${serial$3++}`;
  /**
   * Shows or hides the alpha slider.
   *
   * @default true
   */
  opacity = true;
  /**
   * Sets the size of the ColorGradient internal elements.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$7;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Disables the ColorGradient. To disable it in reactive forms, see [Forms Support](slug:formssupport_colorgradient#toc-managing-the-colorgradient-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorGradient.
   *
   * @default false
   */
  readonly = false;
  /**
   * Shows or hides the **Clear color** button.
   *
   * @default false
   */
  clearButton = false;
  /**
   * Sets the delay (in milliseconds) before the value changes on handle drag.
   *
   * @default 0
   */
  delay = 0;
  /**
   * Sets the value of the selected color.
   */
  set value(value) {
    this._value = parseColor2(value, this.format, this.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Enables the color contrast tool that checks the contrast ratio of the selected color against a predefined background color. [See example](slug:contrasttool_colorgradient).
   */
  set contrastTool(value) {
    this._contrastTool = parseColor2(value, this.format, this.opacity);
  }
  get contrastTool() {
    return this._contrastTool;
  }
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    if (isPresent3(value)) {
      const tabindex = Number(value);
      this._tabindex = !isNaN(tabindex) ? tabindex : 0;
    } else {
      this._tabindex = value;
    }
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Sets the output format of the ColorGradient. The input value may be in a different format, but it will be parsed into the output format after the component processes it.
   *
   * @default 'rgba'
   */
  format = DEFAULT_OUTPUT_FORMAT;
  /**
   * Fires when the user selects a new color..
   */
  valueChange = new EventEmitter();
  /**
   * @hidden
   */
  backgroundColor = DEFAULT_GRADIENT_BACKGROUND_COLOR;
  /**
   * @hidden
   *
   * Represents the currently selected `hue`, `saturation`, `value`, and `alpha` values.
   * The values are initially set in `ngOnInit` or in `ngOnChanges` and are
   * updated on moving the drag handle or the sliders.
   */
  hsva = new BehaviorSubject({});
  /**
   * Returns `true` if the component or its content is focused.
   */
  get isFocused() {
    if (!(isDocumentAvailable() && isPresent3(this.host))) {
      return false;
    }
    return this.host.nativeElement === document.activeElement || this.host.nativeElement.contains(document.activeElement);
  }
  /**
   * @hidden
   */
  get alphaSliderValue() {
    if (!(isPresent3(this.hsva.value) && isPresent3(this.hsva.value.a))) {
      return;
    }
    return this.hsva.value.a * 100;
  }
  /**
   * Sets the step (in pixels) for moving the gradient drag handle with the arrow keys.
   *
   * @default 5
   */
  gradientSliderStep = DRAGHANDLE_MOVE_SPEED;
  /**
   * Sets the step (in pixels) for moving the gradient drag handle with `Shift+arrow keys`.
   *
   * @default 2
   */
  gradientSliderSmallStep = DRAGHANDLE_MOVE_SPEED_SMALL_STEP;
  gradientDragHandle;
  inputs;
  alphaSlider;
  gradientWrapper;
  hsvRectangle;
  /**
   * @hidden
   */
  internalNavigation = false;
  /**
   * @hidden
   */
  dropletSlashIcon = dropletSlashIcon;
  _value;
  _tabindex = 0;
  _contrastTool;
  listeners = [];
  hueSliderTouched = false;
  alphaSliderTouched = false;
  _size = "medium";
  updateValues = new Subject();
  changeRequestsSubscription;
  dynamicRTLSubscription;
  hsvHandleCoordinates = {
    x: 0,
    y: 0
  };
  get gradientRect() {
    return this.gradientWrapper.nativeElement.getBoundingClientRect();
  }
  /**
   * @hidden
   */
  get hsvSliderValueText() {
    return `X: ${this.hsvHandleCoordinates.x} Y: ${this.hsvHandleCoordinates.y}`;
  }
  /**
   * @hidden
   */
  get contrastToolVisible() {
    return this.contrastTool && this.contrastTool.length > 0;
  }
  /**
   * @hidden
   */
  get innerTabIndex() {
    return this.internalNavigation ? 0 : -1;
  }
  control;
  constructor(host, ngZone, renderer, cdr, localizationService, injector) {
    this.host = host;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.localizationService = localizationService;
    this.injector = injector;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.updateUI();
      this.cdr.detectChanges();
    });
    this.addEventListeners();
    this.subscribeChanges();
  }
  ngOnChanges(changes) {
    if (isChanged("value", changes) && !this.isFocused) {
      this.updateUI();
    }
    if (isChanged("delay", changes)) {
      this.unsubscribeChanges();
      this.subscribeChanges();
    }
  }
  ngOnDestroy() {
    this.listeners.forEach((removeListener) => removeListener());
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.unsubscribeChanges();
  }
  /**
   * Focuses the component.
   */
  focus() {
    if (this.disabled) {
      return;
    }
    this.gradientDragHandle.nativeElement.focus();
  }
  /**
   * @hidden
   */
  reset() {
    this.handleValueChange(void 0);
    this.updateUI();
  }
  /**
   * @hidden
   */
  handleDragPress(args) {
    if (this.disabled || this.readonly || !isPresent3(args.originalEvent)) {
      return;
    }
    this.focus();
    args.originalEvent.preventDefault();
  }
  /**
   * @hidden
   */
  onHandleDrag(args) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.renderer.addClass(this.gradientWrapper.nativeElement, "k-dragging");
    this.changePosition(args);
  }
  /**
   * @hidden
   */
  onHandleRelease() {
    if (this.disabled || this.readonly) {
      return;
    }
    this.renderer.removeClass(this.gradientWrapper.nativeElement, "k-dragging");
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
  }
  /**
   * @hidden
   */
  onKeyboardAction(args) {
    if (this.disabled || this.readonly) {
      return;
    }
    if (args.key && args.key.indexOf("Arrow") !== -1) {
      args.preventDefault();
      const dragHandleElement = this.gradientDragHandle.nativeElement;
      this.renderer.addClass(this.gradientWrapper.nativeElement, "k-dragging");
      let keyboardMoveX = 0;
      let keyboardMoveY = 0;
      const shiftKey = args.shiftKey;
      switch (args.key) {
        case "ArrowRight":
          keyboardMoveX = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;
          break;
        case "ArrowLeft":
          keyboardMoveX = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;
          break;
        case "ArrowUp":
          keyboardMoveY = shiftKey ? -this.gradientSliderSmallStep : -this.gradientSliderStep;
          break;
        case "ArrowDown":
          keyboardMoveY = shiftKey ? this.gradientSliderSmallStep : this.gradientSliderStep;
          break;
        default:
          break;
      }
      const newY = parseInt(dragHandleElement.style.top, 10) + keyboardMoveY;
      const newX = parseInt(dragHandleElement.style.left, 10) + keyboardMoveX;
      this.renderer.setStyle(dragHandleElement, "top", `${newY}px`);
      this.renderer.setStyle(dragHandleElement, "left", `${newX}px`);
      this.ngZone.run(() => this.moveDragHandle(newX, newY));
    }
  }
  /**
   * @hidden
   */
  changePosition(position) {
    if (this.disabled || this.readonly) {
      return;
    }
    this.gradientDragHandle.nativeElement.focus();
    const gradientRect = this.gradientRect;
    const newX = position.clientX - gradientRect.left;
    const newY = position.clientY - gradientRect.top;
    this.ngZone.run(() => this.moveDragHandle(newX, newY));
  }
  /**
   * @hidden
   */
  handleHueSliderChange(hue) {
    const hsva = this.hsva.value;
    hsva.h = hue;
    this.hsva.next(hsva);
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.backgroundColor = getColorFromHue(hue);
    this.setBackgroundColor(this.backgroundColor);
    this.setAlphaSliderBackground(this.backgroundColor);
    this.hueSliderTouched = true;
  }
  /**
   * @hidden
   */
  handleAlphaSliderChange(alpha) {
    const hsva = this.hsva.value;
    hsva.a = alpha / 100;
    this.hsva.next(hsva);
    this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.alphaSliderTouched = true;
  }
  /**
   * @hidden
   */
  handleInputsValueChange(color) {
    const parsed = parseColor2(color, this.format, this.opacity);
    if (this.value !== parsed) {
      this.handleValueChange(parsed);
      this.updateUI();
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    if (isPresent3(this.gradientWrapper)) {
      this.updateUI();
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get colorGradientHandleTitle() {
    return this.localizationService.get("colorGradientHandle");
  }
  /**
   * @hidden
   */
  get colorGradientHandleAriaLabel() {
    const parsed = parseColor2(this.value, this.format, this.opacity);
    return `${this.value ? parsed : this.localizationService.get("colorGradientNoColor")}`;
  }
  /**
   * @hidden
   */
  get hueSliderTitle() {
    return this.localizationService.get("hueSliderHandle");
  }
  /**
   * @hidden
   */
  get opacitySliderTitle() {
    return this.localizationService.get("opacitySliderHandle");
  }
  /**
   * @hidden
   */
  get clearButtonTitle() {
    return this.localizationService.get("clearButton");
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  notifyNgChanged = () => {
  };
  notifyNgTouched = () => {
  };
  moveDragHandle(positionX, positionY) {
    const gradientRect = this.gradientRect;
    const gradientRectWidth = gradientRect.width;
    const gradientRectHeight = gradientRect.height;
    const top = fitIntoBounds(positionY, 0, gradientRectHeight);
    const left = fitIntoBounds(positionX, 0, gradientRectWidth);
    this.setDragHandleElementPosition(top, left);
    const hsva = this.hsva.value;
    hsva.s = left / gradientRectWidth;
    hsva.v = 1 - top / gradientRectHeight;
    this.hsva.next(hsva);
    this.updateValues.next(getColorFromHSV(this.hsva.value, this.format, this.opacity));
    this.setAlphaSliderBackground(getColorFromHSV(__spreadProps(__spreadValues({}, this.hsva.value), {
      a: 1
    }), this.format, this.opacity));
  }
  handleValueChange(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  setDragHandleElementPosition(top, left) {
    const dragHandle = this.gradientDragHandle.nativeElement;
    this.hsvHandleCoordinates = {
      x: left,
      y: top
    };
    this.renderer.setStyle(dragHandle, "top", `${top}px`);
    this.renderer.setStyle(dragHandle, "left", `${left}px`);
  }
  setAlphaSliderBackground(backgroundColor) {
    if (!isPresent3(this.alphaSlider)) {
      return;
    }
    const sliderTrack = this.alphaSlider.track.nativeElement;
    this.renderer.setStyle(sliderTrack, "background", `linear-gradient(to ${this.adaptiveMode ? "right" : "top"}, transparent, ${backgroundColor})`);
  }
  setHostElementAriaLabel() {
    const parsed = parseColor2(this.value, this.format, this.opacity);
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", `${this.value ? parsed : this.localizationService.get("colorGradientNoColor")}`);
  }
  setBackgroundColor(color) {
    this.renderer.setStyle(this.hsvRectangle.nativeElement, "background", color);
  }
  updateUI() {
    if (!isDocumentAvailable()) {
      return;
    }
    if (this.hueSliderTouched || this.alphaSliderTouched) {
      this.hueSliderTouched = false;
      this.alphaSliderTouched = false;
      return;
    }
    this.hsva.next(this.value ? getHSV(this.value) : {
      h: 0,
      s: 0,
      v: 1,
      a: 1
    });
    const gradientRect = this.gradientRect;
    const top = (1 - this.hsva.value.v) * gradientRect.height;
    const left = this.hsva.value.s * gradientRect.width;
    this.setDragHandleElementPosition(top, left);
    this.backgroundColor = getColorFromHue(this.hsva.value.h);
    this.setBackgroundColor(this.backgroundColor);
    this.setAlphaSliderBackground(this.backgroundColor);
    this.setHostElementAriaLabel();
  }
  addEventListeners() {
    this.ngZone.runOutsideAngular(() => {
      const focusOutListener = this.renderer.listen(this.host.nativeElement, "focusout", (event) => {
        if (!containsFocus(this.host.nativeElement, event.relatedTarget) && isUntouched(this.host)) {
          this.ngZone.run(() => this.notifyNgTouched());
        }
      });
      const keydownListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "keydown", (event) => {
        this.onKeyboardAction(event);
      });
      const keyupListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "keyup", () => {
        this.renderer.removeClass(this.gradientWrapper.nativeElement, "k-dragging");
        if (!this.readonly && !this.disabled) {
          this.ngZone.run(() => this.handleValueChange(getColorFromHSV(this.hsva.value, this.format, this.opacity)));
        }
      });
      const dragHandleFocusInListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "focusin", () => {
        this.renderer.addClass(this.gradientDragHandle.nativeElement, "k-focus");
      });
      const dragHandleFocusOutListener = this.renderer.listen(this.gradientDragHandle.nativeElement, "focusout", () => {
        this.renderer.removeClass(this.gradientDragHandle.nativeElement, "k-focus");
      });
      this.listeners.push(focusOutListener, keydownListener, keyupListener, dragHandleFocusInListener, dragHandleFocusOutListener);
    });
  }
  subscribeChanges() {
    this.changeRequestsSubscription = this.updateValues.pipe(throttleTime(this.delay)).subscribe((value) => {
      this.handleValueChange(value);
    });
  }
  unsubscribeChanges() {
    if (this.changeRequestsSubscription) {
      this.changeRequestsSubscription.unsubscribe();
    }
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses("colorgradient", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function ColorGradientComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorGradientComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorGradientComponent,
    selectors: [["kendo-colorgradient"]],
    viewQuery: function ColorGradientComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c28, 5);
        ɵɵviewQuery(_c29, 5);
        ɵɵviewQuery(_c30, 5);
        ɵɵviewQuery(_c31, 5);
        ɵɵviewQuery(_c32, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientDragHandle = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputs = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.alphaSlider = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hsvRectangle = _t.first);
      }
    },
    hostVars: 13,
    hostBindings: function ColorGradientComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.enter", function ColorGradientComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.enterHandler($event);
        })("keydown.escape", function ColorGradientComponent_keydown_escape_HostBindingHandler($event) {
          return ctx.escapeHandler($event);
        })("focusin", function ColorGradientComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-readonly", ctx.readonlyAttribute)("id", ctx.gradientId)("dir", ctx.direction)("tabindex", ctx.hostTabindex)("role", ctx.ariaRole)("aria-invalid", ctx.isControlInvalid)("aria-disabled", ctx.isDisabled);
        ɵɵclassProp("k-colorgradient", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      adaptiveMode: "adaptiveMode",
      id: "id",
      opacity: "opacity",
      size: "size",
      disabled: "disabled",
      readonly: "readonly",
      clearButton: "clearButton",
      delay: "delay",
      value: "value",
      contrastTool: "contrastTool",
      tabindex: "tabindex",
      format: "format",
      gradientSliderStep: "gradientSliderStep",
      gradientSliderSmallStep: "gradientSliderSmallStep"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoColorGradient"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorGradientComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorGradientComponent)
    }, ColorGradientLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorGradientLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorgradient"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 16,
    vars: 46,
    consts: () => {
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10 = goog.getMsg("Colorgradient no color chosen");
        i18n_10 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_11 = goog.getMsg("Choose color");
        i18n_11 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12 = goog.getMsg("Clear value");
        i18n_12 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.colorgradient.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_13 = goog.getMsg("Set hue");
        i18n_13 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.colorgradient.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14 = goog.getMsg("Set opacity");
        i18n_14 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_15 = goog.getMsg("Pass");
        i18n_15 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.colorgradient.passContrast|The pass message for the contrast tool.:Pass`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_16 = goog.getMsg("Fail");
        i18n_16 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.colorgradient.failContrast|The fail message for the contrast tool.:Fail`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_17 = goog.getMsg("Contrast ratio");
        i18n_17 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_18 = goog.getMsg("Change color format");
        i18n_18 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.colorgradient.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19 = goog.getMsg("Red channel");
        i18n_19 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_20 = goog.getMsg("Green channel");
        i18n_20 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.colorgradient.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21 = goog.getMsg("Blue channel");
        i18n_21 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.colorgradient.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_22 = goog.getMsg("Alpha channel");
        i18n_22 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.colorgradient.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_23 = goog.getMsg("R");
        i18n_23 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24 = goog.getMsg("G");
        i18n_24 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_25 = goog.getMsg("B");
        i18n_25 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26 = goog.getMsg("HEX");
        i18n_26 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["hsvRectangle", ""], ["gradientWrapper", ""], ["gradientDragHandle", ""], ["inputs", ""], ["alphaSlider", ""], ["kendoColorGradientLocalizedMessages", "", "colorGradientNoColor", i18n_10, "colorGradientHandle", i18n_11, "clearButton", i18n_12, "hueSliderHandle", i18n_13, "opacitySliderHandle", i18n_14, "passContrast", i18n_15, "failContrast", i18n_16, "contrastRatio", i18n_17, "formatButton", i18n_18, "redChannelLabel", i18n_19, "greenChannelLabel", i18n_20, "blueChannelLabel", i18n_21, "alphaChannelLabel", i18n_22, "redChannelLabel", i18n_23, "greenInputPlaceholder", i18n_24, "blueInputPlaceholder", i18n_25, "hexInputPlaceholder", i18n_26], [3, "ngClass"], [1, "k-hsv-rectangle"], ["kendoDraggable", "", 1, "k-hsv-gradient", 3, "click", "kendoPress", "kendoDrag", "kendoRelease"], ["role", "slider", 1, "k-hsv-draghandle", "k-draghandle", 3, "keydown.shift.tab", "tabindex"], ["kendoColorContrastSvg", "", "class", "k-color-contrast-svg", "xmlns", "http://www.w3.org/2000/svg", 3, "wrapper", "hsva", "backgroundColor", "style", 4, "ngIf"], ["kendoButton", "", "class", "k-clear-color", "fillMode", "flat", "icon", "droplet-slash", 3, "svgIcon", "size", "tabindex", "style", "click", "keydown.enter", "keydown.space", 4, "ngIf"], ["tickPlacement", "none", 1, "k-hue-slider", "k-colorgradient-slider", 3, "valueChange", "ngClass", "dragHandleTitle", "tabindex", "disabled", "readonly", "showButtons", "vertical", "min", "max", "value", "smallStep", "largeStep"], ["class", "k-alpha-slider k-colorgradient-slider", "tickPlacement", "none", 3, "tabindex", "ngClass", "height", "dragHandleTitle", "disabled", "readonly", "showButtons", "vertical", "min", "max", "smallStep", "largeStep", "value", "valueChange", 4, "ngIf"], [3, "valueChange", "tabOut", "tabindex", "opacity", "size", "formatView", "value", "disabled", "readonly"], ["class", "k-colorgradient-color-contrast k-vbox", "kendoContrastTool", "", 3, "value", "ratio", 4, "ngIf"], ["kendoColorContrastSvg", "", "xmlns", "http://www.w3.org/2000/svg", 1, "k-color-contrast-svg", 3, "wrapper", "hsva", "backgroundColor"], ["kendoButton", "", "fillMode", "flat", "icon", "droplet-slash", 1, "k-clear-color", 3, "click", "keydown.enter", "keydown.space", "svgIcon", "size", "tabindex"], ["tickPlacement", "none", 1, "k-alpha-slider", "k-colorgradient-slider", 3, "valueChange", "tabindex", "ngClass", "dragHandleTitle", "disabled", "readonly", "showButtons", "vertical", "min", "max", "smallStep", "largeStep", "value"], ["kendoContrastTool", "", 1, "k-colorgradient-color-contrast", "k-vbox", 3, "value", "ratio"]];
    },
    template: function ColorGradientComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "div", 6)(2, "div", 7, 0)(4, "div", 8, 1);
        ɵɵlistener("click", function ColorGradientComponent_Template_div_click_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.changePosition($event));
        })("kendoPress", function ColorGradientComponent_Template_div_kendoPress_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleDragPress($event));
        })("kendoDrag", function ColorGradientComponent_Template_div_kendoDrag_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onHandleDrag($event));
        })("kendoRelease", function ColorGradientComponent_Template_div_kendoRelease_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onHandleRelease());
        });
        ɵɵelementStart(6, "div", 9, 2);
        ɵɵlistener("keydown.shift.tab", function ColorGradientComponent_Template_div_keydown_shift_tab_6_listener($event) {
          ɵɵrestoreView(_r1);
          const inputs_r2 = ɵɵreference(14);
          $event.preventDefault();
          return ɵɵresetView(inputs_r2.focusLast());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(8, ColorGradientComponent__svg_svg_8_Template, 1, 5, "svg", 10);
        ɵɵelementEnd();
        ɵɵelementStart(9, "div", 6);
        ɵɵtemplate(10, ColorGradientComponent_button_10_Template, 1, 7, "button", 11);
        ɵɵelementStart(11, "kendo-slider", 12);
        ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_slider_valueChange_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleHueSliderChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, ColorGradientComponent_kendo_slider_12_Template, 2, 16, "kendo-slider", 13);
        ɵɵelementEnd()();
        ɵɵelementStart(13, "kendo-colorinput", 14, 3);
        ɵɵlistener("valueChange", function ColorGradientComponent_Template_kendo_colorinput_valueChange_13_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputsValueChange($event));
        })("tabOut", function ColorGradientComponent_Template_kendo_colorinput_tabOut_13_listener() {
          ɵɵrestoreView(_r1);
          const gradientDragHandle_r7 = ɵɵreference(7);
          return ɵɵresetView(gradientDragHandle_r7.focus());
        });
        ɵɵelementEnd();
        ɵɵtemplate(15, ColorGradientComponent_div_15_Template, 1, 2, "div", 15);
      }
      if (rf & 2) {
        const gradientWrapper_r4 = ɵɵreference(5);
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction2(37, _c33, ctx.adaptiveMode, !ctx.adaptiveMode));
        ɵɵadvance(3);
        ɵɵstyleProp("touch-action", "none");
        ɵɵadvance(2);
        ɵɵproperty("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.colorGradientHandleTitle)("aria-label", ctx.colorGradientHandleTitle + " " + ctx.colorGradientHandleAriaLabel)("aria-valuetext", ctx.hsvSliderValueText)("aria-readonly", ctx.readonly ? ctx.readonly : void 0)("aria-disabled", ctx.disabled ? ctx.disabled : void 0)("aria-orientation", "undefined")("aria-valuenow", "0");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.contrastToolVisible && gradientWrapper_r4);
        ɵɵadvance();
        ɵɵproperty("ngClass", ɵɵpureFunction3(40, _c34, ctx.clearButton, ctx.adaptiveMode, !ctx.adaptiveMode));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton);
        ɵɵadvance();
        ɵɵstyleProp("height", ctx.clearButton ? "140" : null, "px");
        ɵɵproperty("ngClass", ɵɵpureFunction1(44, _c35, ctx.clearButton))("dragHandleTitle", ctx.hueSliderTitle)("tabindex", ctx.innerTabIndex)("disabled", ctx.disabled)("readonly", ctx.readonly)("showButtons", false)("vertical", !ctx.adaptiveMode)("min", 0)("max", 360)("value", ctx.hsva.value.h)("smallStep", 5)("largeStep", 10);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.opacity);
        ɵɵadvance();
        ɵɵproperty("tabindex", ctx.innerTabIndex)("opacity", ctx.opacity)("size", ctx.size)("formatView", ctx.format)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.contrastToolVisible);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, DraggableDirective, NgIf, ColorContrastSvgComponent, ButtonComponent, SliderComponent, NgClass, ColorInputComponent, ContrastComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorGradientComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorGradient",
      selector: "kendo-colorgradient",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorGradientComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorGradientComponent)
      }, ColorGradientLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorGradientLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorgradient"
      }],
      template: `
        <ng-container kendoColorGradientLocalizedMessages
            i18n-colorGradientNoColor="kendo.colorgradient.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorGradientHandle="kendo.colorgradient.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorgradient.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorgradient.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorgradient.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-passContrast="kendo.colorgradient.passContrast|The pass message for the contrast tool."
            passContrast="Pass"
            i18n-failContrast="kendo.colorgradient.failContrast|The fail message for the contrast tool."
            failContrast="Fail"
            i18n-contrastRatio="kendo.colorgradient.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-formatButton="kendo.colorgradient.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-redChannelLabel="kendo.colorgradient.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.colorgradient.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.colorgradient.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.colorgradient.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.colorgradient.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.colorgradient.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.colorgradient.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.colorgradient.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <div [ngClass]="{
                'k-colorgradient-canvas': true,
                'k-vstack': adaptiveMode,
                'k-hstack': !adaptiveMode
            }">
            <div class="k-hsv-rectangle" #hsvRectangle>
                <div
                    #gradientWrapper
                    kendoDraggable
                    class="k-hsv-gradient"
                    (click)="changePosition($event)"
                    (kendoPress)="handleDragPress($event)"
                    (kendoDrag)="onHandleDrag($event)"
                    (kendoRelease)="onHandleRelease()"
                    [style.touch-action]="'none'">
                    <div
                        #gradientDragHandle
                        class="k-hsv-draghandle k-draghandle"
                        [tabindex]="innerTabIndex.toString()"
                        [attr.title]="colorGradientHandleTitle"
                        [attr.aria-label]="colorGradientHandleTitle + ' ' + colorGradientHandleAriaLabel"
                        role="slider"
                        [attr.aria-valuetext]="hsvSliderValueText"
                        [attr.aria-readonly]="readonly ? readonly : undefined"
                        [attr.aria-disabled]="disabled ? disabled : undefined"
                        [attr.aria-orientation]="'undefined'"
                        [attr.aria-valuenow]="'0'"
                        (keydown.shift.tab)="$event.preventDefault(); inputs.focusLast();">
                    </div>
                </div>
                <svg kendoColorContrastSvg
                    *ngIf="contrastToolVisible && gradientWrapper"
                    class="k-color-contrast-svg"
                    xmlns="http://www.w3.org/2000/svg"
                    [wrapper]="gradientWrapper ? gradientWrapper : undefined"
                    [hsva]="hsva"
                    [backgroundColor]="contrastTool"
                    [style]="'position: absolute; overflow: visible; pointer-events: none; left: 0px; top: 0px;'">
                </svg>
            </div>
            <div [ngClass]="{
                    'k-hsv-controls': true,
                    'k-sliders-wrap-clearable': clearButton,
                    'k-vstack': adaptiveMode,
                    'k-hstack': !adaptiveMode
                }">
                <button
                    kendoButton
                    *ngIf="clearButton"
                    class="k-clear-color"
                    fillMode="flat"
                    icon="droplet-slash"
                    [svgIcon]="dropletSlashIcon"
                    [size]="size"
                    (click)="reset()"
                    (keydown.enter)="reset()"
                    (keydown.space)="reset()"
                    [attr.aria-label]="clearButtonTitle"
                    [attr.title]="clearButtonTitle"
                    [tabindex]="innerTabIndex.toString()"
                    [style]="'position: absolute; top: 0; left: 50%; transform: translateX(-50%);'"
                >
                </button>
                <kendo-slider
                    [ngClass]="{'k-align-self-end': clearButton}"
                    [style.height.px]="clearButton ? '140' : null"
                    class="k-hue-slider k-colorgradient-slider"
                    [dragHandleTitle]="hueSliderTitle"
                    [tabindex]="innerTabIndex"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    tickPlacement="none"
                    [vertical]="!adaptiveMode"
                    [min]="0"
                    [max]="360"
                    [value]="hsva.value.h"
                    [smallStep]="5"
                    [largeStep]="10"
                    (valueChange)="handleHueSliderChange($event)"
                >
                </kendo-slider>
                <kendo-slider
                    *ngIf="opacity"
                    #alphaSlider
                    [tabindex]="innerTabIndex"
                    [ngClass]="{'k-align-self-end': clearButton}"
                    [style.height.px]="clearButton ? '140' : null"
                    class="k-alpha-slider k-colorgradient-slider"
                    [dragHandleTitle]="opacitySliderTitle"
                    [disabled]="disabled"
                    [readonly]="readonly"
                    [showButtons]="false"
                    tickPlacement="none"
                    [vertical]="!adaptiveMode"
                    [min]="0"
                    [max]="100"
                    [smallStep]="1"
                    [largeStep]="10"
                    [value]="alphaSliderValue"
                    (valueChange)="handleAlphaSliderChange($event)"
                >
                </kendo-slider>
            </div>
        </div>
        <kendo-colorinput  #inputs
            [tabindex]="innerTabIndex"
            [opacity]="opacity"
            [size]="size"
            [formatView]="format"
            [value]="value"
            [disabled]="disabled"
            [readonly]="readonly"
            (valueChange)="handleInputsValueChange($event)"
            (tabOut)="gradientDragHandle.focus()"
        >
        </kendo-colorinput>
        <div class="k-colorgradient-color-contrast k-vbox"
            *ngIf="contrastToolVisible"
            kendoContrastTool
            [value]="value"
            [ratio]="contrastTool">
        </div>
    `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, DraggableDirective, NgIf, ColorContrastSvgComponent, ButtonComponent, SliderComponent, NgClass, ColorInputComponent, ContrastComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: Injector
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorgradient"]
    }],
    readonlyAttribute: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    gradientId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    enterHandler: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }],
    escapeHandler: [{
      type: HostListener,
      args: ["keydown.escape", ["$event"]]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    adaptiveMode: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    opacity: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    clearButton: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    contrastTool: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    gradientSliderStep: [{
      type: Input
    }],
    gradientSliderSmallStep: [{
      type: Input
    }],
    gradientDragHandle: [{
      type: ViewChild,
      args: ["gradientDragHandle"]
    }],
    inputs: [{
      type: ViewChild,
      args: ["inputs"]
    }],
    alphaSlider: [{
      type: ViewChild,
      args: ["alphaSlider"]
    }],
    gradientWrapper: [{
      type: ViewChild,
      args: ["gradientWrapper"]
    }],
    hsvRectangle: [{
      type: ViewChild,
      args: ["hsvRectangle"]
    }]
  });
})();
var ColorPaletteLocalizationService = class _ColorPaletteLocalizationService extends LocalizationService {
  flatColorPickerLocalization;
  constructor(prefix, messageService, _rtl, flatColorPickerLocalization) {
    super(prefix, messageService, _rtl);
    this.flatColorPickerLocalization = flatColorPickerLocalization;
  }
  get(shortKey) {
    if (this.flatColorPickerLocalization) {
      return this.flatColorPickerLocalization.get(shortKey);
    }
    return super.get(shortKey);
  }
  static ɵfac = function ColorPaletteLocalizationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteLocalizationService)(ɵɵinject(L10N_PREFIX), ɵɵinject(MessageService, 8), ɵɵinject(RTL, 8), ɵɵinject(FlatColorPickerLocalizationService, 8));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPaletteLocalizationService,
    factory: _ColorPaletteLocalizationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteLocalizationService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [L10N_PREFIX]
      }]
    }, {
      type: MessageService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [RTL]
      }]
    }, {
      type: FlatColorPickerLocalizationService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [FlatColorPickerLocalizationService]
      }]
    }];
  }, null);
})();
var PALETTEPRESETS = {
  basic: {
    colors: "000000,7f7f7f,880015,ed1c24,ff7f27,fff200,22b14c,00a2e8,3f48cc,a349a4,ffffff,c3c3c3,b97a57,ffaec9,ffc90e,efe4b0,b5e61d,99d9ea,7092be,c8bfe7",
    columns: 10
  },
  office: {
    colors: "ffffff, 000000, e6e6e6, 435569, 4371c4, ed7e32, a5a4a5, febf04, 5a9bd5, 71ae48, f2f2f3, 7f7f7f, d1cece, d5dde3, dae1f4, fce5d4, deeded, fff2cc, deeaf6, e1efd9, d7d8d8, 585959, aeabab, adbaca, b4c5e7, f6caac, dbdbdb, ffe498, bcd6ee, c5e0b2, bfbfc0, 3f3f3f, 767070, 8595b1, 8fabdb, f5b183, c9c8c9, fed965, 9bc4e5, a8d08d, a5a5a6, 262625, 393939, 334050, 2e5496, c45a11, 7b7b7a, bf9000, 2f75b5, 548235, 7f7f7f, 0b0c0c, 161616, 222a34, 203764, 843d0b, 525252, 7f6000, 1d4d79, 375623",
    columns: 10
  },
  apex: {
    colors: "ffffff, 000000, c9c2d1, 69676d, ceb966, 9cb084, 6bb1c9, 6585cf, 7e6bc9, a379bb, f2f2f2, 7f7f7f, f4f2f5, e0e0e2, f5f1e0, ebefe6, e1eff4, e0e6f5, e5e1f4, ece4f1, d8d8d8, 595959, e9e6ec, c2c1c5, ebe3c1, d7dfcd, c3dfe9, c1ceeb, cbc3e9, dac9e3, bfbfbf, 3f3f3f, dedae3, a4a3a8, e1d5a3, c3cfb5, a6d0de, a2b5e2, b1a6de, c7aed6, a5a5a5, 262626, 9688a5, 4e4d51, ae9638, 758c5a, 3d8da9, 365bb0, 533da9, 7d4d99, 7f7f7f, 0c0c0c, 635672, 343336, 746425, 4e5d3c, 295e70, 243c75, 372970, 533366",
    columns: 10
  },
  austin: {
    colors: "ffffff, 000000, caf278, 3e3d2d, 94c600, 71685a, ff6700, 909465, 956b43, fea022, f2f2f2, 7f7f7f, f4fce4, dddcd0, efffc0, e3e1dc, ffe0cb, e8e9df, ece1d6, feecd2, d8d8d8, 595959, e9f9c9, bbb9a1, dfff82, c8c3ba, ffc299, d2d4c0, dac3ad, fed9a6, bfbfbf, 3f3f3f, dff7ae, ada598, cfff43, ada598, ffa365, bcbfa1, c8a585, fec67a, a5a5a5, 262626, a9ea25, 2e2d21, 6f9400, 544e43, bf4d00, 6c6f4b, 6f5032, d77b00, 7f7f7f, 0c0c0c, 74a50f, 1f1e16, 4a6300, 38342d, 7f3300, 484a32, 4a3521, 8f5200",
    columns: 10
  },
  clarity: {
    colors: "ffffff, 292934, f3f2dc, d2533c, 93a299, ad8f67, 726056, 4c5a6a, 808da0, 79463d, f2f2f2, e7e7ec, e7e5b9, f6dcd8, e9ecea, eee8e0, e4dedb, d8dde3, e5e8ec, e9d6d3, d8d8d8, c4c4d1, d5d185, edbab1, d3d9d6, ded2c2, c9beb8, b2bcc8, ccd1d9, d3aea7, bfbfbf, 8a8aa3, aca73b, e4978a, bec7c1, cdbba3, af9e94, 8c9bac, b2bac6, bd857c, a5a5a5, 56566e, 56531d, a43925, 6b7c72, 866b48, 554840, 39434f, 5c697b, 5a342d, 7f7f7f, 3b3b4b, 22210b, 6d2619, 47534c, 594730, 39302b, 262d35, 3d4652, 3c231e",
    columns: 10
  },
  slipstream: {
    colors: "ffffff, 000000, b4dcfa, 212745, 4e67c8, 5eccf3, a7ea52, 5dceaf, ff8021, f14124, f2f2f2, 7f7f7f, 8bc9f7, c7cce4, dbe0f4, def4fc, edfadc, def5ef, ffe5d2, fcd9d3, d8d8d8, 595959, 4facf3, 909aca, b8c2e9, beeafa, dbf6b9, beebdf, ffcca6, f9b3a7, bfbfbf, 3f3f3f, 0d78c9, 5967af, 94a3de, 9ee0f7, caf297, 9de1cf, ffb279, f68d7b, a5a5a5, 262626, 063c64, 181d33, 31479f, 11b2eb, 81d319, 34ac8b, d85c00, c3260c, 7f7f7f, 0c0c0c, 021828, 101322, 202f6a, 0b769c, 568c11, 22725c, 903d00, 821908",
    columns: 10
  },
  metro: {
    colors: "ffffff, 000000, d6ecff, 4e5b6f, 7fd13b, ea157a, feb80a, 00addc, 738ac8, 1ab39f, f2f2f2, 7f7f7f, a7d6ff, d9dde4, e5f5d7, fad0e4, fef0cd, c5f2ff, e2e7f4, c9f7f1, d8d8d8, 595959, 60b5ff, b3bcca, cbecb0, f6a1c9, fee29c, 8be6ff, c7d0e9, 94efe3, bfbfbf, 3f3f3f, 007dea, 8d9baf, b2e389, f272af, fed46b, 51d9ff, aab8de, 5fe7d5, a5a5a5, 262626, 003e75, 3a4453, 5ea226, af0f5b, c58c00, 0081a5, 425ea9, 138677, 7f7f7f, 0c0c0c, 00192e, 272d37, 3f6c19, 750a3d, 835d00, 00566e, 2c3f71, 0c594f",
    columns: 10
  },
  flow: {
    colors: "ffffff, 000000, dbf5f9, 04617b, 0f6fc6, 009dd9, 0bd0d9, 10cf9b, 7cca62, a5c249, f2f2f2, 7f7f7f, b2e9f2, b4ecfc, c7e2fa, c4eeff, c9fafc, c9faed, e4f4df, edf2da, d8d8d8, 595959, 76d9e8, 6adafa, 90c6f6, 89deff, 93f5f9, 94f6db, cae9c0, dbe6b6, bfbfbf, 3f3f3f, 21b2c8, 20c8f7, 59a9f2, 4fceff, 5df0f6, 5ff2ca, b0dfa0, c9da91, a5a5a5, 262626, 105964, 02485c, 0b5394, 0075a2, 089ca2, 0b9b74, 54a838, 7e9532, 7f7f7f, 0c0c0c, 062328, 01303d, 073763, 004e6c, 05686c, 07674d, 387025, 546321",
    columns: 10
  },
  hardcover: {
    colors: "ffffff, 000000, ece9c6, 895d1d, 873624, d6862d, d0be40, 877f6c, 972109, aeb795, f2f2f2, 7f7f7f, e1dca5, f2e0c6, f0d0c9, f6e6d5, f5f2d8, e7e5e1, fbc7bc, eef0e9, d8d8d8, 595959, d0c974, e6c28d, e2a293, eeceaa, ece5b2, cfccc3, f78f7a, dee2d4, bfbfbf, 3f3f3f, a29a36, daa454, d4735e, e6b681, e2d88c, b7b2a5, f35838, ced3bf, a5a5a5, 262626, 514d1b, 664515, 65281a, a2641f, a39428, 655f50, 711806, 879464, 7f7f7f, 0c0c0c, 201e0a, 442e0e, 431b11, 6c4315, 6d621a, 433f35, 4b1004, 5a6243",
    columns: 10
  },
  trek: {
    colors: "ffffff, 000000, fbeec9, 4e3b30, f0a22e, a5644e, b58b80, c3986d, a19574, c17529, f2f2f2, 7f7f7f, f7e09e, e1d6cf, fcecd5, eddfda, f0e7e5, f3eae1, ece9e3, f5e3d1, d8d8d8, 595959, f3cc5f, c4ad9f, f9d9ab, dcc0b6, e1d0cc, e7d5c4, d9d4c7, ebc7a3, bfbfbf, 3f3f3f, d29f0f, a78470, f6c781, cba092, d2b9b2, dbc1a7, c6bfab, e1ac76, a5a5a5, 262626, 694f07, 3a2c24, c87d0e, 7b4b3a, 926255, a17242, 7b7153, 90571e, 7f7f7f, 0c0c0c, 2a1f03, 271d18, 855309, 523226, 614138, 6b4c2c, 524b37, 603a14",
    columns: 10
  },
  verve: {
    colors: "ffffff, 000000, d2d2d2, 666666, ff388c, e40059, 9c007f, 68007f, 005bd3, 00349e, f2f2f2, 7f7f7f, bdbdbd, e0e0e0, ffd7e8, ffc6dc, ffb8f1, f1b2ff, c3dcff, b8cfff, d8d8d8, 595959, 9d9d9d, c1c1c1, ffafd1, ff8eba, ff71e4, e365ff, 87baff, 72a0ff, bfbfbf, 3f3f3f, 696969, a3a3a3, ff87ba, ff5597, ff2ad7, d519ff, 4b98ff, 2b71ff, a5a5a5, 262626, 343434, 4c4c4c, e90062, ab0042, 75005f, 4e005f, 00449e, 002676, 7f7f7f, 0c0c0c, 151515, 333333, 9b0041, 72002c, 4e003f, 34003f, 002d69, 00194f",
    columns: 10
  },
  monochrome: {
    colors: "000000, 1a1a1a, 333333, 4d4d4d, 666666, 808080, 999999, b3b3b3, cccccc, e6e6e6, f2f2f2, ffffff",
    columns: 12
  },
  accessible: {
    colors: "black, grey, darkred, red, darkorange, gold, green, blue, darkblue, purple, white, darkgrey, saddlebrown, pink, orange, yellow, lightgreen, lightskyblue, lightblue, mediumpurple",
    columns: 10
  }
};
var ColorPaletteService = class _ColorPaletteService {
  colorRows = [];
  setColorMatrix(palette, columns) {
    this.colorRows = [];
    if (!(isPresent3(palette) && palette.length)) {
      return;
    }
    columns = columns || palette.length;
    for (let start = 0; start < palette.length; start += columns) {
      const row = palette.slice(start, columns + start);
      this.colorRows.push(row);
    }
  }
  getCellCoordsFor(color) {
    if (!isPresent3(color)) {
      return;
    }
    for (let row = 0; row < this.colorRows.length; row++) {
      for (let col = 0; col < this.colorRows[row].length; col++) {
        if (this.colorRows[row][col] === color) {
          return {
            row,
            col
          };
        }
      }
    }
  }
  getColorAt(cellCoords) {
    if (!(isPresent3(cellCoords) && isPresent3(this.colorRows[cellCoords.row]))) {
      return;
    }
    return this.colorRows[cellCoords.row][cellCoords.col];
  }
  getNextCell(current, horizontalStep, verticalStep) {
    if (!(isPresent3(current) && isPresent3(current.row) && isPresent3(current.col))) {
      return {
        row: 0,
        col: 0
      };
    }
    const row = this.clampIndex(current.row + verticalStep, this.colorRows.length - 1);
    const col = this.clampIndex(current.col + horizontalStep, this.colorRows[row].length - 1);
    return {
      row,
      col
    };
  }
  clampIndex(index, max) {
    const minArrayIndex = 0;
    if (index < minArrayIndex) {
      return minArrayIndex;
    }
    if (index > max) {
      return max;
    }
    return index;
  }
  static ɵfac = function ColorPaletteService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ColorPaletteService,
    factory: _ColorPaletteService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteService, [{
    type: Injectable
  }], null, null);
})();
var DEFAULT_COLUMNS_COUNT = 10;
var DEFAULT_PRESET = "office";
var DEFAULT_ACCESSIBLE_PRESET = "accessible";
var DEFAULT_SIZE$6 = "medium";
var serial$2 = 0;
var ColorPaletteComponent = class _ColorPaletteComponent {
  host;
  service;
  cdr;
  renderer;
  localizationService;
  ngZone;
  /**
   * @hidden
   */
  direction;
  /**
   * @hidden
   */
  role = "grid";
  /**
   * @hidden
   */
  get activeDescendant() {
    return this.activeCellId;
  }
  /**
   * @hidden
   */
  get paletteId() {
    return this.id;
  }
  /**
   * @hidden
   */
  id = `k-colorpalette-${serial$2++}`;
  /**
   * Specifies the output format of the `ColorPaletteComponent`.
   * The input value may be in a different format. The component parses it into the output `format`.
   *
   * @default 'hex'
   */
  format = "hex";
  /**
   * Sets the value of the selected color.
   */
  set value(value) {
    this._value = parseColor2(value, this.format);
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the number of columns to display.
   *
   * @default 10
   */
  set columns(value) {
    const minColumnsCount = 1;
    this._columns = value > minColumnsCount ? value : minColumnsCount;
  }
  get columns() {
    return this._columns;
  }
  /**
   * Sets the color palette to display. You can use a predefined palette preset (such as `office`, `basic`, or `apex`), string with comma-separated colors, or an array of string colors.
   */
  set palette(value) {
    if (!isPresent3(value)) {
      value = DEFAULT_PRESET;
    }
    if (typeof value === "string" && isPresent3(PALETTEPRESETS[value])) {
      this.columns = this.columns || PALETTEPRESETS[value].columns;
      value = PALETTEPRESETS[value].colors;
    }
    const colors = typeof value === "string" ? value.split(",") : value;
    this._palette = colors.map((color) => parseColor2(color, this.format, false, false));
  }
  get palette() {
    return this._palette;
  }
  /**
   * Sets the size of the ColorPalette internal elements.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$6;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Disables the ColorPalette. To disable it in reactive forms, see [Forms Support](slug:formssupport_colorpalette#toc-managing-the-colorpalette-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the ColorPalette.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the size of a color cell. The default tile size depends on the `size` of the component.
   */
  tileSize;
  /**
   * @hidden
   */
  get tileLayout() {
    if (typeof this.tileSize !== "number") {
      return this.tileSize;
    }
    return {
      width: this.tileSize,
      height: this.tileSize
    };
  }
  /**
   * Fires when the color selection changes.
   */
  selectionChange = new EventEmitter();
  /**
   * Fires when the value changes.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user selects a cell with the mouse or presses `Enter`.
   *
   * @hidden
   */
  cellSelection = new EventEmitter();
  /**
   * @hidden
   */
  get colorRows() {
    return this.service.colorRows;
  }
  /**
   * @hidden
   */
  get hostTabindex() {
    return this.tabindex;
  }
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get disabledClass() {
    return this.disabled;
  }
  /**
   * @hidden
   */
  get readonlyAttribute() {
    return this.readonly;
  }
  /**
   * @hidden
   */
  activeCellId;
  /**
   * @hidden
   */
  focusedCell;
  /**
   * @hidden
   */
  selectedCell;
  /**
   * @hidden
   */
  focusInComponent;
  /**
   * @hidden
   */
  uniqueId = guid();
  selection;
  _size = "medium";
  _value;
  _columns;
  _palette;
  _tabindex = 0;
  subs = new Subscription();
  dynamicRTLSubscription;
  constructor(host, service, cdr, renderer, localizationService, ngZone) {
    this.host = host;
    this.service = service;
    this.cdr = cdr;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    if (this.colorRows.length === 0) {
      const defaultPreset = this.format !== "name" ? DEFAULT_PRESET : DEFAULT_ACCESSIBLE_PRESET;
      this.palette = this.palette || defaultPreset;
      this.setRows();
    }
    const elem = this.host.nativeElement;
    this.subs.add(this.renderer.listen(elem, "keydown", (event) => this.handleKeydown(event)));
    this.subs.add(this.renderer.listen(elem, "focus", () => this.handleFocus()));
    this.subs.add(this.renderer.listen(elem, "blur", () => this.handleHostBlur()));
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    if (this.value) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.selectCell(this.value);
      });
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
  }
  ngOnChanges(changes) {
    if (changes["palette"] || changes["columns"]) {
      this.setRows();
    }
    if (changes["palette"] || changes["value"] || changes["columns"]) {
      this.selectCell(this.value);
      this.setHostElementAriaLabel();
    }
  }
  /**
   * @hidden
   */
  handleKeydown(event) {
    const isRTL = this.direction === "rtl";
    switch (event.keyCode) {
      case Keys.ArrowDown:
        this.handleCellNavigation(0, 1);
        break;
      case Keys.ArrowUp:
        this.handleCellNavigation(0, -1);
        break;
      case Keys.ArrowRight:
        this.handleCellNavigation(isRTL ? -1 : 1, 0);
        break;
      case Keys.ArrowLeft:
        this.handleCellNavigation(isRTL ? 1 : -1, 0);
        break;
      case Keys.Enter:
        this.handleEnter();
        break;
      default:
        return;
    }
    event.preventDefault();
  }
  /**
   * @hidden
   */
  handleFocus() {
    if (!this.focusInComponent) {
      this.focus();
    }
  }
  /**
   * @hidden
   */
  handleHostBlur() {
    this.notifyNgTouched();
    this.handleCellFocusOnBlur();
  }
  /**
   * @hidden
   */
  handleCellSelection(value, focusedCell) {
    if (this.readonly) {
      return;
    }
    this.selectedCell = focusedCell;
    this.focusedCell = this.selectedCell;
    this.focusInComponent = true;
    const parsedColor = parseColor2(value, this.format, false, false);
    this.cellSelection.emit(parsedColor);
    this.handleValueChange(parsedColor);
    if (this.selection !== parsedColor) {
      this.selection = parsedColor;
      this.selectionChange.emit(parsedColor);
    }
    if (focusedCell) {
      this.activeCellId = `k-${this.selectedCell.row}-${this.selectedCell.col}-${this.uniqueId}`;
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.selectCell(value);
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  focus() {
    this.host.nativeElement.focus();
    if (!this.focusedCell && !this.readonly && !this.disabled) {
      this.focusedCell = {
        row: 0,
        col: 0
      };
      this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  /**
   * Clears the color value of the ColorPalette.
   */
  reset() {
    this.focusedCell = null;
    if (isPresent3(this.value)) {
      this.handleValueChange(void 0);
    }
    this.selectedCell = void 0;
  }
  handleValueChange(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  handleCellFocusOnBlur() {
    this.focusInComponent = false;
    this.focusedCell = this.selectedCell;
  }
  selectCell(value) {
    const parsedColor = parseColor2(value, "hex");
    this.selectedCell = this.service.getCellCoordsFor(parsedColor);
    this.focusedCell = this.selectedCell;
  }
  setRows() {
    if (!isPresent3(this.palette)) {
      return;
    }
    this.columns = this.columns || DEFAULT_COLUMNS_COUNT;
    this.service.setColorMatrix(this.palette, this.columns);
  }
  handleCellNavigation(horizontalStep, verticalStep) {
    if (this.readonly) {
      return;
    }
    this.focusedCell = this.service.getNextCell(this.focusedCell, horizontalStep, verticalStep);
    this.focusInComponent = true;
    if (this.focusedCell) {
      this.activeCellId = `k-${this.focusedCell.row}-${this.focusedCell.col}-${this.uniqueId}`;
    }
  }
  setHostElementAriaLabel() {
    const parsed = parseColor2(this.value, this.format);
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", `${this.value ? parsed : this.localizationService.get("colorPaletteNoColor")}`);
  }
  handleEnter() {
    if (!isPresent3(this.focusedCell)) {
      return;
    }
    const selectedColor = this.service.getColorAt(this.focusedCell);
    this.handleCellSelection(selectedColor, this.focusedCell);
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses("colorpalette", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  notifyNgTouched = () => {
  };
  notifyNgChanged = () => {
  };
  static ɵfac = function ColorPaletteComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPaletteComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ColorPaletteService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPaletteComponent,
    selectors: [["kendo-colorpalette"]],
    hostVars: 13,
    hostBindings: function ColorPaletteComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.role)("aria-activedescendant", ctx.activeDescendant)("id", ctx.paletteId)("tabindex", ctx.hostTabindex)("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.readonlyAttribute);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-colorpalette", ctx.hostClasses)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      id: "id",
      format: "format",
      value: "value",
      columns: "columns",
      palette: "palette",
      size: "size",
      tabindex: "tabindex",
      disabled: "disabled",
      readonly: "readonly",
      tileSize: "tileSize"
    },
    outputs: {
      selectionChange: "selectionChange",
      valueChange: "valueChange",
      cellSelection: "cellSelection"
    },
    exportAs: ["kendoColorPalette"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorPaletteComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorPaletteComponent)
    }, ColorPaletteService, ColorPaletteLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorPaletteLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorpalette"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 4,
    vars: 1,
    consts: () => {
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_27 = goog.getMsg("Colorpalette no color chosen");
        i18n_27 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      return [["kendoColorPaletteLocalizedMessages", "", "colorPaletteNoColor", i18n_27], ["role", "presentation", 1, "k-colorpalette-table"], ["role", "row", 4, "ngFor", "ngForOf"], ["role", "row"], ["role", "gridcell", "class", "k-colorpalette-tile", 3, "k-selected", "k-focus", "id", "ngStyle", "click", 4, "ngFor", "ngForOf"], ["role", "gridcell", 1, "k-colorpalette-tile", 3, "click", "id", "ngStyle"]];
    },
    template: function ColorPaletteComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 0);
        ɵɵelementStart(1, "table", 1)(2, "tbody");
        ɵɵtemplate(3, ColorPaletteComponent_tr_3_Template, 2, 1, "tr", 2);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngForOf", ctx.colorRows);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgForOf, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPaletteComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorPalette",
      selector: "kendo-colorpalette",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorPaletteComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorPaletteComponent)
      }, ColorPaletteService, ColorPaletteLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorPaletteLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorpalette"
      }],
      template: `
        <ng-container kendoColorPaletteLocalizedMessages
            i18n-colorPaletteNoColor="kendo.colorpalette.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen">
        </ng-container>
        <table role="presentation" class="k-colorpalette-table">
            <tbody>
                <tr *ngFor="let row of colorRows; let rowIndex = index" role="row">
                    <td *ngFor="let color of row; let colIndex = index"
                        role="gridcell"
                        [class.k-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex"
                        [class.k-focus]="focusInComponent && focusedCell?.row === rowIndex && focusedCell?.col === colIndex"
                        [attr.aria-selected]="selectedCell?.row === rowIndex && selectedCell?.col === colIndex ? 'true' : undefined"
                        [attr.aria-label]="color"
                        class="k-colorpalette-tile"
                        [id]="'k-' + rowIndex + '-' + colIndex + '-' + uniqueId"
                        [attr.value]="color"
                        (click)="handleCellSelection(color, { row: rowIndex, col: colIndex })"
                        [ngStyle]="{
                            backgroundColor: color,
                            width: tileLayout?.width + 'px',
                            height: tileLayout?.height + 'px',
                            minWidth: tileLayout?.width + 'px'
                        }">
                    </td>
                </tr>
            </tbody>
        </table>
    `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgForOf, NgStyle]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ColorPaletteService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    activeDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    paletteId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    id: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    columns: [{
      type: Input
    }],
    palette: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tileSize: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    cellSelection: [{
      type: Output
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorpalette"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    readonlyAttribute: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }]
  });
})();
var FlatColorPickerService = class _FlatColorPickerService {
  getPaletteSettings(settings, format) {
    const defaultPreset = format !== "name" ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
    const settingsPalette = settings.palette;
    const presetColumns = typeof settingsPalette === "string" && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : void 0;
    return {
      palette: settingsPalette || defaultPreset,
      tileSize: settings.tileSize,
      columns: settings.columns || presetColumns || 10
    };
  }
  paletteTileLayout(tileSize) {
    if (typeof tileSize === "number") {
      return {
        width: tileSize,
        height: tileSize
      };
    }
    return {
      width: tileSize?.width ? tileSize?.width : tileSize?.height,
      height: tileSize?.height ? tileSize?.height : tileSize?.width
    };
  }
  static ɵfac = function FlatColorPickerService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _FlatColorPickerService,
    factory: _FlatColorPickerService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerService, [{
    type: Injectable
  }], null, null);
})();
var ColorPickerCancelEvent = class extends PreventableEvent {
  /**
   * The DOM event that triggered the `cancel` event.
   */
  originalEvent;
  constructor(originalEvent) {
    super();
    this.originalEvent = originalEvent;
  }
};
var ColorPickerCloseEvent = class extends PreventableEvent {
};
var ColorPickerOpenEvent = class extends PreventableEvent {
};
var ActiveColorClickEvent = class {
  color;
  openPrevented = false;
  /**
   * @hidden
   * @param color Represents the current value of the ColorPicker.
   */
  constructor(color) {
    this.color = color;
  }
  /**
   * Prevents the popup from opening.
   */
  preventOpen() {
    this.openPrevented = true;
  }
  /**
   * Returns `true` if the popup opening is prevented by any of its subscribers.
   *
   * @returns Returns `true` if the open action was prevented. Otherwise, returns `false`.
   */
  isOpenPrevented() {
    return this.openPrevented;
  }
};
var FlatColorPickerHeaderComponent = class _FlatColorPickerHeaderComponent {
  localizationService;
  renderer;
  hostClasses = true;
  clearButton;
  activeView;
  views;
  preview;
  innerTabIndex = -1;
  value;
  selection;
  size;
  viewChange = new EventEmitter();
  valuePaneClick = new EventEmitter();
  clearButtonClick = new EventEmitter();
  tabOut = new EventEmitter();
  viewButtonsCollection;
  clearButtonElement;
  dropletSliderIcon = dropletSliderIcon;
  paletteIcon = paletteIcon;
  dropletSlashIcon = dropletSlashIcon;
  constructor(localizationService, renderer) {
    this.localizationService = localizationService;
    this.renderer = renderer;
  }
  ngAfterViewInit() {
    if (this.viewButtonsCollection.length > 0) {
      this.viewButtonsCollection.forEach((button) => {
        const buttonElem = button.nativeElement;
        const isViewActive = buttonElem.getAttribute("aria-pressed") === "true";
        if (isViewActive) {
          this.renderer.addClass(buttonElem, "k-selected");
        }
      });
    }
  }
  onViewButtonClick(view) {
    this.activeView = view;
    this.viewChange.emit(view);
  }
  get viewButtons() {
    return this.views && this.views.indexOf("gradient") >= 0 && this.views.indexOf("palette") >= 0;
  }
  getViewButtonIcon(view) {
    return view === "gradient" ? "color-canvas" : "palette";
  }
  getViewButtonsSVGIcon(view) {
    return view === "gradient" ? this.dropletSliderIcon : this.paletteIcon;
  }
  getText(text) {
    return this.localizationService.get(text);
  }
  onHeaderTabOut(ev, index) {
    if (index === 0) {
      ev.preventDefault();
      this.tabOut.emit(ev);
    }
  }
  static ɵfac = function FlatColorPickerHeaderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerHeaderComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerHeaderComponent,
    selectors: [["", "kendoFlatColorPickerHeader", ""]],
    viewQuery: function FlatColorPickerHeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c37, 5, ElementRef);
        ɵɵviewQuery(_c38, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.clearButtonElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.viewButtonsCollection = _t);
      }
    },
    hostVars: 4,
    hostBindings: function FlatColorPickerHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-coloreditor-header", ctx.hostClasses)("k-hstack", ctx.hostClasses);
      }
    },
    inputs: {
      clearButton: "clearButton",
      activeView: "activeView",
      views: "views",
      preview: "preview",
      innerTabIndex: "innerTabIndex",
      value: "value",
      selection: "selection",
      size: "size"
    },
    outputs: {
      viewChange: "viewChange",
      valuePaneClick: "valuePaneClick",
      clearButtonClick: "clearButtonClick",
      tabOut: "tabOut"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c39,
    decls: 6,
    vars: 3,
    consts: [["viewButtons", ""], ["clearButton", ""], [1, "k-coloreditor-header-actions", "k-hstack"], ["class", "k-button-group k-button-group-flat", "role", "group", 4, "ngIf"], [1, "k-spacer"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "reset-color", "class", "k-coloreditor-reset", 3, "tabindex", "size", "svgIcon", "click", 4, "ngIf"], ["class", "k-coloreditor-preview k-vstack", "aria-hidden", "true", 4, "ngIf"], ["role", "group", 1, "k-button-group", "k-button-group-flat"], ["kendoButton", "", "type", "button", "fillMode", "flat", 3, "tabindex", "icon", "svgIcon", "size", "ngClass", "click", "keydown.shift.tab", 4, "ngFor", "ngForOf"], ["kendoButton", "", "type", "button", "fillMode", "flat", 3, "click", "keydown.shift.tab", "tabindex", "icon", "svgIcon", "size", "ngClass"], ["kendoButton", "", "type", "button", "fillMode", "flat", "icon", "reset-color", 1, "k-coloreditor-reset", 3, "click", "tabindex", "size", "svgIcon"], ["aria-hidden", "true", 1, "k-coloreditor-preview", "k-vstack"], [1, "k-coloreditor-preview-color", "k-color-preview"], [1, "k-coloreditor-current-color", "k-color-preview", 3, "click"]],
    template: function FlatColorPickerHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 2);
        ɵɵtemplate(1, FlatColorPickerHeaderComponent_div_1_Template, 2, 1, "div", 3);
        ɵɵelementEnd();
        ɵɵelement(2, "div", 4);
        ɵɵelementStart(3, "div", 2);
        ɵɵtemplate(4, FlatColorPickerHeaderComponent_button_4_Template, 2, 5, "button", 5)(5, FlatColorPickerHeaderComponent_div_5_Template, 3, 6, "div", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.viewButtons);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.clearButton);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.preview);
      }
    },
    dependencies: [NgIf, NgForOf, ButtonComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerHeaderComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoFlatColorPickerHeader]",
      template: `
        <div class="k-coloreditor-header-actions k-hstack">
            <div 
                *ngIf="viewButtons" 
                class="k-button-group k-button-group-flat"
                role="group"
            >
                <button 
                    *ngFor="let view of views; let i = index;"
                    kendoButton
                    type="button"
                    #viewButtons
                    fillMode="flat"
                    [tabindex]="innerTabIndex.toString()"
                    (click)="onViewButtonClick(view)"
                    [icon]="getViewButtonIcon(view)"
                    [svgIcon]="getViewButtonsSVGIcon(view)"
                    (keydown.shift.tab)="onHeaderTabOut($event, i)"
                    [size]="size"
                    [attr.title]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-label]="getText(view === 'gradient' ? 'gradientView' : 'paletteView')"
                    [attr.aria-pressed]="activeView === view"
                    [ngClass]="activeView === view ? 'k-selected' : ''">
                </button>
            </div>
        </div>
        <div class="k-spacer"></div>
        <div class="k-coloreditor-header-actions k-hstack">
            <button
                kendoButton
                type="button"
                [tabindex]="innerTabIndex.toString()"
                *ngIf="clearButton"
                #clearButton
                [size]="size"
                fillMode="flat"
                icon="reset-color"
                [svgIcon]="dropletSlashIcon"
                class="k-coloreditor-reset"
                [attr.aria-label]="getText('clearButton')"
                [attr.title]="getText('clearButton')"
                (click)="clearButtonClick.emit()">
            </button>
            <div class="k-coloreditor-preview k-vstack" *ngIf="preview" aria-hidden="true">
                <span
                    class="k-coloreditor-preview-color k-color-preview"
                    [attr.title]="getText('previewColor')"
                    [style.background-color]="selection">
                </span>
                <span class="k-coloreditor-current-color k-color-preview"
                    [style.background-color]="value"
                    [attr.title]="getText('revertSelection')"
                    (click)="valuePaneClick.emit($event)">
                </span>
            </div>
        </div>
    `,
      standalone: true,
      imports: [NgIf, NgForOf, ButtonComponent, NgClass]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Renderer2
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-coloreditor-header"]
    }, {
      type: HostBinding,
      args: ["class.k-hstack"]
    }],
    clearButton: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    innerTabIndex: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    viewChange: [{
      type: Output
    }],
    valuePaneClick: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    viewButtonsCollection: [{
      type: ViewChildren,
      args: ["viewButtons", {
        read: ElementRef
      }]
    }],
    clearButtonElement: [{
      type: ViewChild,
      args: ["clearButton", {
        read: ElementRef
      }]
    }]
  });
})();
var FlatColorPickerActionButtonsComponent = class _FlatColorPickerActionButtonsComponent {
  localizationService;
  hostClasses = true;
  innerTabIndex = -1;
  size;
  actionButtonClick = new EventEmitter();
  tabOut = new EventEmitter();
  firstButton;
  lastButton;
  constructor(localizationService) {
    this.localizationService = localizationService;
  }
  getText(text) {
    return this.localizationService.get(text);
  }
  onActionButtonClick(type, ev) {
    const args = {
      target: type,
      originalEvent: ev
    };
    this.actionButtonClick.emit(args);
  }
  static ɵfac = function FlatColorPickerActionButtonsComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerActionButtonsComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerActionButtonsComponent,
    selectors: [["", "kendoFlatColorPickerActionButtons", ""]],
    viewQuery: function FlatColorPickerActionButtonsComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c40, 5, ElementRef);
        ɵɵviewQuery(_c41, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.firstButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.lastButton = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function FlatColorPickerActionButtonsComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-coloreditor-footer", ctx.hostClasses)("k-actions", ctx.hostClasses)("k-actions-horizontal", ctx.hostClasses);
      }
    },
    inputs: {
      innerTabIndex: "innerTabIndex",
      size: "size"
    },
    outputs: {
      actionButtonClick: "actionButtonClick",
      tabOut: "tabOut"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    attrs: _c42,
    decls: 6,
    vars: 8,
    consts: [["first", ""], ["last", ""], ["kendoButton", "", "type", "button", 1, "k-coloreditor-cancel", 3, "click", "size", "tabindex"], ["kendoButton", "", "themeColor", "primary", "type", "button", 1, "k-coloreditor-apply", 3, "click", "keydown.tab", "size", "tabindex"]],
    template: function FlatColorPickerActionButtonsComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "button", 2, 0);
        ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onActionButtonClick("cancel", $event));
        });
        ɵɵtext(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "button", 3, 1);
        ɵɵlistener("click", function FlatColorPickerActionButtonsComponent_Template_button_click_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onActionButtonClick("apply", $event));
        })("keydown.tab", function FlatColorPickerActionButtonsComponent_Template_button_keydown_tab_3_listener($event) {
          ɵɵrestoreView(_r1);
          $event.preventDefault();
          return ɵɵresetView(ctx.tabOut.emit());
        });
        ɵɵtext(5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("size", ctx.size)("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.getText("cancelButton"));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.getText("cancelButton"));
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("tabindex", ctx.innerTabIndex.toString());
        ɵɵattribute("title", ctx.getText("applyButton"));
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx.getText("applyButton"));
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerActionButtonsComponent, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[kendoFlatColorPickerActionButtons]",
      template: `
        <button #first
            kendoButton
            class="k-coloreditor-cancel"
            [size]="size"
            [attr.title]="getText('cancelButton')"
            (click)="onActionButtonClick('cancel', $event)"
            type="button"
            [tabindex]="innerTabIndex.toString()"
        >{{getText('cancelButton')}}</button>
        <button #last
            kendoButton
            themeColor="primary"
            [size]="size"
            class="k-coloreditor-apply"
            [attr.title]="getText('applyButton')"
            (click)="onActionButtonClick('apply', $event)"
            type="button"
            [tabindex]="innerTabIndex.toString()"
            (keydown.tab)="$event.preventDefault(); tabOut.emit();"
        >{{getText('applyButton')}}</button>
    `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-coloreditor-footer"]
    }, {
      type: HostBinding,
      args: ["class.k-actions"]
    }, {
      type: HostBinding,
      args: ["class.k-actions-horizontal"]
    }],
    innerTabIndex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    actionButtonClick: [{
      type: Output
    }],
    tabOut: [{
      type: Output
    }],
    firstButton: [{
      type: ViewChild,
      args: ["first", {
        read: ElementRef
      }]
    }],
    lastButton: [{
      type: ViewChild,
      args: ["last", {
        read: ElementRef
      }]
    }]
  });
})();
var DEFAULT_SIZE$5 = "medium";
var FlatColorPickerComponent = class _FlatColorPickerComponent {
  host;
  service;
  localizationService;
  cdr;
  renderer;
  ngZone;
  injector;
  hostClasses = true;
  get disabledClass() {
    return this.disabled;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  direction;
  get hostTabindex() {
    return this.tabindex?.toString() || "0";
  }
  ariaRole = "textbox";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  get isDisabled() {
    return this.disabled?.toString() || void 0;
  }
  /**
   * @hidden
   */
  enterHandler(event) {
    if (event.target !== this.host.nativeElement) {
      return;
    }
    event.preventDefault();
    this.internalNavigation = true;
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.firstFocusable?.focus());
  }
  /**
   * @hidden
   */
  escapeHandler() {
    this.internalNavigation = false;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  focusHandler(ev) {
    this.internalNavigation = ev.target !== this.host.nativeElement;
  }
  /**
   * Sets the read-only state of the FlatColorPicker.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the FlatColorPicker. To disable it in reactive forms, see [Forms Support](slug:formssupport_flatcolorpicker#toc-managing-the-flatcolorpicker-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the output format of the FlatColorPicker.
   *
   * If the input value is in a different format, the component parses it into the specified output `format`.
   *
   * @default 'rgba'
   */
  format = "rgba";
  /**
   * Specifies the initially selected color.
   */
  set value(value) {
    this._value = parseColor2(value, this.format, this.gradientSettings.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    if (isPresent3(value)) {
      const tabindex = Number(value);
      this._tabindex = !isNaN(tabindex) ? tabindex : 0;
    } else {
      this._tabindex = value;
    }
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Specifies whether the FlatColorPicker displays a **Clear color** button.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Displays `Apply` and `Cancel` action buttons and a color preview pane.
   *
   * When enabled, the component value does not change immediately upon
   * color selection, but only after the **Apply** button is clicked.
   *
   * The **Cancel** button reverts the current selection to its
   * initial state, i.e., to the current value.
   *
   * @default true
   */
  preview = true;
  /**
   * Configures the layout of the `Apply` and `Cancel` action buttons.
   *
   * @default 'end'
   */
  actionsLayout = "end";
  /**
   * Sets the initially active view in the FlatColorPicker. Supports two-way binding.
   */
  activeView;
  /**
   * Specifies the views to render. The default value is gradient and palette.
   */
  views = ["gradient", "palette"];
  /**
   * Configures the gradient view.
   */
  set gradientSettings(value) {
    Object.assign(this._gradientSettings, value);
  }
  get gradientSettings() {
    return this._gradientSettings;
  }
  /**
   * @hidden
   */
  adaptiveMode = false;
  /**
   * Configures the palette view.
   */
  set paletteSettings(value) {
    Object.assign(this._paletteSettings, value);
  }
  get paletteSettings() {
    return this._paletteSettings;
  }
  /**
   * Sets the size of the FlatColorPicker internal elements.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$5;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Fires when the component value changes.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the user cancels the current color selection.
   *
   * The event is emitted on preview pane or on 'Cancel' button click.
   */
  cancel = new EventEmitter();
  /**
   * Fires when the view is about to change.
   * Used to provide a two-way binding for the `activeView` property.
   */
  activeViewChange = new EventEmitter();
  /**
   * @hidden
   * Fires each time the clear button is clicked.
   */
  clearButtonClick = new EventEmitter();
  /**
   * @hidden
   */
  actionButtonClick = new EventEmitter();
  header;
  headerElement;
  gradient;
  gradientElement;
  palette;
  footer;
  /**
   * @hidden
   */
  selection;
  focused;
  _value;
  _tabindex = 0;
  _gradientSettings = {
    opacity: true,
    delay: 0,
    gradientSliderStep: DRAGHANDLE_MOVE_SPEED,
    gradientSliderSmallStep: DRAGHANDLE_MOVE_SPEED_SMALL_STEP
  };
  _paletteSettings = {};
  dynamicRTLSubscription;
  subscriptions = new Subscription();
  internalNavigation = false;
  _size = "medium";
  control;
  /**
   * @hidden
   */
  get innerTabIndex() {
    return this.internalNavigation ? 0 : -1;
  }
  /**
   * @hidden
   */
  get firstFocusable() {
    if (this.headerHasContent) {
      return this.headerElement.nativeElement.querySelector(".k-button");
    }
    return this.activeView === "gradient" ? this.gradient : this.palette;
  }
  constructor(host, service, localizationService, cdr, renderer, ngZone, injector) {
    this.host = host;
    this.service = service;
    this.localizationService = localizationService;
    this.cdr = cdr;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.injector = injector;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnInit() {
    this.selection = this.value;
    this.control = this.injector.get(NgControl, null);
    this._paletteSettings = this.service.getPaletteSettings(this._paletteSettings, this.format);
    this.setActiveView();
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    this.initDomEvents();
    this.setSizingVariables();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => this.removeGradientAttributes());
  }
  ngOnChanges(changes) {
    if (isChanged("value", changes)) {
      this.selection = this.value;
      this.setHostElementAriaLabel();
    }
    if (isChanged("paletteSettings", changes)) {
      this.setSizingVariables();
    }
  }
  ngOnDestroy() {
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  focusFirstHeaderButton() {
    if (this.gradientElement.nativeElement === document.activeElement) {
      if (this.headerHasContent && !this.preview) {
        const firstHeaderButton = this.headerElement.nativeElement.querySelector(".k-button");
        firstHeaderButton.focus();
      }
    }
  }
  /**
   * @hidden
   */
  lastFocusable(event) {
    if (this.preview) {
      this.footer.lastButton.nativeElement.focus();
      return;
    }
    event.stopImmediatePropagation();
    const gradient = this.gradientElement?.nativeElement;
    const palette = this.palette?.host.nativeElement;
    this.activeView === "gradient" ? gradient.focus() : palette.focus();
  }
  /**
   * @hidden
   */
  onTab(ev) {
    const {
      shiftKey
    } = ev;
    const nextTabStop = this.preview ? this.footer.firstButton.nativeElement : this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : null;
    const previousTabStop = this.headerHasContent ? findFocusableChild(this.headerElement.nativeElement) : this.preview ? this.footer.lastButton.nativeElement : null;
    if (!nextTabStop && !previousTabStop) {
      return;
    }
    ev.preventDefault();
    shiftKey ? previousTabStop?.focus() : nextTabStop?.focus();
  }
  /**
   * @hidden
   */
  get headerHasContent() {
    return this.preview || this.views.length > 1 || this.clearButton;
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  /**
   * Focuses the wrapper of the FlatColorPicker.
   */
  focus() {
    if (this.disabled || this.focused) {
      return;
    }
    this.host.nativeElement.focus();
    this.focused = true;
  }
  /**
   * Blurs the wrapper of the FlatColorPicker.
   */
  blur() {
    if (!this.focused) {
      return;
    }
    this.notifyNgTouched();
    this.host.nativeElement.blur();
    this.focused = false;
  }
  /**
   * Clears the value of the FlatColorPicker.
   */
  reset() {
    if (!isPresent3(this.value)) {
      return;
    }
    this.value = void 0;
    this.notifyNgChanged(void 0);
    this.setHostElementAriaLabel();
  }
  /**
   * @hidden
   */
  onViewChange(view) {
    if (this.activeView === view) {
      return;
    }
    this.activeView = view;
    this.activeViewChange.emit(view);
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        this[this.activeView]?.focus();
      });
    });
    if (this.activeView === "gradient") {
      this.removeGradientAttributes();
    }
  }
  /**
   * @hidden
   */
  onClearButtonClick() {
    this.resetInnerComponentValue();
    this.clearButtonClick.emit();
  }
  /**
   * @hidden
   */
  handleValueChange(color) {
    this.preview ? this.changeCurrentValue(color) : this.setFlatColorPickerValue(color);
  }
  /**
   * @hidden
   */
  onAction(ev) {
    ev.target === "apply" ? this.setFlatColorPickerValue(this.selection) : this.resetSelection(ev.originalEvent);
    this.actionButtonClick.emit();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  resetSelection(ev) {
    const eventArgs = new ColorPickerCancelEvent(ev);
    this.cancel.emit(eventArgs);
    if (!eventArgs.isDefaultPrevented()) {
      this.selection = this.value;
    }
    this.notifyNgTouched();
  }
  setHostElementAriaLabel() {
    const parsed = parseColor2(this.value, this.format, this.gradientSettings.opacity);
    const ariaLabelValue = `${this.value ? parsed : this.localizationService.get("flatColorPickerNoColor")}`;
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", ariaLabelValue);
  }
  setSizingVariables() {
    const paletteTileSize = this.service.paletteTileLayout(this.paletteSettings.tileSize);
    const element = this.host.nativeElement.querySelector(".k-coloreditor-views.k-vstack");
    const cssProperties = [`--kendo-color-preview-columns: ${this.paletteSettings.columns};`];
    if (paletteTileSize.width) {
      cssProperties.push(`--kendo-color-preview-width: ${paletteTileSize.width}px;`);
    }
    if (paletteTileSize.height) {
      cssProperties.push(`--kendo-color-preview-height: ${paletteTileSize.height}px;`);
    }
    this.renderer.setProperty(element, "style", cssProperties.join(" "));
  }
  changeCurrentValue(color) {
    this.selection = color;
    this.notifyNgTouched();
  }
  resetInnerComponentValue() {
    this.selection = null;
    if (this.gradient) {
      this.gradient.reset();
      return;
    }
    this.palette.reset();
  }
  setFlatColorPickerValue(color) {
    if (this.value === color) {
      return;
    }
    this.value = color;
    this.valueChange.emit(color);
    this.notifyNgChanged(color);
    this.setHostElementAriaLabel();
  }
  setActiveView() {
    if (!isPresent3(this.activeView)) {
      this.activeView = this.views[0];
      return;
    }
    if (isDevMode() && this.views.indexOf(this.activeView) === -1) {
      throw new Error("Invalid configuration: The current activeView is not present in the views collection");
    }
  }
  notifyNgChanged = () => {
  };
  notifyNgTouched = () => {
  };
  initDomEvents() {
    if (!this.host) {
      return;
    }
    const hostElement = this.host.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focus", () => {
        this.focused = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "blur", () => {
        this.focused = false;
        this.notifyNgTouched();
      }));
    });
  }
  removeGradientAttributes() {
    this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, "role");
    this.gradientElement && this.renderer.removeAttribute(this.gradientElement.nativeElement, "aria-label");
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses("coloreditor", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function FlatColorPickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatColorPickerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FlatColorPickerService), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FlatColorPickerComponent,
    selectors: [["kendo-flatcolorpicker"]],
    viewQuery: function FlatColorPickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c43, 5);
        ɵɵviewQuery(_c43, 5, ElementRef);
        ɵɵviewQuery(_c44, 5);
        ɵɵviewQuery(_c44, 5, ElementRef);
        ɵɵviewQuery(_c45, 5);
        ɵɵviewQuery(_c46, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradient = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.gradientElement = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.palette = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footer = _t.first);
      }
    },
    hostVars: 14,
    hostBindings: function FlatColorPickerComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown.enter", function FlatColorPickerComponent_keydown_enter_HostBindingHandler($event) {
          return ctx.enterHandler($event);
        })("keydown.escape", function FlatColorPickerComponent_keydown_escape_HostBindingHandler() {
          return ctx.escapeHandler();
        })("focusin", function FlatColorPickerComponent_focusin_HostBindingHandler($event) {
          return ctx.focusHandler($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabled)("aria-readonly", ctx.ariaReadonly)("dir", ctx.direction)("tabindex", ctx.hostTabindex)("role", ctx.ariaRole)("aria-invalid", ctx.isControlInvalid);
        ɵɵclassProp("k-flatcolorpicker", ctx.hostClasses)("k-coloreditor", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      readonly: "readonly",
      disabled: "disabled",
      format: "format",
      value: "value",
      tabindex: "tabindex",
      clearButton: "clearButton",
      preview: "preview",
      actionsLayout: "actionsLayout",
      activeView: "activeView",
      views: "views",
      gradientSettings: "gradientSettings",
      adaptiveMode: "adaptiveMode",
      paletteSettings: "paletteSettings",
      size: "size"
    },
    outputs: {
      valueChange: "valueChange",
      cancel: "cancel",
      activeViewChange: "activeViewChange",
      clearButtonClick: "clearButtonClick",
      actionButtonClick: "actionButtonClick"
    },
    exportAs: ["kendoFlatColorPicker"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _FlatColorPickerComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _FlatColorPickerComponent)
    }, FlatColorPickerService, FlatColorPickerLocalizationService, {
      provide: LocalizationService,
      useExisting: FlatColorPickerLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.flatcolorpicker"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 6,
    vars: 4,
    consts: () => {
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_28 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_28 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29 = goog.getMsg("Colorgradient no color chosen");
        i18n_29 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_30 = goog.getMsg("Colorpalette no color chosen");
        i18n_30 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31 = goog.getMsg("Choose color");
        i18n_31 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_32 = goog.getMsg("Clear value");
        i18n_32 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.flatcolorpicker.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_33 = goog.getMsg("Set hue");
        i18n_33 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_34 = goog.getMsg("Set opacity");
        i18n_34 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_35 = goog.getMsg("Contrast ratio");
        i18n_35 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_36 = goog.getMsg("Color preview");
        i18n_36 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.flatcolorpicker.previewColor|The message for the color preview pane.:Color preview`;
      }
      let i18n_37;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_37 = goog.getMsg("Revert selection");
        i18n_37 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_37;
      } else {
        i18n_37 = $localize`:kendo.flatcolorpicker.revertSelection|The message for the selected color pane.:Revert selection`;
      }
      let i18n_38;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_38 = goog.getMsg("Gradient view");
        i18n_38 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_38;
      } else {
        i18n_38 = $localize`:kendo.flatcolorpicker.gradientView|The message for the gradient view button.:Gradient view`;
      }
      let i18n_39;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39 = goog.getMsg("Palette view");
        i18n_39 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_39;
      } else {
        i18n_39 = $localize`:kendo.flatcolorpicker.paletteView|The message for the palette view button.:Palette view`;
      }
      let i18n_40;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_40 = goog.getMsg("Change color format");
        i18n_40 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_40;
      } else {
        i18n_40 = $localize`:kendo.flatcolorpicker.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_41;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_41 = goog.getMsg("Apply");
        i18n_41 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_41;
      } else {
        i18n_41 = $localize`:kendo.flatcolorpicker.applyButton|The message for the Apply action button.:Apply`;
      }
      let i18n_42;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_42 = goog.getMsg("Cancel");
        i18n_42 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_42;
      } else {
        i18n_42 = $localize`:kendo.flatcolorpicker.cancelButton|The message for the Cancel action button.:Cancel`;
      }
      let i18n_43;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_43 = goog.getMsg("Red channel");
        i18n_43 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_43;
      } else {
        i18n_43 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_44;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_44 = goog.getMsg("Green channel");
        i18n_44 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_44;
      } else {
        i18n_44 = $localize`:kendo.flatcolorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_45;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_45 = goog.getMsg("Blue channel");
        i18n_45 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_45;
      } else {
        i18n_45 = $localize`:kendo.flatcolorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_46;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_46 = goog.getMsg("Alpha channel");
        i18n_46 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_46;
      } else {
        i18n_46 = $localize`:kendo.flatcolorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_47;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_47 = goog.getMsg("R");
        i18n_47 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_47;
      } else {
        i18n_47 = $localize`:kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_48;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_48 = goog.getMsg("G");
        i18n_48 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_48;
      } else {
        i18n_48 = $localize`:kendo.flatcolorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_49;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_49 = goog.getMsg("B");
        i18n_49 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_49;
      } else {
        i18n_49 = $localize`:kendo.flatcolorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_50;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_50 = goog.getMsg("HEX");
        i18n_50 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_50;
      } else {
        i18n_50 = $localize`:kendo.flatcolorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["header", ""], ["gradient", ""], ["palette", ""], ["footer", ""], ["kendoFlatColorPickerLocalizedMessages", "", "flatColorPickerNoColor", i18n_28, "colorGradientNoColor", i18n_29, "colorPaletteNoColor", i18n_30, "colorGradientHandle", i18n_31, "clearButton", i18n_32, "hueSliderHandle", i18n_33, "opacitySliderHandle", i18n_34, "contrastRatio", i18n_35, "previewColor", i18n_36, "revertSelection", i18n_37, "gradientView", i18n_38, "paletteView", i18n_39, "formatButton", i18n_40, "applyButton", i18n_41, "cancelButton", i18n_42, "redChannelLabel", i18n_43, "greenChannelLabel", i18n_44, "blueChannelLabel", i18n_45, "alphaChannelLabel", i18n_46, "redChannelLabel", i18n_47, "greenInputPlaceholder", i18n_48, "blueInputPlaceholder", i18n_49, "hexInputPlaceholder", i18n_50], ["kendoFlatColorPickerHeader", "", 3, "innerTabIndex", "clearButton", "activeView", "views", "size", "value", "selection", "preview", "clearButtonClick", "viewChange", "valuePaneClick", "tabOut", 4, "ngIf"], [1, "k-coloreditor-views", "k-vstack"], [3, "tabindex", "value", "size", "adaptiveMode", "format", "opacity", "delay", "contrastTool", "gradientSliderSmallStep", "gradientSliderStep", "readonly", "keydown.tab", "valueChange", 4, "ngIf"], [3, "tabindex", "palette", "size", "columns", "tileSize", "format", "value", "readonly", "valueChange", 4, "ngIf"], ["kendoFlatColorPickerActionButtons", "", 3, "innerTabIndex", "size", "ngClass", "actionButtonClick", "tabOut", 4, "ngIf"], ["kendoFlatColorPickerHeader", "", 3, "clearButtonClick", "viewChange", "valuePaneClick", "tabOut", "innerTabIndex", "clearButton", "activeView", "views", "size", "value", "selection", "preview"], [3, "keydown.tab", "valueChange", "tabindex", "value", "size", "adaptiveMode", "format", "opacity", "delay", "contrastTool", "gradientSliderSmallStep", "gradientSliderStep", "readonly"], [3, "valueChange", "tabindex", "palette", "size", "columns", "tileSize", "format", "value", "readonly"], ["kendoFlatColorPickerActionButtons", "", 3, "actionButtonClick", "tabOut", "innerTabIndex", "size", "ngClass"]];
    },
    template: function FlatColorPickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 4);
        ɵɵtemplate(1, FlatColorPickerComponent_div_1_Template, 2, 8, "div", 5);
        ɵɵelementStart(2, "div", 6);
        ɵɵtemplate(3, FlatColorPickerComponent_kendo_colorgradient_3_Template, 2, 11, "kendo-colorgradient", 7)(4, FlatColorPickerComponent_kendo_colorpalette_4_Template, 2, 8, "kendo-colorpalette", 8);
        ɵɵelementEnd();
        ɵɵtemplate(5, FlatColorPickerComponent_div_5_Template, 2, 3, "div", 9);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.headerHasContent);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.activeView === "gradient");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.activeView === "palette");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.preview && !ctx.adaptiveMode);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, NgClass],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatColorPickerComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoFlatColorPicker",
      selector: "kendo-flatcolorpicker",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => FlatColorPickerComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => FlatColorPickerComponent)
      }, FlatColorPickerService, FlatColorPickerLocalizationService, {
        provide: LocalizationService,
        useExisting: FlatColorPickerLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.flatcolorpicker"
      }],
      template: `
        <ng-container kendoFlatColorPickerLocalizedMessages
            i18n-flatColorPickerNoColor="kendo.flatcolorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.flatcolorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.flatcolorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.flatcolorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.flatcolorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.flatcolorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.flatcolorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.flatcolorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.flatcolorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.flatcolorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.flatcolorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.flatcolorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.flatcolorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.flatcolorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.flatcolorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel"
            i18n-redChannelLabel="kendo.flatcolorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.flatcolorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.flatcolorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.flatcolorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.flatcolorpicker.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.flatcolorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.flatcolorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.flatcolorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <div kendoFlatColorPickerHeader
            [innerTabIndex]="innerTabIndex"
            *ngIf="headerHasContent"
            #header
            [clearButton]="clearButton"
            [activeView]="activeView"
            [views]="views"
            [size]="size"
            [value]="value"
            [selection]="selection"
            [preview]="preview"
            (clearButtonClick)="onClearButtonClick()"
            (viewChange)="onViewChange($event)"
            (valuePaneClick)="resetSelection($event)"
            (tabOut)="lastFocusable($event)"></div>
        <div class="k-coloreditor-views k-vstack">
            <kendo-colorgradient #gradient
                [tabindex]="innerTabIndex"
                *ngIf="activeView === 'gradient'"
                [value]="selection"
                [size]="size"
                [adaptiveMode]="adaptiveMode"
                [format]="format"
                [opacity]="gradientSettings.opacity"
                [delay]="gradientSettings.delay"
                [contrastTool]="gradientSettings.contrastTool"
                [gradientSliderSmallStep]="gradientSettings.gradientSliderSmallStep"
                [gradientSliderStep]="gradientSettings.gradientSliderStep"
                [readonly]="readonly"
                (keydown.tab)="focusFirstHeaderButton()"
                (valueChange)="handleValueChange($event)"
            ></kendo-colorgradient>
            <kendo-colorpalette #palette
                [tabindex]="innerTabIndex"
                *ngIf="activeView === 'palette'"
                [palette]="paletteSettings.palette"
                [size]="size"
                [columns]="paletteSettings.columns"
                [tileSize]="paletteSettings.tileSize"
                [format]="format"
                [value]="selection"
                [readonly]="readonly"
                (valueChange)="handleValueChange($event)"
            ></kendo-colorpalette>
        </div>
        <div *ngIf="preview && !adaptiveMode"
            #footer
            kendoFlatColorPickerActionButtons
            [innerTabIndex]="innerTabIndex"
            [size]="size"
            [ngClass]="'k-justify-content-' + actionsLayout"
            (actionButtonClick)="onAction($event)"
            (tabOut)="firstFocusable.focus()">
        </div>
`,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgIf, FlatColorPickerHeaderComponent, ColorGradientComponent, ColorPaletteComponent, FlatColorPickerActionButtonsComponent, NgClass]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FlatColorPickerService
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: Injector
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-flatcolorpicker"]
    }, {
      type: HostBinding,
      args: ["class.k-coloreditor"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    enterHandler: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }],
    escapeHandler: [{
      type: HostListener,
      args: ["keydown.escape"]
    }],
    focusHandler: [{
      type: HostListener,
      args: ["focusin", ["$event"]]
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    disabled: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    views: [{
      type: Input
    }],
    gradientSettings: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    paletteSettings: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    cancel: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    actionButtonClick: [{
      type: Output
    }],
    header: [{
      type: ViewChild,
      args: ["header"]
    }],
    headerElement: [{
      type: ViewChild,
      args: ["header", {
        read: ElementRef
      }]
    }],
    gradient: [{
      type: ViewChild,
      args: ["gradient"]
    }],
    gradientElement: [{
      type: ViewChild,
      args: ["gradient", {
        read: ElementRef
      }]
    }],
    palette: [{
      type: ViewChild,
      args: ["palette"]
    }],
    footer: [{
      type: ViewChild,
      args: ["footer"]
    }]
  });
})();
var animationDuration = 300;
var AdaptiveCloseButtonComponent = class _AdaptiveCloseButtonComponent {
  title;
  icon;
  svgIcon;
  color;
  close = new EventEmitter();
  static ɵfac = function AdaptiveCloseButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveCloseButtonComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveCloseButtonComponent,
    selectors: [["kendo-adaptive-close-button"]],
    inputs: {
      title: "title",
      icon: "icon",
      svgIcon: "svgIcon",
      color: "color"
    },
    outputs: {
      close: "close"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 1,
    vars: 5,
    consts: [["kendoButton", "", "type", "button", "fillMode", "flat", "size", "large", 3, "click", "title", "icon", "svgIcon", "themeColor", "tabIndex"]],
    template: function AdaptiveCloseButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "button", 0);
        ɵɵlistener("click", function AdaptiveCloseButtonComponent_Template_button_click_0_listener($event) {
          return ctx.close.emit($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("title", ctx.title)("icon", ctx.icon)("svgIcon", ctx.svgIcon)("themeColor", ctx.color)("tabIndex", -1);
      }
    },
    dependencies: [ButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveCloseButtonComponent, [{
    type: Component,
    args: [{
      selector: "kendo-adaptive-close-button",
      template: `
        <button kendoButton
            type="button"
            [title]="title"
            [icon]="icon"
            [svgIcon]="svgIcon"
            [themeColor]="color"
            fillMode="flat"
            size="large"
            [tabIndex]="-1"
            (click)="close.emit($event)"
        ></button>
    `,
      standalone: true,
      imports: [ButtonComponent]
    }]
  }], null, {
    title: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    close: [{
      type: Output
    }]
  });
})();
var AdaptiveRendererComponent = class _AdaptiveRendererComponent {
  localization;
  adaptiveService;
  title;
  subtitle;
  actionSheetTemplate;
  isActionSheetExpanded;
  preview;
  actionSheetClose = new EventEmitter();
  onExpand = new EventEmitter();
  onCollapse = new EventEmitter();
  onApply = new EventEmitter();
  onCancel = new EventEmitter();
  actionSheet;
  actionSheetSearchBar;
  cancelButton;
  applyButton;
  constructor(localization, adaptiveService) {
    this.localization = localization;
    this.adaptiveService = adaptiveService;
  }
  animationDuration = animationDuration;
  checkIcon = checkIcon;
  messageFor(key) {
    return this.localization.get(key);
  }
  get windowSize() {
    return this.adaptiveService.size;
  }
  static ɵfac = function AdaptiveRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveRendererComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveRendererComponent,
    selectors: [["kendo-adaptive-renderer"]],
    viewQuery: function AdaptiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ActionSheetComponent, 5);
        ɵɵviewQuery(_c47, 5);
        ɵɵviewQuery(_c48, 5);
        ɵɵviewQuery(_c49, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cancelButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.applyButton = _t.first);
      }
    },
    inputs: {
      title: "title",
      subtitle: "subtitle",
      actionSheetTemplate: "actionSheetTemplate",
      isActionSheetExpanded: "isActionSheetExpanded",
      preview: "preview"
    },
    outputs: {
      actionSheetClose: "actionSheetClose",
      onExpand: "onExpand",
      onCollapse: "onCollapse",
      onApply: "onApply",
      onCancel: "onCancel"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 11,
    consts: [["actionSheet", ""], ["cancel", ""], ["apply", ""], [3, "overlayClick", "expand", "collapse", "animation", "expanded", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [1, "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], [1, "k-text-center"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["icon", "check", "color", "primary", 3, "close", "title", "svgIcon"], [1, "k-actionsheet-content"], [4, "ngTemplateOutlet"], ["class", "k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer", 4, "ngIf"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actions", "k-actions-stretched", "k-actions-horizontal", "k-actionsheet-footer"], ["kendoButton", "", "size", "large", 3, "click", "title"], ["kendoButton", "", "size", "large", "themeColor", "primary", 3, "click", "title"]],
    template: function AdaptiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 3, 0);
        ɵɵlistener("overlayClick", function AdaptiveRendererComponent_Template_kendo_actionsheet_overlayClick_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.actionSheetClose.emit());
        })("expand", function AdaptiveRendererComponent_Template_kendo_actionsheet_expand_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onExpand.emit());
        })("collapse", function AdaptiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onCollapse.emit());
        });
        ɵɵtemplate(2, AdaptiveRendererComponent_ng_template_2_Template, 11, 6, "ng-template", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("animation", ɵɵpureFunction1(4, _c50, ctx.animationDuration))("expanded", ctx.isActionSheetExpanded)("cssClass", ɵɵpureFunction2(6, _c51, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(9, _c52, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, NgTemplateOutlet, AdaptiveCloseButtonComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveRendererComponent, [{
    type: Component,
    args: [{
      selector: "kendo-adaptive-renderer",
      template: `
        <kendo-actionsheet
            #actionSheet
            [animation]="{ duration: animationDuration }"
            [expanded]="isActionSheetExpanded"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
            (overlayClick)="actionSheetClose.emit()"
            (expand)="onExpand.emit()"
            (collapse)="onCollapse.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title || messageFor('adaptiveTitle') }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="subtitle">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <kendo-adaptive-close-button
                                icon="check"
                                color="primary"
                                [title]="messageFor('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                (close)="actionSheetClose.emit($event)">
                            </kendo-adaptive-close-button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <ng-container *ngTemplateOutlet="actionSheetTemplate"></ng-container>
                </div>
                <div *ngIf="preview" class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button 
                        #cancel
                        kendoButton
                        size="large"
                        (click)="onCancel.emit($event)"
                        [title]="messageFor('cancelButton')">
                        {{messageFor('cancelButton')}}
                    </button>
                    <button
                        #apply
                        kendoButton
                        size="large"
                        themeColor="primary"
                        (click)="onApply.emit()"
                        [title]="messageFor('applyButton')">
                        {{messageFor('applyButton')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, NgTemplateOutlet, AdaptiveCloseButtonComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: AdaptiveService
    }];
  }, {
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    actionSheetTemplate: [{
      type: Input
    }],
    isActionSheetExpanded: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionSheetClose: [{
      type: Output
    }],
    onExpand: [{
      type: Output
    }],
    onCollapse: [{
      type: Output
    }],
    onApply: [{
      type: Output
    }],
    onCancel: [{
      type: Output
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    actionSheetSearchBar: [{
      type: ViewChild,
      args: ["actionSheetSearchBar"]
    }],
    cancelButton: [{
      type: ViewChild,
      args: ["cancel"]
    }],
    applyButton: [{
      type: ViewChild,
      args: ["apply"]
    }]
  });
})();
var DOM_FOCUS_EVENTS = ["focus", "blur"];
var DEFAULT_SIZE$4 = "medium";
var DEFAULT_ROUNDED$3 = "medium";
var DEFAULT_FILL_MODE$3 = "solid";
var nextColorPickerId = 0;
var ColorPickerComponent = class _ColorPickerComponent {
  host;
  popupService;
  cdr;
  localizationService;
  ngZone;
  renderer;
  injector;
  adaptiveService;
  hostClasses = true;
  get focusedClass() {
    return this.isFocused;
  }
  get disabledClass() {
    return this.disabled;
  }
  get ariaReadonly() {
    return this.readonly;
  }
  get ariaExpanded() {
    return this.isOpen;
  }
  get hostTabindex() {
    return this.tabindex;
  }
  direction;
  role = "combobox";
  hasPopup = "dialog";
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  /**
   * @hidden
   */
  focusableId;
  /**
   * Specifies the views rendered in the popup.
   * By default, both the gradient and palette views are rendered.
   */
  views = ["gradient", "palette"];
  /**
   * @hidden
   */
  set view(view) {
    this.views = [view];
  }
  get view() {
    return this.views && this.views.length > 0 ? this.views[0] : null;
  }
  /**
   * Enables or disables the adaptive mode.
   * By default, adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the initially active view in the popup. Supports two-way binding.
   */
  activeView;
  /**
   * Sets the read-only state of the ColorPicker.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the ColorPicker. To disable it in reactive forms, see [Forms Support](slug:formssupport_colorpicker#toc-managing-the-colorpicker-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Specifies the output format of the ColorPicker.
   *
   * If the input value is in a different format, the component parses it into the specified output `format`.
   *
   * @default 'rgba'
   */
  format = "rgba";
  /**
   * Sets the value of the selected color.
   */
  set value(value) {
    this._value = parseColor2(value, this.format, this.gradientSettings.opacity);
  }
  get value() {
    return this._value;
  }
  /**
   * Configures the popup of the ColorPicker.
   */
  set popupSettings(value) {
    this._popupSettings = Object.assign(this._popupSettings, value);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Configures the palette displayed in the ColorPicker popup.
   */
  set paletteSettings(value) {
    this._paletteSettings = Object.assign(this._paletteSettings, value);
  }
  get paletteSettings() {
    return this._paletteSettings;
  }
  /**
   * Configures the gradient displayed in the ColorPicker popup.
   */
  set gradientSettings(value) {
    this._gradientSettings = Object.assign(this._gradientSettings, value);
  }
  get gradientSettings() {
    return this._gradientSettings;
  }
  /**
   * Defines the name of an existing icon in the Kendo UI theme.
   * Provide only the name of the icon without the `k-icon` or `k-i-` prefixes.
   */
  icon;
  /**
   * A CSS class name which displays an icon in the ColorPicker button.
   * `iconClass` is compatible with the `ngClass` syntax.
   *
   * Takes precedence over `icon` if both are defined.
   */
  iconClass;
  /**
   * Defines an SVGIcon to render within the button.
   * The input can take either an existing Kendo SVG icon or a custom one.
   */
  set svgIcon(icon) {
    if (isDevMode() && icon && this.icon && this.iconClass) {
      throw new Error("Setting both icon/svgIcon and iconClass options at the same time is not supported.");
    }
    this._svgIcon = icon;
  }
  get svgIcon() {
    return this._svgIcon;
  }
  /**
   * Sets the title of the ActionSheet rendered instead of the Popup on small screens.
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle of the ActionSheet rendered instead of the Popup on small screens.
   * By default, the ActionSheet does not render a subtitle.
   */
  adaptiveSubtitle;
  /**
   * Specifies whether the ColorPicker displays a **Clear color** button.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Displays **Apply** and **Cancel** action buttons and color preview panes.
   *
   * When enabled, the component value does not change immediately upon
   * color selection, but only after the **Apply** button is clicked.
   *
   * The **Cancel** button reverts the current selection to its
   * previous state, i.e., to the current value.
   *
   * @default false
   */
  preview = false;
  /**
   * Configures the layout of the **Apply** and **Cancel** action buttons.
   *
   * @default 'end'
   */
  actionsLayout = "end";
  /**
   * The size property specifies the padding of the ColorPicker internal elements
   * ([see example]({% slug appearance_colorpicker %}#toc-size)).
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE$4;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * The rounded property specifies the border radius of the ColorPicker
   * ([see example](slug:appearance_colorpicker#toc-roundness)).
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded || DEFAULT_ROUNDED$3;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * The fillMode property specifies the background and border styles of the ColorPicker
   * ([see example]({% slug appearance_colorpicker %}#toc-fill-mode)).
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode || DEFAULT_FILL_MODE$3;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Fires when the value changes.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the Popup (or ActionSheet in adaptive mode) is about to open.
   * This event is preventable. If you cancel it, the Popup (or the ActionSheet) remains closed.
   */
  open = new EventEmitter();
  /**
   * Fires when the Popup (or ActionSheet in adaptive mode) is about to close.
   * This event is preventable. If you cancel it, the Popup (or the ActionSheet) remains open.
   */
  close = new EventEmitter();
  /**
   * Fires when the ColorPicker is focused.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the ColorPicker is blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the user cancels the current color selection.
   *
   * Fires on preview pane or 'Cancel' button click.
   */
  cancel = new EventEmitter();
  /**
   * Fires when the left side of the ColorPicker wrapper is clicked.
   * The event is triggered regardless of whether a ColorPicker icon is set or not.
   *
   * The [`ActiveColorClickEvent`]({% slug api_inputs_activecolorclickevent %}) event provides the option to prevent the popup opening.
   */
  activeColorClick = new EventEmitter();
  /**
   * @hidden
   * Fires when the clear button is clicked.
   */
  clearButtonClick = new EventEmitter();
  /**
   * Fires when the view is about to change.
   * Used to provide a two-way binding for the `activeView` property.
   */
  activeViewChange = new EventEmitter();
  /**
   * Indicates whether the ColorPicker wrapper is focused.
   */
  isFocused = false;
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * Returns the current open state. Returns `true` if the Popup (or ActionSheet in adaptive mode) is currently open.
   */
  get isOpen() {
    return isPresent3(this.popupRef) || this.isActionSheetExpanded;
  }
  /**
   * @hidden
   */
  get customIconStyles() {
    if (this.iconClass) {
      let parsedIconClass = "";
      parseCSSClassNames(this.iconClass).forEach((iconClass) => {
        parsedIconClass += iconClass + " ";
      });
      return parsedIconClass.slice(0, -1);
    }
    return "";
  }
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRenderer?.actionSheet;
  }
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return Boolean(this.actionSheet?.expanded);
  }
  /**
   * @hidden
   */
  get iconStyles() {
    if (this.icon && !this.iconClass) {
      return `${this.icon}`;
    }
    return "";
  }
  /**
   * Provides a reference to a container element inside the component markup.
   * The container element references the location of the appended popup&mdash;
   * for example, inside the component markup.
   */
  container;
  activeColor;
  popupTemplate;
  flatColorPicker;
  /**
   * @hidden
   */
  adaptiveRenderer;
  /**
   * @hidden
   */
  arrowDownIcon = caretAltDownIcon;
  popupRef;
  _svgIcon;
  _value;
  _tabindex = 0;
  _popupSettings = {
    animate: true
  };
  _paletteSettings = {};
  _gradientSettings = {
    opacity: true,
    delay: 0
  };
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  dynamicRTLSubscription;
  subscriptions = new Subscription();
  popupSubs = new Subscription();
  colorPickerId;
  control;
  constructor(host, popupService, cdr, localizationService, ngZone, renderer, injector, adaptiveService) {
    this.host = host;
    this.popupService = popupService;
    this.cdr = cdr;
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata2);
    this.dynamicRTLSubscription = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.colorPickerId = nextColorPickerId++;
  }
  ngOnInit() {
    const defaultPreset = this.format !== "name" ? DEFAULT_PRESET$1 : DEFAULT_ACCESSIBLE_PRESET$1;
    const settingsPalette = this._paletteSettings.palette;
    const presetColumns = typeof settingsPalette === "string" && PALETTEPRESETS[settingsPalette] ? PALETTEPRESETS[settingsPalette].columns : void 0;
    this._paletteSettings = {
      palette: settingsPalette || defaultPreset,
      tileSize: this._paletteSettings.tileSize,
      columns: this._paletteSettings.columns || presetColumns || 10
    };
    this.handleHostId();
    this.renderer.setAttribute(this.host.nativeElement, "aria-controls", `k-colorpicker-popup-${this.colorPickerId}`);
    this.control = this.injector.get(NgControl, null);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    this.setHostElementAriaLabel();
    this.initDomEvents();
    this.windowSize = this.adaptiveService.size;
    if (this.actionSheet && isDocumentAvailable()) {
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-height", "60vh");
      this.actionSheet.element.nativeElement.style.setProperty("--kendo-actionsheet-max-height", "none");
    }
  }
  ngOnChanges(changes) {
    if (changes.format && changes.format.currentValue === "name") {
      this.activeView = "palette";
    }
    if (this.activeView === "gradient" && this.gradientSettings.opacity) {
      this.format = "rgba";
      this.value = parseColor2(this.value, this.format, this.gradientSettings.opacity);
    }
    if (isChanged("value", changes)) {
      this.setHostElementAriaLabel();
    }
  }
  ngOnDestroy() {
    this.closePopup();
    if (this.dynamicRTLSubscription) {
      this.dynamicRTLSubscription.unsubscribe();
    }
    this.subscriptions.unsubscribe();
    this.handleDomEvents("remove", DOM_FOCUS_EVENTS);
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.toggleWithEvents(false);
      }
      this.windowSize = currentWindowSize;
    }
  }
  /**
   * @hidden
   */
  handleCancelEvent(ev) {
    this.cancel.emit(ev);
  }
  /**
   * @hidden
   */
  togglePopup() {
    if (!this.isActionSheetExpanded) {
      this.focus();
      this.toggleWithEvents(!this.isOpen);
    }
  }
  /**
   * @hidden
   */
  handleWrapperClick(event) {
    if (this.disabled) {
      return;
    }
    this.focus();
    if (closest(event.target, (element) => element === this.activeColor.nativeElement)) {
      const event2 = new ActiveColorClickEvent(this.value);
      this.activeColorClick.emit(event2);
      if (!event2.isOpenPrevented() || this.isOpen) {
        this.toggleWithEvents(!this.isOpen);
      }
      return;
    }
    if (!this.isActionSheetExpanded) {
      this.toggleWithEvents(!this.isOpen);
    }
  }
  /**
   * Focuses the wrapper of the ColorPicker.
   */
  focus() {
    this.isFocused = true;
    this.host.nativeElement.focus();
  }
  /**
   * @hidden
   */
  handleWrapperFocus() {
    if (this.isFocused) {
      return;
    }
    this.ngZone.run(() => {
      this.focus();
      this.onFocus.emit();
    });
  }
  /**
   * Blurs the ColorPicker.
   */
  blur() {
    this.isFocused = false;
    this.host.nativeElement.blur();
    this.notifyNgTouched();
  }
  /**
   * @hidden
   */
  handleWrapperBlur() {
    if (!this.isActionSheetExpanded) {
      if (this.isOpen) {
        return;
      }
      this.ngZone.run(() => {
        this.onBlur.emit();
        this.isFocused = false;
      });
    }
  }
  /**
   * Clears the value of the ColorPicker.
   */
  reset() {
    if (!isPresent3(this.value)) {
      return;
    }
    this._value = void 0;
    this.setHostElementAriaLabel();
    this.notifyNgChanged(void 0);
  }
  /**
   * Toggles the Popup (or ActionSheet in adaptive mode) of the ColorPicker.
   * Does not trigger the `open` and `close` events of the component.
   *
   * @param open An optional parameter. Specifies whether the popup will be opened or closed.
   */
  toggle(open) {
    this.windowSize = this.adaptiveService.size;
    if (this.disabled || this.readonly) {
      return;
    }
    this.cdr.markForCheck();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    } else {
      this.closePopup();
    }
    open = isPresent3(open) ? open : !this.isOpen;
    if (open) {
      if (this.isAdaptive && !this.isActionSheetExpanded) {
        this.openActionSheet();
      } else {
        this.openPopup();
      }
      this.focusFirstElement();
    }
  }
  /**
   * @hidden
   */
  handleValueChange(color) {
    const parsedColor = parseColor2(color, this.format, this.gradientSettings.opacity);
    const valueChange = parsedColor !== this.value;
    if (valueChange) {
      this.value = parsedColor;
      this.valueChange.emit(parsedColor);
      this.setHostElementAriaLabel();
      this.notifyNgChanged(parsedColor);
    }
  }
  /**
   * @hidden
   */
  handlePopupBlur(event) {
    if (!this.isActionSheetExpanded) {
      if (this.popupBlurInvalid(event)) {
        return;
      }
      this.isFocused = false;
      this.onBlur.emit();
      this.notifyNgTouched();
      this.toggleWithEvents(false);
    }
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  handleWrapperKeyDown(event) {
    if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.Enter) {
      event.preventDefault();
      this.ngZone.run(() => {
        this.toggleWithEvents(true);
      });
    }
  }
  /**
   * @hidden
   */
  applyValue() {
    this.handleValueChange(this.flatColorPicker.selection);
    this.toggleWithEvents(false);
  }
  /**
   * @hidden
   */
  cancelValue(e) {
    this.flatColorPicker.resetSelection(e);
    this.toggleWithEvents(false);
  }
  /**
   * @hidden
   */
  onActionSheetClose(e) {
    if (this.preview) {
      this.cancelValue(e);
    } else {
      this.applyValue();
    }
  }
  /**
   * @hidden
   */
  handlePopupKeyDown(event) {
    if (event.keyCode === Keys.Escape) {
      this.toggleWithEvents(false);
      this.host.nativeElement.focus();
    }
    if (event.keyCode === Keys.Tab) {
      const currentElement = event.shiftKey ? this.firstFocusableElement.nativeElement : this.lastFocusableElement.nativeElement;
      const nextElement = event.shiftKey ? this.lastFocusableElement.nativeElement : this.firstFocusableElement.nativeElement;
      if (event.target === currentElement) {
        event.preventDefault();
        nextElement.focus();
      }
    }
  }
  /**
   * @hidden
   * Used by the FloatingLabel to determine if the component is empty.
   */
  isEmpty() {
    return false;
  }
  setHostElementAriaLabel() {
    const ariaLabelValue = `${this.value ? this.value : this.localizationService.get("colorPickerNoColor")}`;
    this.renderer.setAttribute(this.host.nativeElement, "aria-label", ariaLabelValue);
  }
  handleClasses(value, input) {
    const elem = this.host.nativeElement;
    const classes = getStylingClasses("picker", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  popupBlurInvalid(ev) {
    const focusInFlatColorPickerElement = this.popupRef?.popupElement?.contains(ev.relatedTarget);
    const hostClicked = closest(ev.relatedTarget, (element) => element === this.host.nativeElement);
    return Boolean(hostClicked || focusInFlatColorPickerElement);
  }
  toggleWithEvents(open) {
    const sameState = this.isOpen === open;
    if (this.disabled || this.readonly || sameState) {
      return;
    }
    let eventArgs;
    if (open) {
      eventArgs = new ColorPickerOpenEvent();
      this.open.emit(eventArgs);
    } else {
      eventArgs = new ColorPickerCloseEvent();
      this.close.emit(eventArgs);
    }
    if (!eventArgs.isDefaultPrevented()) {
      this.toggle(open);
    }
    if (open) {
      this.focusFirstElement();
    }
  }
  focusFirstElement() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      if (this.flatColorPicker) {
        const gradientDragHandle = this.flatColorPicker.gradient?.gradientDragHandle;
        const palette = this.flatColorPicker.palette?.host;
        const elementToFocus = gradientDragHandle ? gradientDragHandle : palette;
        elementToFocus.nativeElement.focus();
      }
    });
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.focus();
  }
  openPopup() {
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    this.popupRef = this.popupService.open({
      anchor: this.activeColor,
      animate: this.popupSettings.animate,
      appendTo: this.popupSettings.appendTo,
      popupAlign: popupPosition,
      anchorAlign: anchorPosition,
      popupClass: "k-colorpicker-popup",
      content: this.popupTemplate,
      positionMode: "absolute"
    });
    this.renderer.setAttribute(this.popupRef.popupElement.querySelector(".k-colorpicker-popup"), "id", `k-colorpicker-popup-${this.colorPickerId}`);
    this.popupSubs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.toggleWithEvents(false);
      if (!this.isOpen) {
        this.host.nativeElement.focus({
          preventScroll: true
        });
      }
    }));
  }
  closePopup() {
    if (!this.isOpen) {
      return;
    }
    this.popupSubs.unsubscribe();
    this.popupRef.close();
    this.popupRef = null;
  }
  get firstFocusableElement() {
    if (!this.flatColorPicker.header || this.views.length <= 1 && !this.flatColorPicker.clearButton) {
      const gradient = this.flatColorPicker.gradient;
      return gradient ? gradient.gradientDragHandle : this.flatColorPicker.palette.host;
    }
    return this.views.length > 1 ? this.flatColorPicker.header.viewButtonsCollection.toArray()[0] : this.flatColorPicker.header.clearButtonElement;
  }
  get lastFocusableElement() {
    if (this.preview) {
      return this.flatColorPicker.footer?.lastButton || this.adaptiveRenderer.applyButton.nativeElement;
    }
    if (this.flatColorPicker.palette) {
      return this.flatColorPicker.palette.host;
    }
    const gradient = this.flatColorPicker.gradient;
    const inputs = gradient && gradient.inputs;
    if (gradient && inputs && inputs.formatView === "hex") {
      return inputs.hexInput;
    }
    return this.gradientSettings.opacity ? inputs.opacityInput.numericInput : inputs.blueInput.numericInput;
  }
  notifyNgTouched = () => {
  };
  notifyNgChanged = () => {
  };
  handleDomEvents(action, events) {
    const hostElement = this.host.nativeElement;
    events.forEach((ev) => hostElement[`${action}EventListener`](ev, this.domFocusListener, true));
  }
  initDomEvents() {
    if (!this.host) {
      return;
    }
    const hostElement = this.host.nativeElement;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.handleWrapperFocus();
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (event) => {
        const closestPopup = this.popupRef ? closest(event.relatedTarget, (element) => element === this.flatColorPicker.host.nativeElement) : false;
        const closestWrapper = closest(event.relatedTarget, (element) => element === this.host.nativeElement);
        const closestActionSheet = this.isActionSheetExpanded ? closest(event.relatedTarget, (element) => element === this.actionSheet.element.nativeElement) : false;
        if (!closestPopup && !closestWrapper && !closestActionSheet) {
          this.handleWrapperBlur();
        }
      }));
      this.handleDomEvents("add", DOM_FOCUS_EVENTS);
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (event) => {
        this.handleWrapperKeyDown(event);
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "click", (event) => {
        this.ngZone.run(() => {
          !this.isActionSheetExpanded && this.handleWrapperClick(event);
        });
      }));
    });
  }
  domFocusListener = (event) => event.stopImmediatePropagation();
  handleHostId() {
    const hostElement = this.host.nativeElement;
    const existingId = hostElement.getAttribute("id");
    if (existingId) {
      this.focusableId = existingId;
    } else {
      const id2 = `k-${guid()}`;
      hostElement.setAttribute("id", id2);
      this.focusableId = id2;
    }
  }
  static ɵfac = function ColorPickerComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPickerComponent,
    selectors: [["kendo-colorpicker"]],
    viewQuery: function ColorPickerComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c53, 7, ViewContainerRef);
        ɵɵviewQuery(_c54, 7);
        ɵɵviewQuery(_c55, 7);
        ɵɵviewQuery(_c56, 5);
        ɵɵviewQuery(AdaptiveRendererComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.activeColor = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.flatColorPicker = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);
      }
    },
    hostVars: 20,
    hostBindings: function ColorPickerComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabledClass)("aria-readonly", ctx.ariaReadonly)("aria-expanded", ctx.ariaExpanded)("tabindex", ctx.hostTabindex)("dir", ctx.direction)("role", ctx.role)("aria-haspopup", ctx.hasPopup)("aria-invalid", ctx.isControlInvalid);
        ɵɵclassProp("k-colorpicker", ctx.hostClasses)("k-icon-picker", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-focus", ctx.focusedClass)("k-disabled", ctx.disabledClass)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      views: "views",
      view: "view",
      adaptiveMode: "adaptiveMode",
      activeView: "activeView",
      readonly: "readonly",
      disabled: "disabled",
      format: "format",
      value: "value",
      popupSettings: "popupSettings",
      paletteSettings: "paletteSettings",
      gradientSettings: "gradientSettings",
      icon: "icon",
      iconClass: "iconClass",
      svgIcon: "svgIcon",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      clearButton: "clearButton",
      tabindex: "tabindex",
      preview: "preview",
      actionsLayout: "actionsLayout",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      cancel: "cancel",
      activeColorClick: "activeColorClick",
      clearButtonClick: "clearButtonClick",
      activeViewChange: "activeViewChange"
    },
    exportAs: ["kendoColorPicker"],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _ColorPickerComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ColorPickerComponent)
    }, ColorPickerLocalizationService, {
      provide: LocalizationService,
      useExisting: ColorPickerLocalizationService
    }, {
      provide: L10N_PREFIX,
      useValue: "kendo.colorpicker"
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 13,
    vars: 17,
    consts: () => {
      let i18n_51;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_51 = goog.getMsg("Colorpicker no color chosen");
        i18n_51 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_51;
      } else {
        i18n_51 = $localize`:kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty.:Colorpicker no color chosen`;
      }
      let i18n_52;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_52 = goog.getMsg("Flatcolorpicker no color chosen");
        i18n_52 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_52;
      } else {
        i18n_52 = $localize`:kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty.:Flatcolorpicker no color chosen`;
      }
      let i18n_53;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_53 = goog.getMsg("Colorgradient no color chosen");
        i18n_53 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_53;
      } else {
        i18n_53 = $localize`:kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty.:Colorgradient no color chosen`;
      }
      let i18n_54;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54 = goog.getMsg("Colorpalette no color chosen");
        i18n_54 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_54;
      } else {
        i18n_54 = $localize`:kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty.:Colorpalette no color chosen`;
      }
      let i18n_55;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_55 = goog.getMsg("Choose color");
        i18n_55 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_55;
      } else {
        i18n_55 = $localize`:kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser.:Choose color`;
      }
      let i18n_56;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56 = goog.getMsg("Clear value");
        i18n_56 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_56;
      } else {
        i18n_56 = $localize`:kendo.colorpicker.clearButton|The title for the clear button.:Clear value`;
      }
      let i18n_57;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_57 = goog.getMsg("Set hue");
        i18n_57 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_57;
      } else {
        i18n_57 = $localize`:kendo.colorpicker.hueSliderHandle|The title for the hue slider handle.:Set hue`;
      }
      let i18n_58;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58 = goog.getMsg("Set opacity");
        i18n_58 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_58;
      } else {
        i18n_58 = $localize`:kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle.:Set opacity`;
      }
      let i18n_59;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_59 = goog.getMsg("Contrast ratio");
        i18n_59 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_59;
      } else {
        i18n_59 = $localize`:kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool.:Contrast ratio`;
      }
      let i18n_60;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60 = goog.getMsg("Color preview");
        i18n_60 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_60;
      } else {
        i18n_60 = $localize`:kendo.colorpicker.previewColor|The message for the color preview pane.:Color preview`;
      }
      let i18n_61;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_61 = goog.getMsg("Revert selection");
        i18n_61 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_61;
      } else {
        i18n_61 = $localize`:kendo.colorpicker.revertSelection|The message for the selected color pane.:Revert selection`;
      }
      let i18n_62;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62 = goog.getMsg("Gradient view");
        i18n_62 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_62;
      } else {
        i18n_62 = $localize`:kendo.colorpicker.gradientView|The message for the gradient view button.:Gradient view`;
      }
      let i18n_63;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_63 = goog.getMsg("Palette view");
        i18n_63 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_63;
      } else {
        i18n_63 = $localize`:kendo.colorpicker.paletteView|The message for the palette view button.:Palette view`;
      }
      let i18n_64;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64 = goog.getMsg("Change color format");
        i18n_64 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_64;
      } else {
        i18n_64 = $localize`:kendo.colorpicker.formatButton|The message for the input format toggle button.:Change color format`;
      }
      let i18n_65;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_65 = goog.getMsg("Apply");
        i18n_65 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_65;
      } else {
        i18n_65 = $localize`:kendo.colorpicker.applyButton|The message for the Apply action button.:Apply`;
      }
      let i18n_66;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66 = goog.getMsg("Cancel");
        i18n_66 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_66;
      } else {
        i18n_66 = $localize`:kendo.colorpicker.cancelButton|The message for the Cancel action button.:Cancel`;
      }
      let i18n_67;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_67 = goog.getMsg("Close");
        i18n_67 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_67;
      } else {
        i18n_67 = $localize`:kendo.colorpicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.:Close`;
      }
      let i18n_68;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68 = goog.getMsg("Choose Color");
        i18n_68 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_68;
      } else {
        i18n_68 = $localize`:kendo.colorpicker.adaptiveTitle|The title for the ActionSheet when in adaptive mode.:Choose Color`;
      }
      let i18n_69;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_69 = goog.getMsg("Red channel");
        i18n_69 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_69;
      } else {
        i18n_69 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:Red channel`;
      }
      let i18n_70;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70 = goog.getMsg("Green channel");
        i18n_70 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_70;
      } else {
        i18n_70 = $localize`:kendo.colorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel.:Green channel`;
      }
      let i18n_71;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_71 = goog.getMsg("Blue channel");
        i18n_71 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_71;
      } else {
        i18n_71 = $localize`:kendo.colorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel.:Blue channel`;
      }
      let i18n_72;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72 = goog.getMsg("Alpha channel");
        i18n_72 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_72;
      } else {
        i18n_72 = $localize`:kendo.colorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel.:Alpha channel`;
      }
      let i18n_73;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_73 = goog.getMsg("R");
        i18n_73 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_73;
      } else {
        i18n_73 = $localize`:kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel.:R`;
      }
      let i18n_74;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74 = goog.getMsg("G");
        i18n_74 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_74;
      } else {
        i18n_74 = $localize`:kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input.:G`;
      }
      let i18n_75;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_75 = goog.getMsg("B");
        i18n_75 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_75;
      } else {
        i18n_75 = $localize`:kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input.:B`;
      }
      let i18n_76;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76 = goog.getMsg("HEX");
        i18n_76 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_76;
      } else {
        i18n_76 = $localize`:kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input.:HEX`;
      }
      return [["activeColor", ""], ["popupTemplate", ""], ["container", ""], ["flatColorPicker", ""], ["kendoColorPickerLocalizedMessages", "", "colorPickerNoColor", i18n_51, "flatColorPickerNoColor", i18n_52, "colorGradientNoColor", i18n_53, "colorPaletteNoColor", i18n_54, "colorGradientHandle", i18n_55, "clearButton", i18n_56, "hueSliderHandle", i18n_57, "opacitySliderHandle", i18n_58, "contrastRatio", i18n_59, "previewColor", i18n_60, "revertSelection", i18n_61, "gradientView", i18n_62, "paletteView", i18n_63, "formatButton", i18n_64, "applyButton", i18n_65, "cancelButton", i18n_66, "adaptiveCloseButtonTitle", i18n_67, "adaptiveTitle", i18n_68, "redChannelLabel", i18n_69, "greenChannelLabel", i18n_70, "blueChannelLabel", i18n_71, "alphaChannelLabel", i18n_72, "redChannelLabel", i18n_73, "greenInputPlaceholder", i18n_74, "blueInputPlaceholder", i18n_75, "hexInputPlaceholder", i18n_76], [1, "k-input-inner"], [1, "k-value-icon", "k-color-preview", 3, "ngClass"], ["innerCssClass", "k-color-preview-icon", 3, "name", "customFontClass", "svgIcon", 4, "ngIf"], [1, "k-color-preview-mask"], ["kendoButton", "", "tabindex", "-1", "type", "button", "icon", "caret-alt-down", "rounded", "none", "aria-hidden", "true", 1, "k-input-button", 3, "size", "svgIcon", "fillMode", "disabled"], [3, "actionSheetClose", "onApply", "onCancel", "actionSheetTemplate", "isActionSheetExpanded", "title", "subtitle", "preview"], [3, "resize", 4, "ngIf"], ["innerCssClass", "k-color-preview-icon", 3, "name", "customFontClass", "svgIcon"], [3, "cancel", "focusout", "valueChange", "keydown", "activeViewChange", "clearButtonClick", "actionButtonClick", "value", "format", "size", "views", "activeView", "actionsLayout", "adaptiveMode", "preview", "gradientSettings", "paletteSettings", "clearButton"], [3, "resize"]];
    },
    template: function ColorPickerComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 4);
        ɵɵelementStart(1, "span", 5, 0)(3, "span", 6);
        ɵɵtemplate(4, ColorPickerComponent_kendo_icon_wrapper_4_Template, 1, 3, "kendo-icon-wrapper", 7);
        ɵɵelement(5, "span", 8);
        ɵɵelementEnd()();
        ɵɵelement(6, "button", 9);
        ɵɵtemplate(7, ColorPickerComponent_ng_template_7_Template, 2, 11, "ng-template", null, 1, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 2);
        ɵɵelementStart(11, "kendo-adaptive-renderer", 10);
        ɵɵlistener("actionSheetClose", function ColorPickerComponent_Template_kendo_adaptive_renderer_actionSheetClose_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onActionSheetClose($event));
        })("onApply", function ColorPickerComponent_Template_kendo_adaptive_renderer_onApply_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.applyValue());
        })("onCancel", function ColorPickerComponent_Template_kendo_adaptive_renderer_onCancel_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.cancelValue($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, ColorPickerComponent_kendo_resize_sensor_12_Template, 1, 0, "kendo-resize-sensor", 11);
      }
      if (rf & 2) {
        const popupTemplate_r5 = ɵɵreference(8);
        ɵɵadvance(3);
        ɵɵproperty("ngClass", ɵɵpureFunction2(14, _c57, ctx.customIconStyles || ctx.iconStyles || ctx.svgIcon, !ctx.value));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.iconClass || ctx.icon || ctx.svgIcon);
        ɵɵadvance();
        ɵɵstyleProp("background-color", ctx.value);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("svgIcon", ctx.arrowDownIcon)("fillMode", ctx.fillMode)("disabled", ctx.disabled);
        ɵɵadvance(5);
        ɵɵproperty("actionSheetTemplate", popupTemplate_r5)("isActionSheetExpanded", ctx.isActionSheetExpanded)("title", ctx.adaptiveTitle)("subtitle", ctx.adaptiveSubtitle)("preview", ctx.preview);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedColorPickerMessagesDirective, NgClass, NgIf, IconWrapperComponent, ButtonComponent, FlatColorPickerComponent, ResizeSensorComponent, AdaptiveRendererComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoColorPicker",
      selector: "kendo-colorpicker",
      providers: [{
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ColorPickerComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ColorPickerComponent)
      }, ColorPickerLocalizationService, {
        provide: LocalizationService,
        useExisting: ColorPickerLocalizationService
      }, {
        provide: L10N_PREFIX,
        useValue: "kendo.colorpicker"
      }],
      template: `
        <ng-container kendoColorPickerLocalizedMessages
            i18n-colorPickerNoColor="kendo.colorpicker.colorPickerNoColor|The aria-label applied to the ColorPicker component when the value is empty."
            colorPickerNoColor="Colorpicker no color chosen"
            i18n-flatColorPickerNoColor="kendo.colorpicker.flatColorPickerNoColor|The aria-label applied to the FlatColorPicker component when the value is empty."
            flatColorPickerNoColor="Flatcolorpicker no color chosen"
            i18n-colorGradientNoColor="kendo.colorpicker.colorGradientNoColor|The aria-label applied to the ColorGradient component when the value is empty."
            colorGradientNoColor="Colorgradient no color chosen"
            i18n-colorPaletteNoColor="kendo.colorpicker.colorPaletteNoColor|The aria-label applied to the ColorPalette component when the value is empty."
            colorPaletteNoColor="Colorpalette no color chosen"
            i18n-colorGradientHandle="kendo.colorpicker.colorGradientHandle|The title for the gradient color drag handle chooser."
            colorGradientHandle="Choose color"
            i18n-clearButton="kendo.colorpicker.clearButton|The title for the clear button."
            clearButton="Clear value"
            i18n-hueSliderHandle="kendo.colorpicker.hueSliderHandle|The title for the hue slider handle."
            hueSliderHandle="Set hue"
            i18n-opacitySliderHandle="kendo.colorpicker.opacitySliderHandle|The title for the opacity slider handle."
            opacitySliderHandle="Set opacity"
            i18n-contrastRatio="kendo.colorpicker.contrastRatio|The contrast ratio message for the contrast tool."
            contrastRatio="Contrast ratio"
            i18n-previewColor="kendo.colorpicker.previewColor|The message for the color preview pane."
            previewColor="Color preview"
            i18n-revertSelection="kendo.colorpicker.revertSelection|The message for the selected color pane."
            revertSelection="Revert selection"
            i18n-gradientView="kendo.colorpicker.gradientView|The message for the gradient view button."
            gradientView="Gradient view"
            i18n-paletteView="kendo.colorpicker.paletteView|The message for the palette view button."
            paletteView="Palette view"
            i18n-formatButton="kendo.colorpicker.formatButton|The message for the input format toggle button."
            formatButton="Change color format"
            i18n-applyButton="kendo.colorpicker.applyButton|The message for the Apply action button."
            applyButton="Apply"
            i18n-cancelButton="kendo.colorpicker.cancelButton|The message for the Cancel action button."
            cancelButton="Cancel"
            i18n-adaptiveCloseButtonTitle="kendo.colorpicker.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode."
            adaptiveCloseButtonTitle="Close"
            i18n-adaptiveTitle="kendo.colorpicker.adaptiveTitle|The title for the ActionSheet when in adaptive mode."
            adaptiveTitle="Choose Color"
            i18n-redChannelLabel="kendo.colorpicker.redChannelLabel|The label of the NumericTextBox representing the red color channel."
            redChannelLabel="Red channel"
            i18n-greenChannelLabel="kendo.colorpicker.greenChannelLabel|The label of the NumericTextBox representing the green color channel."
            greenChannelLabel="Green channel"
            i18n-blueChannelLabel="kendo.colorpicker.blueChannelLabel|The label of the NumericTextBox representing the blue color channel."
            blueChannelLabel="Blue channel"
            i18n-alphaChannelLabel="kendo.colorpicker.alphaChannelLabel|The label of the NumericTextBox representing the alpha color channel."
            alphaChannelLabel="Alpha channel"
            i18n-redInputPlaceholder="kendo.colorpicker.redInputPlaceholder|The placeholder for the red color input."
            redChannelLabel="R"
            i18n-greenInputPlaceholder="kendo.colorpicker.greenInputPlaceholder|The placeholder for the green color input."
            greenInputPlaceholder="G"
            i18n-blueInputPlaceholder="kendo.colorpicker.blueInputPlaceholder|The placeholder for the blue color input."
            blueInputPlaceholder="B"
            i18n-hexInputPlaceholder="kendo.colorpicker.hexInputPlaceholder|The placeholder for the HEX color input."
            hexInputPlaceholder="HEX">
        </ng-container>
        <span #activeColor class="k-input-inner">
            <span
                class="k-value-icon k-color-preview"
                [ngClass]="{'k-icon-color-preview': customIconStyles || iconStyles || svgIcon, 'k-no-color': !value}"
            >
                <kendo-icon-wrapper
                    *ngIf="iconClass || icon || svgIcon"
                    [name]="iconStyles"
                    innerCssClass="k-color-preview-icon"
                    [customFontClass]="customIconStyles"
                    [svgIcon]="svgIcon"
                >
                </kendo-icon-wrapper>
                <span class="k-color-preview-mask" [style.background-color]="value"></span>
            </span>
        </span>
        <button
            kendoButton
            tabindex="-1"
            type="button"
            icon="caret-alt-down"
            [size]="size"
            [svgIcon]="arrowDownIcon"
            [fillMode]="fillMode"
            [disabled]="disabled"
            rounded="none"
            aria-hidden="true"
            class="k-input-button"
        >
        </button>
        <ng-template #popupTemplate>
            <kendo-flatcolorpicker
                #flatColorPicker
                [value]="value"
                [format]="format"
                [size]="isAdaptive ? 'large' : size"
                [views]="views"
                [activeView]="activeView"
                [actionsLayout]="actionsLayout"
                [adaptiveMode]="isActionSheetExpanded"
                [preview]="preview"
                [gradientSettings]="gradientSettings"
                [paletteSettings]="paletteSettings"
                [clearButton]="clearButton"
                (cancel)="handleCancelEvent($event)"
                (focusout)="handlePopupBlur($event)"
                (valueChange)="handleValueChange($event)"
                (keydown)="handlePopupKeyDown($event)"
                (activeViewChange)="activeViewChange.emit($event)"
                (clearButtonClick)="clearButtonClick.emit()"
                (actionButtonClick)="togglePopup()">
            </kendo-flatcolorpicker>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-adaptive-renderer
            [actionSheetTemplate]="popupTemplate"
            [isActionSheetExpanded]="isActionSheetExpanded"
            [title]="adaptiveTitle"
            [subtitle]="adaptiveSubtitle"
            [preview]="preview"
            (actionSheetClose)="onActionSheetClose($event)"
            (onApply)="applyValue()"
            (onCancel)="cancelValue($event)"
        >
        </kendo-adaptive-renderer>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        `,
      standalone: true,
      imports: [LocalizedColorPickerMessagesDirective, NgClass, NgIf, IconWrapperComponent, ButtonComponent, FlatColorPickerComponent, ResizeSensorComponent, AdaptiveRendererComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-colorpicker"]
    }, {
      type: HostBinding,
      args: ["class.k-icon-picker"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    focusedClass: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    ariaReadonly: [{
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    hostTabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    hasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    views: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    activeView: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    disabled: [{
      type: Input
    }],
    format: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    paletteSettings: [{
      type: Input
    }],
    gradientSettings: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconClass: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    preview: [{
      type: Input
    }],
    actionsLayout: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    cancel: [{
      type: Output
    }],
    activeColorClick: [{
      type: Output
    }],
    clearButtonClick: [{
      type: Output
    }],
    activeViewChange: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    activeColor: [{
      type: ViewChild,
      args: ["activeColor", {
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    flatColorPicker: [{
      type: ViewChild,
      args: ["flatColorPicker", {
        static: false
      }]
    }],
    adaptiveRenderer: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent]
    }]
  });
})();
var ColorPickerCustomMessagesComponent = class _ColorPickerCustomMessagesComponent extends ColorPickerMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function ColorPickerCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ColorPickerCustomMessagesComponent,
    selectors: [["kendo-colorpicker-messages"], ["kendo-flatcolorpicker-messages"], ["kendo-colorgradient-messages"], ["kendo-colorpalette-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: ColorPickerMessages,
      useExisting: forwardRef(() => _ColorPickerCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ColorPickerCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: ColorPickerMessages,
        useExisting: forwardRef(() => ColorPickerCustomMessagesComponent)
      }],
      selector: "kendo-colorpicker-messages, kendo-flatcolorpicker-messages, kendo-colorgradient-messages, kendo-colorpalette-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var serial$1 = 0;
var ErrorComponent = class _ErrorComponent {
  hostClass = true;
  /**
   * Sets the alignment of the error message.
   *
   * @default 'start'
   */
  align = "start";
  /**
   * @hidden
   */
  id = `kendo-error-${serial$1++}`;
  roleAttribute = "alert";
  get startClass() {
    return this.align === "start";
  }
  get endClass() {
    return this.align === "end";
  }
  get idAttribute() {
    return this.id;
  }
  static ɵfac = function ErrorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ErrorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ErrorComponent,
    selectors: [["kendo-formerror"]],
    hostVars: 8,
    hostBindings: function ErrorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.roleAttribute)("id", ctx.idAttribute);
        ɵɵclassProp("k-form-error", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
      }
    },
    inputs: {
      align: "align"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c58,
    decls: 1,
    vars: 0,
    template: function ErrorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ErrorComponent, [{
    type: Component,
    args: [{
      selector: "kendo-formerror",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-error"]
    }],
    align: [{
      type: Input
    }],
    roleAttribute: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    startClass: [{
      type: HostBinding,
      args: ["class.k-text-start"]
    }],
    endClass: [{
      type: HostBinding,
      args: ["class.k-text-end"]
    }],
    idAttribute: [{
      type: HostBinding,
      args: ["attr.id"]
    }]
  });
})();
var serial = 0;
var HintComponent2 = class _HintComponent {
  /**
   * Sets the alignment of the hint message.
   *
   * @default 'start'
   */
  align = "start";
  /**
   * @hidden
   */
  id = `kendo-hint-${serial++}`;
  hostClass = true;
  get startClass() {
    return this.align === "start";
  }
  get endClass() {
    return this.align === "end";
  }
  get idAttribute() {
    return this.id;
  }
  static ɵfac = function HintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HintComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _HintComponent,
    selectors: [["kendo-formhint"]],
    hostVars: 7,
    hostBindings: function HintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.idAttribute);
        ɵɵclassProp("k-form-hint", ctx.hostClass)("k-text-start", ctx.startClass)("k-text-end", ctx.endClass);
      }
    },
    inputs: {
      align: "align"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c58,
    decls: 1,
    vars: 0,
    template: function HintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HintComponent2, [{
    type: Component,
    args: [{
      selector: "kendo-formhint",
      template: `
        <ng-content></ng-content>
    `,
      standalone: true
    }]
  }], null, {
    align: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-hint"]
    }],
    startClass: [{
      type: HostBinding,
      args: ["class.k-text-start"]
    }],
    endClass: [{
      type: HostBinding,
      args: ["class.k-text-end"]
    }],
    idAttribute: [{
      type: HostBinding,
      args: ["attr.id"]
    }]
  });
})();
var FormFieldComponent = class _FormFieldComponent {
  renderer;
  localizationService;
  hostElement;
  hostClass = true;
  /**
   * @hidden
   */
  direction;
  get errorClass() {
    if (!this.control) {
      return false;
    }
    return this.control.invalid && (this.control.touched || this.control.dirty);
  }
  get disabledClass() {
    if (!this.control) {
      return false;
    }
    if (this.isRadioControl(this.control)) {
      return false;
    }
    return this.disabledControl() || this.disabledElement() || this.disabledKendoInput();
  }
  set formControls(formControls) {
    this.validateFormControl(formControls);
    this.control = formControls.first;
  }
  controlElementRefs;
  kendoInput;
  errorChildren;
  hintChildren;
  /**
   * Specifies when to show the hint messages:
   * * `initial`&mdash;Shows hints when the form control is `valid` or `untouched` and `pristine`.
   * * `always`&mdash;Always shows hints.
   *
   * @default 'initial'
   */
  showHints = "initial";
  /**
   * Specifies the layout orientation of the form field.
   *
   * @default 'vertical'
   */
  orientation = "vertical";
  /**
   * Specifies when to show the error messages:
   * * `initial`&mdash;Shows errors when the form control is `invalid` and `touched` or `dirty`.
   * * `always`&mdash;Always shows errors.
   *
   * @default 'initial'
   */
  showErrors = "initial";
  /**
   * @hidden
   */
  get horizontal() {
    return this.orientation === "horizontal";
  }
  /**
   * @hidden
   */
  get hasHints() {
    return this.showHints === "always" ? true : this.showHintsInitial();
  }
  /**
   * @hidden
   */
  get hasErrors() {
    return this.showErrors === "always" ? true : this.showErrorsInitial();
  }
  control;
  subscriptions = new Subscription();
  rtl = false;
  constructor(renderer, localizationService, hostElement) {
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.rtl = rtl;
      this.direction = this.rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    this.setDescription();
  }
  ngAfterViewChecked() {
    this.updateDescription();
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  disabledKendoInput() {
    return this.kendoInput && this.kendoInput.disabled;
  }
  disabledControl() {
    return this.control.disabled;
  }
  disabledElement() {
    const elements = this.controlElementRefs.toArray();
    return elements.every((e) => e.nativeElement.hasAttribute("disabled"));
  }
  validateFormControl(formControls) {
    if (isDevMode() && formControls.length !== 1 && !this.isControlGroup(formControls)) {
      throw new Error("The `kendo-formfield` component should contain only one control of type NgControl with a formControlName(https://angular.io/api/forms/FormControlName)or an ngModel(https://angular.io/api/forms/NgModel) binding.");
    }
  }
  isControlGroup(formControls) {
    if (!formControls.length) {
      return false;
    }
    const name = formControls.first.name;
    return formControls.toArray().every((c) => c.name === name && this.isRadioControl(c));
  }
  isRadioControl(control) {
    return control.valueAccessor instanceof RadioControlValueAccessor;
  }
  updateDescription() {
    const controls = this.findControlElements().filter((c) => !!c);
    if (!controls) {
      return;
    }
    controls.forEach((control) => {
      if (this.errorChildren.length > 0 || this.hintChildren.length > 0) {
        const ariaIds = this.generateDescriptionIds(control);
        if (ariaIds !== "") {
          this.renderer.setAttribute(control, "aria-describedby", ariaIds);
        } else {
          this.renderer.removeAttribute(control, "aria-describedby");
        }
      }
    });
  }
  findControlElements() {
    if (!this.controlElementRefs) {
      return;
    }
    if (this.kendoInput && this.kendoInput.focusableId && isDocumentAvailable()) {
      const isEditor = this.kendoInput.focusableId.startsWith("k-editor");
      return isEditor ? [this.kendoInput.viewMountElement] : [this.hostElement.nativeElement.querySelector(`#${this.kendoInput.focusableId}`)];
    }
    return this.controlElementRefs.map((el) => el.nativeElement);
  }
  generateDescriptionIds(control) {
    const ids = /* @__PURE__ */ new Set();
    let errorAttribute = "";
    if (control.hasAttribute("aria-describedby")) {
      const attributes = control.getAttribute("aria-describedby").split(" ");
      errorAttribute = attributes.filter((attr) => attr.includes("kendo-error-"))[0];
      attributes.forEach((attr) => {
        if (attr.includes("kendo-hint-") || attr.includes("kendo-error-")) {
          return;
        }
        ids.add(attr);
      });
    }
    this.hintChildren.forEach((hint) => {
      ids.add(hint.id);
    });
    if (this.hasErrors) {
      this.errorChildren.forEach((error) => {
        ids.add(error.id);
      });
    } else {
      ids.delete(errorAttribute);
    }
    return Array.from(ids).join(" ");
  }
  showHintsInitial() {
    if (!this.control) {
      return true;
    }
    const {
      valid,
      untouched,
      pristine
    } = this.control;
    return valid || untouched && pristine;
  }
  showErrorsInitial() {
    if (!this.control) {
      return false;
    }
    const {
      invalid,
      dirty,
      touched
    } = this.control;
    return invalid && (dirty || touched);
  }
  setDescription() {
    this.updateDescription();
    this.subscriptions.add(this.errorChildren.changes.subscribe(() => this.updateDescription()));
    this.subscriptions.add(this.hintChildren.changes.subscribe(() => this.updateDescription()));
  }
  static ɵfac = function FormFieldComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormFieldComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _FormFieldComponent,
    selectors: [["kendo-formfield"]],
    contentQueries: function FormFieldComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, KendoInput, 7);
        ɵɵcontentQuery(dirIndex, NgControl, 5);
        ɵɵcontentQuery(dirIndex, NgControl, 5, ElementRef);
        ɵɵcontentQuery(dirIndex, ErrorComponent, 5);
        ɵɵcontentQuery(dirIndex, HintComponent2, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.kendoInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.formControls = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlElementRefs = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.errorChildren = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hintChildren = _t);
      }
    },
    hostVars: 7,
    hostBindings: function FormFieldComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-form-field", ctx.hostClass)("k-form-field-error", ctx.errorClass)("k-form-field-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      showHints: "showHints",
      orientation: "orientation",
      showErrors: "showErrors"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.formfield"
    }]), ɵɵStandaloneFeature],
    ngContentSelectors: _c60,
    decls: 5,
    vars: 2,
    consts: [[1, "k-form-field-wrap"], [4, "ngIf"]],
    template: function FormFieldComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef(_c59);
        ɵɵprojection(0);
        ɵɵelementStart(1, "div", 0);
        ɵɵprojection(2, 1);
        ɵɵtemplate(3, FormFieldComponent_ng_content_3_Template, 1, 0, "ng-content", 1)(4, FormFieldComponent_ng_content_4_Template, 1, 0, "ng-content", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.hasHints);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasErrors);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFieldComponent, [{
    type: Component,
    args: [{
      selector: "kendo-formfield",
      template: `
        <ng-content select="label, kendo-label"></ng-content>
        <div class="k-form-field-wrap">
            <ng-content></ng-content>
            <ng-content select="kendo-formhint" *ngIf="hasHints"></ng-content>
            <ng-content select="kendo-formerror" *ngIf="hasErrors"></ng-content>
        </div>
    `,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.formfield"
      }],
      standalone: true,
      imports: [NgIf]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ElementRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-form-field"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    errorClass: [{
      type: HostBinding,
      args: ["class.k-form-field-error"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-form-field-disabled"]
    }],
    formControls: [{
      type: ContentChildren,
      args: [NgControl, {
        descendants: true
      }]
    }],
    controlElementRefs: [{
      type: ContentChildren,
      args: [NgControl, {
        read: ElementRef,
        descendants: true
      }]
    }],
    kendoInput: [{
      type: ContentChild,
      args: [KendoInput, {
        static: true
      }]
    }],
    errorChildren: [{
      type: ContentChildren,
      args: [ErrorComponent, {
        descendants: true
      }]
    }],
    hintChildren: [{
      type: ContentChildren,
      args: [HintComponent2, {
        descendants: true
      }]
    }],
    showHints: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    showErrors: [{
      type: Input
    }]
  });
})();
var RadioButtonComponent = class _RadioButtonComponent extends RadioCheckBoxBase {
  renderer;
  hostElement;
  cdr;
  ngZone;
  injector;
  localizationService;
  hostClass = true;
  direction;
  /**
   * Specifies the checked state of the RadioButton.
   *
   * @default false
   */
  checked = false;
  /**
   * Fires when the checked state changes.
   * The event does not fire when you change the state through `ngModel` or `formControl` bindings.
   * Use this event for two-way binding of the `checked` property.
   */
  checkedChange = new EventEmitter();
  subs = new Subscription();
  get defaultAttributes() {
    return {
      type: "radio",
      id: this.focusableId,
      title: this.title,
      tabindex: this.tabindex,
      tabIndex: this.tabindex,
      disabled: this.disabled ? "" : null,
      value: this.value,
      checked: this.checked,
      name: this.name,
      "aria-invalid": this.isControlInvalid
    };
  }
  constructor(renderer, hostElement, cdr, ngZone, injector, localizationService) {
    super("radio", hostElement, renderer, cdr, ngZone, injector);
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.ngZone = ngZone;
    this.injector = injector;
    this.localizationService = localizationService;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    super.ngOnInit();
    this.subs.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
    if (this.control) {
      this.subs.add(this.control.valueChanges.subscribe((e) => {
        this.control.control.setValue(e, {
          emitEvent: false
        });
      }));
    }
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  /**
   * @hidden
   */
  handleChange = ($event) => {
    this.ngZone.run(() => {
      this.checked = $event.target.checked;
      this.checkedChange.emit(this.checked);
      this.ngChange($event.target.value);
    });
  };
  /**
   * @hidden
   */
  writeValue(value) {
    this.checked = value === this.value;
  }
  static ɵfac = function RadioButtonComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RadioButtonComponent,
    selectors: [["kendo-radiobutton"]],
    hostVars: 3,
    hostBindings: function RadioButtonComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-radio-wrap", ctx.hostClass);
      }
    },
    inputs: {
      checked: "checked"
    },
    outputs: {
      checkedChange: "checkedChange"
    },
    exportAs: ["kendoRadioButton"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.radiobutton"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RadioButtonComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RadioButtonComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 3,
    vars: 21,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["type", "radio", 1, "k-radio", 3, "id", "disabled", "value", "name", "checked", "kendoEventsOutsideAngular"]],
    template: function RadioButtonComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function RadioButtonComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function RadioButtonComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function RadioButtonComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵelement(1, "input", 2, 0);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵclassProp("k-disabled", ctx.disabled)("k-checked", ctx.checked)("k-invalid", ctx.isControlInvalid);
        ɵɵproperty("id", ctx.focusableId)("disabled", ctx.disabled)("value", ctx.value)("name", ctx.name)("checked", ctx.checked)("kendoEventsOutsideAngular", ɵɵpureFunction2(18, _c19, ctx.handleInputBlur, ctx.handleChange));
        ɵɵattribute("title", ctx.title)("tabindex", ctx.disabled ? void 0 : ctx.tabindex)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null);
      }
    },
    dependencies: [SharedInputEventsDirective, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRadioButton",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.radiobutton"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RadioButtonComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RadioButtonComponent)
      }],
      selector: "kendo-radiobutton",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <input #input
                type="radio"
                class="k-radio"
                [id]="focusableId"
                [attr.title]="title"
                [disabled]="disabled"
                [class.k-disabled]="disabled"
                [attr.tabindex]="disabled ? undefined : tabindex"
                [value]="value"
                [name]="name"
                [checked]="checked"
                [class.k-checked]="checked"
                [attr.aria-invalid]="isControlInvalid"
                [class.k-invalid]="isControlInvalid"
                [attr.required]="isControlRequired ? '' : null"
                [kendoEventsOutsideAngular]="{
                    blur: handleInputBlur,
                    change: handleChange
                }"
            />
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: LocalizationService
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-radio-wrap"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    checked: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }]
  });
})();
var DEFAULT_SIZE$3 = "medium";
var RadioButtonDirective = class _RadioButtonDirective {
  renderer;
  hostElement;
  kendoClass = true;
  /**
   * Specifies the `size` of the RadioButton. The `size` property changes the width and height of the RadioButton ([see example]({% slug appearance_radiobuttondirective %}#toc-size)).
   *
   * @default "medium"
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$3;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  _size = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
  }
  ngAfterViewInit() {
    const stylingInputs = ["size"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("radio", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  static ɵfac = function RadioButtonDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonDirective)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RadioButtonDirective,
    selectors: [["input", "kendoRadioButton", ""]],
    hostVars: 2,
    hostBindings: function RadioButtonDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-radio", ctx.kendoClass);
      }
    },
    inputs: {
      size: "size"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonDirective, [{
    type: Directive,
    args: [{
      selector: "input[kendoRadioButton]",
      standalone: true
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    kendoClass: [{
      type: HostBinding,
      args: ["class.k-radio"]
    }],
    size: [{
      type: Input
    }]
  });
})();
var RangeSliderCustomMessagesComponent = class _RangeSliderCustomMessagesComponent extends RangeSliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function RangeSliderCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RangeSliderCustomMessagesComponent,
    selectors: [["kendo-rangeslider-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: RangeSliderMessages,
      useExisting: forwardRef(() => _RangeSliderCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function RangeSliderCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: RangeSliderMessages,
        useExisting: forwardRef(() => RangeSliderCustomMessagesComponent)
      }],
      selector: "kendo-rangeslider-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var RatingHoveredItemTemplateDirective = class _RatingHoveredItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingHoveredItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingHoveredItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingHoveredItemTemplateDirective,
    selectors: [["", "kendoRatingHoveredItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingHoveredItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingHoveredItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingItemTemplateDirective = class _RatingItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingItemTemplateDirective,
    selectors: [["", "kendoRatingItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingSelectedItemTemplateDirective = class _RatingSelectedItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function RatingSelectedItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingSelectedItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _RatingSelectedItemTemplateDirective,
    selectors: [["", "kendoRatingSelectedItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingSelectedItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoRatingSelectedItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RatingComponent = class _RatingComponent {
  element;
  renderer;
  localizationService;
  cdr;
  zone;
  itemTemplate;
  hoveredItemTemplate;
  selectedItemTemplate;
  /**
   * When `true`, disables the Rating ([see example]({% slug disabledstate_rating %})).
    * To disable the component in reactive forms, see [Forms Support](slug:formssupport_rating#toc-managing-the-rating-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * When `true`, sets the Rating to read-only ([see example]({% slug readonly_rating %})).
    *
   * @default false
   */
  readonly = false;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the Rating.
    *
   * @default 0
   */
  tabindex = 0;
  /**
   * Sets the number of Rating items ([see example]({% slug itemscount_rating %})).
   *
   * @default 5
   */
  itemsCount = 5;
  /**
   * Sets the initial value of the Rating component.
   * Use either `ngModel` or the `value` binding, but not both at the same time.
   */
  set value(value) {
    this._value = value;
    this.updateRatingItems();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the selection mode of the Rating ([see example]({% slug selection_rating %})).
   *
   * @default 'continuous'
   */
  set selection(selection) {
    this._selection = selection;
    this.updateRatingItems();
  }
  get selection() {
    return this._selection;
  }
  /**
   * Sets the precision of the Rating ([see example]({% slug precision_rating %})).
   *
   * @default 'item'
   */
  set precision(precision) {
    this._precision = precision;
    this.updateRatingItems();
  }
  get precision() {
    return this._precision;
  }
  /**
   * Sets the label text for the Rating. The text renders in a `<span>` element ([see example]({% slug label_rating %})).
   */
  label;
  /**
   * Sets a custom font icon for the Rating items ([see example]({% slug icon_rating %})).
   */
  icon;
  /**
   * Sets a custom SVG icon for the selected or hovered state of the Rating items ([see example]({% slug icon_rating %})).
   */
  svgIcon = starIcon;
  /**
   * Sets a custom SVG icon for the default state of the Rating items when not hovered or selected ([see example]({% slug icon_rating %})).
   */
  svgIconOutline = starOutlineIcon;
  /**
   * Fires when the user selects a new value.
   */
  valueChange = new EventEmitter();
  hostClass = true;
  direction;
  get isControlInvalid() {
    return this.control?.invalid?.toString();
  }
  valueMin = 0;
  get valueMax() {
    return this.itemsCount;
  }
  get valueNow() {
    return this.value;
  }
  ariaRole = "slider";
  /**
   * @hidden
   */
  ratingItems = [];
  control;
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  rect;
  _value;
  _selection = "continuous";
  _precision = "item";
  subscriptions = new Subscription();
  constructor(element, renderer, localizationService, cdr, zone) {
    this.element = element;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.cdr = cdr;
    this.zone = zone;
    validatePackage(packageMetadata2);
  }
  ngOnInit() {
    this.subscriptions.add(this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    }));
    this.subscriptions.add(this.renderer.listen(this.element.nativeElement, "blur", () => this.ngTouched()));
    this.subscriptions.add(this.renderer.listen(this.element.nativeElement, "keydown", (event) => this.onKeyDown(event)));
    this.createRatingItems();
  }
  ngAfterViewInit() {
    const items = this.element.nativeElement.querySelectorAll(".k-rating-item");
    this.zone.runOutsideAngular(() => {
      items.forEach((item, index) => this.subscriptions.add(this.renderer.listen(item, "mousemove", (event) => this.onMouseMove(index, event))));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * Focuses the Rating component.
   */
  focus() {
    if (isDocumentAvailable() && !this.disabled) {
      this.element.nativeElement.focus();
    }
  }
  /**
   * Blurs the Rating component.
   */
  blur() {
    if (isDocumentAvailable()) {
      this.element.nativeElement.blur();
    }
  }
  /**
   * @hidden
   */
  createRatingItems() {
    for (let i = 0; i < this.itemsCount; i++) {
      const item = {
        title: this.isHalf(i, this.value) ? String(i + 0.5) : String(i + 1),
        selected: this.isSelected(i, this.value),
        selectedIndicator: false,
        hovered: false,
        half: this.isHalf(i, this.value)
      };
      this.ratingItems.push(item);
    }
  }
  /**
   * @hidden
   */
  onMouseEnter(event) {
    this.rect = event.target.getBoundingClientRect();
  }
  /**
   * @hidden
   */
  onMouseMove(value, event) {
    const halfPrecision = this.precision === "half";
    const isFirstHalf = halfPrecision && this.isFirstHalf(this.rect, event.clientX);
    this.zone.run(() => this.ratingItems.forEach((item, index) => {
      item.title = halfPrecision && value === index && isFirstHalf ? String(index + 0.5) : String(index + 1);
      item.selected = item.hovered = this.isSelected(index, value + 1);
      item.selectedIndicator = this.isSelected(index, this.value);
      item.half = halfPrecision && value === index ? isFirstHalf : false;
    }));
  }
  /**
   * @hidden
   */
  onMouseOut() {
    this.rect = null;
    this.updateRatingItems();
  }
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  changeValue(index, event) {
    const rect = event.target.getBoundingClientRect();
    const isFirstHalf = this.isFirstHalf(rect, event.clientX);
    const value = this.precision === "half" && isFirstHalf ? index + 0.5 : index + 1;
    if (!areSame(this.value, value)) {
      this.value = value;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    }
  }
  /**
   * @hidden
   */
  updateRatingItems() {
    this.ratingItems.forEach((item, index) => {
      item.title = this.isHalf(index, this.value) ? String(index + 0.5) : String(index + 1);
      item.selected = this.isSelected(index, this.value);
      item.selectedIndicator = this.isSelected(index, this.value);
      item.hovered = false;
      item.half = this.isHalf(index, this.value);
    });
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.updateRatingItems();
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  isSelected(index, value) {
    return this.selection === "single" ? index === Math.ceil(value - 1) : index <= Math.ceil(value - 1);
  }
  isHalf(index, value) {
    return this.precision === "half" && value > index && value < index + 1;
  }
  isFirstHalf(rect, clientX) {
    const elementPosition = rect.x + rect.width / 2;
    return this.direction === "ltr" ? clientX < elementPosition : clientX > elementPosition;
  }
  onKeyDown(event) {
    const decreaseValue = () => {
      if (this.value <= 0) {
        return;
      }
      this.value = this.precision === "half" ? this.value - 0.5 : this.value - 1;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    };
    const increaseValue = () => {
      if (this.value >= this.itemsCount) {
        return;
      }
      this.value = this.precision === "half" ? this.value + 0.5 : this.value + 1;
      this.ngChange(this.value);
      this.valueChange.emit(this.value);
      this.updateRatingItems();
      this.cdr.markForCheck();
    };
    const setMinValue = () => {
      if (!areSame(this.value, this.valueMin)) {
        this.value = this.valueMin;
        this.ngChange(this.value);
        this.valueChange.emit(this.value);
        this.updateRatingItems();
        this.cdr.markForCheck();
      }
    };
    const setMaxValue = () => {
      if (!areSame(this.value, this.valueMax)) {
        this.value = this.valueMax;
        this.ngChange(this.value);
        this.valueChange.emit(this.value);
        this.updateRatingItems();
        this.cdr.markForCheck();
      }
    };
    if (event.keyCode === Keys.ArrowDown) {
      decreaseValue();
    }
    if (event.keyCode === Keys.ArrowLeft) {
      if (this.direction === "ltr") {
        decreaseValue();
      } else {
        increaseValue();
      }
    }
    if (event.keyCode === Keys.ArrowUp) {
      increaseValue();
    }
    if (event.keyCode === Keys.ArrowRight) {
      if (this.direction === "ltr") {
        increaseValue();
      } else {
        decreaseValue();
      }
    }
    if (event.keyCode === Keys.Home) {
      setMinValue();
    }
    if (event.keyCode === Keys.End) {
      setMaxValue();
    }
  }
  static ɵfac = function RatingComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _RatingComponent,
    selectors: [["kendo-rating"]],
    contentQueries: function RatingComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, RatingItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, RatingHoveredItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, RatingSelectedItemTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.hoveredItemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.selectedItemTemplate = _t.first);
      }
    },
    hostVars: 15,
    hostBindings: function RatingComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.disabled)("aria-readonly", ctx.readonly)("tabindex", ctx.tabindex)("dir", ctx.direction)("aria-invalid", ctx.isControlInvalid)("aria-valuemin", ctx.valueMin)("aria-valuemax", ctx.valueMax)("aria-valuenow", ctx.valueNow)("role", ctx.ariaRole);
        ɵɵclassProp("k-disabled", ctx.disabled)("k-readonly", ctx.readonly)("k-rating", ctx.hostClass);
      }
    },
    inputs: {
      disabled: "disabled",
      readonly: "readonly",
      tabindex: "tabindex",
      itemsCount: "itemsCount",
      value: "value",
      selection: "selection",
      precision: "precision",
      label: "label",
      icon: "icon",
      svgIcon: "svgIcon",
      svgIconOutline: "svgIconOutline"
    },
    outputs: {
      valueChange: "valueChange"
    },
    exportAs: ["kendoRating"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.rating"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _RatingComponent)
      /* eslint-disable-line*/
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _RatingComponent)
    }]), ɵɵStandaloneFeature],
    decls: 3,
    vars: 2,
    consts: [[1, "k-rating-container"], ["class", "k-rating-item", 3, "title", "ngClass", "mouseenter", "mouseout", "click", 4, "ngFor", "ngForOf"], ["class", "k-rating-label", 4, "ngIf"], [1, "k-rating-item", 3, "mouseenter", "mouseout", "click", "title", "ngClass"], [4, "ngIf"], ["size", "xlarge", 3, "name", "svgIcon", 4, "ngIf"], ["size", "xlarge", 3, "name", 4, "ngIf"], ["size", "xlarge", 3, "name", "svgIcon"], ["size", "xlarge", 3, "name"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "k-rating-precision-complement"], ["class", "k-rating-precision-part", 3, "ngStyle", 4, "ngIf"], [1, "k-rating-precision-part", 3, "ngStyle"], [1, "k-rating-label"]],
    template: function RatingComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementStart(0, "span", 0);
        ɵɵtemplate(1, RatingComponent_span_1_Template, 3, 7, "span", 1);
        ɵɵelementEnd();
        ɵɵtemplate(2, RatingComponent_span_2_Template, 2, 1, "span", 2);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx.ratingItems);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.label);
      }
    },
    dependencies: [NgForOf, NgClass, NgIf, IconWrapperComponent, NgTemplateOutlet, NgStyle],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoRating",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.rating"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => RatingComponent)
        /* eslint-disable-line*/
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => RatingComponent)
      }],
      selector: "kendo-rating",
      template: `
        <span class="k-rating-container">
            <span
                *ngFor="let item of ratingItems; index as i"
                class="k-rating-item"
                [title]="item.title"
                [ngClass]="{
                    'k-selected': item.selected || item.selectedIndicator,
                    'k-hover': item.hovered
                }"
                (mouseenter)="onMouseEnter($event)"
                (mouseout)="onMouseOut()"
                (click)="changeValue(i, $event)"
            >
                <ng-container *ngIf="!item.half">
                    <ng-container *ngIf="!itemTemplate">
                        <kendo-icon-wrapper
                            *ngIf="!icon"
                            size="xlarge"
                            [name]="item.selected || item.hovered ? 'star' : 'star-outline'"
                            [svgIcon]="item.selected || item.hovered ? svgIcon : svgIconOutline"
                        >
                        </kendo-icon-wrapper>

                        <kendo-icon-wrapper
                            *ngIf="icon"
                            size="xlarge"
                            [name]="item.selected || item.hovered ? icon : icon + '-outline'"
                        >
                        </kendo-icon-wrapper>
                    </ng-container>

                    <ng-template
                        *ngIf="itemTemplate && (!item.selected && !item.hovered)"
                        [ngTemplateOutlet]="itemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>

                    <ng-template
                        *ngIf="hoveredItemTemplate && item.hovered"
                        [ngTemplateOutlet]="hoveredItemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>

                    <ng-template
                        *ngIf="selectedItemTemplate && (item.selected && !item.hovered)"
                        [ngTemplateOutlet]="selectedItemTemplate?.templateRef"
                        [ngTemplateOutletContext]="{index: i}"
                    >
                    </ng-template>
                </ng-container>

                <ng-container *ngIf="item.half">
                    <ng-container *ngIf="!itemTemplate">
                        <span class="k-rating-precision-complement">
                            <kendo-icon-wrapper
                                *ngIf="!icon"
                                size="xlarge"
                                [name]="'star-outline'"
                                [svgIcon]="svgIconOutline"
                            >
                            </kendo-icon-wrapper>

                            <kendo-icon-wrapper
                                *ngIf="icon"
                                size="xlarge"
                                [name]="icon + '-outline'"
                            >
                            </kendo-icon-wrapper>
                        </span>

                        <span
                            class="k-rating-precision-part"
                            [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                        >
                            <kendo-icon-wrapper
                                *ngIf="!icon"
                                size="xlarge"
                                [name]="'star'"
                                [svgIcon]="svgIcon"
                            >
                            </kendo-icon-wrapper>

                            <kendo-icon-wrapper
                                *ngIf="icon"
                                size="xlarge"
                                [name]="icon"
                            >
                            </kendo-icon-wrapper>
                        </span>
                    </ng-container>

                    <span
                        class="k-rating-precision-complement"
                    >
                        <ng-template
                            [ngTemplateOutlet]="itemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span
                        *ngIf="hoveredItemTemplate && item.hovered"
                        class="k-rating-precision-part"
                        [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                    >
                        <ng-template
                            [ngTemplateOutlet]="hoveredItemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span
                        *ngIf="selectedItemTemplate && (item.selected && !item.hovered)"
                        class="k-rating-precision-part"
                        [ngStyle]="{'clipPath': direction === 'rtl' ? 'inset(0 0 0 50%)' : 'inset(0 50% 0 0)'}"
                    >
                        <ng-template
                            [ngTemplateOutlet]="selectedItemTemplate?.templateRef"
                            [ngTemplateOutletContext]="{index: i}"
                        >
                        </ng-template>
                    </span>

                    <span [style.width.px]="24" [style.height.px]="24" [style.display]="'block'"></span>
                </ng-container>
            </span>
        </span>

        <span
            *ngIf="label"
            class="k-rating-label"
        >{{ label }}</span>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgIf, IconWrapperComponent, NgTemplateOutlet, NgStyle]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }];
  }, {
    itemTemplate: [{
      type: ContentChild,
      args: [RatingItemTemplateDirective]
    }],
    hoveredItemTemplate: [{
      type: ContentChild,
      args: [RatingHoveredItemTemplateDirective]
    }],
    selectedItemTemplate: [{
      type: ContentChild,
      args: [RatingSelectedItemTemplateDirective]
    }],
    disabled: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }, {
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.aria-readonly"]
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    itemsCount: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selection: [{
      type: Input
    }],
    precision: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    svgIconOutline: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-rating"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    isControlInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    valueMin: [{
      type: HostBinding,
      args: ["attr.aria-valuemin"]
    }],
    valueMax: [{
      type: HostBinding,
      args: ["attr.aria-valuemax"]
    }],
    valueNow: [{
      type: HostBinding,
      args: ["attr.aria-valuenow"]
    }],
    ariaRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var SignatureMessages = class _SignatureMessages extends ComponentMessages {
  /**
   * The title of the Clear button of the Signature.
   */
  clear;
  /**
   * The title of the Minimize button of the Signature.
   */
  minimize;
  /**
   * The title of the Maximize button of the Signature.
   */
  maximize;
  /**
   * The value of the Signature canvas element aria-label attribute.
   */
  canvasLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵSignatureMessages_BaseFactory;
    return function SignatureMessages_Factory(__ngFactoryType__) {
      return (ɵSignatureMessages_BaseFactory || (ɵSignatureMessages_BaseFactory = ɵɵgetInheritedFactory(_SignatureMessages)))(__ngFactoryType__ || _SignatureMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _SignatureMessages,
    selectors: [["kendo-signature-messages-base"]],
    inputs: {
      clear: "clear",
      minimize: "minimize",
      maximize: "maximize",
      canvasLabel: "canvasLabel"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-signature-messages-base"
    }]
  }], null, {
    clear: [{
      type: Input
    }],
    minimize: [{
      type: Input
    }],
    maximize: [{
      type: Input
    }],
    canvasLabel: [{
      type: Input
    }]
  });
})();
var SignatureCustomMessagesComponent = class _SignatureCustomMessagesComponent extends SignatureMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SignatureCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SignatureCustomMessagesComponent,
    selectors: [["kendo-signature-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SignatureMessages,
      useExisting: forwardRef(() => _SignatureCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function SignatureCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SignatureMessages,
        useExisting: forwardRef(() => SignatureCustomMessagesComponent)
      }],
      selector: "kendo-signature-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SignatureCloseEvent = class extends PreventableEvent {
};
var SignatureOpenEvent = class extends PreventableEvent {
};
var LocalizedSignatureMessagesDirective = class _LocalizedSignatureMessagesDirective extends SignatureMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedSignatureMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedSignatureMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedSignatureMessagesDirective,
    selectors: [["", "kendoSignatureLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SignatureMessages,
      useExisting: forwardRef(() => _LocalizedSignatureMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedSignatureMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: SignatureMessages,
        useExisting: forwardRef(() => LocalizedSignatureMessagesDirective)
      }],
      selector: "[kendoSignatureLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var noop4 = () => {
};
var _id = 0;
var nextId = () => "k-signature-focusable-" + _id++;
var FOCUSED_CLASS = "k-focus";
var DEFAULT_SIZE$2 = "medium";
var DEFAULT_ROUNDED$2 = "medium";
var DEFAULT_FILL_MODE$2 = "solid";
var DEFAULT_POPUP_SCALE = 3;
var DEFAULT_EXPORT_SCALE2 = 2;
var DEFAULT_COLOR2 = "#000000";
var DEFAULT_BACKGROUND_COLOR2 = "#ffffff";
var iconsMap = {
  xIcon,
  hyperlinkOpenIcon
};
var SignatureComponent = class _SignatureComponent {
  element;
  renderer;
  ngZone;
  cd;
  localization;
  cdr;
  staticHostClasses = true;
  /**
   * @hidden
   */
  focusableId = nextId();
  direction;
  /**
   * Sets the read-only state of the Signature.
   *
   * Set to `true` to prevent editing.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the disabled state of the Signature.
   *
   * Set to `true` to disable the component and prevent any user interaction.
   * To disable the component in reactive forms, see [Managing the Signature Disabled State in Reactive Forms](slug:formssupport_signature#toc-managing-the-signature-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the width of the Signature in pixels.
   *
   * You can also set the width using inline styles or CSS.
   */
  width;
  /**
   * Sets the height of the Signature in pixels.
   *
   * You can also set the height using inline styles or CSS.
   */
  height;
  /**
   * Gets or sets the value of the Signature.
   *
   * The value is a Base64-encoded PNG image.
   */
  set value(value) {
    if (value !== this._value) {
      this._value = value;
      if (this.instance) {
        this.instance.loadImage(value);
      }
    }
  }
  get value() {
    return this._value;
  }
  /**
   * @hidden
   */
  svgIcon(name) {
    return iconsMap[name];
  }
  /**
   * Specifies the [tabindex](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  set tabindex(value) {
    const tabindex = Number(value);
    const defaultValue = 0;
    this._tabindex = !isNaN(tabindex) ? tabindex : defaultValue;
  }
  get tabindex() {
    return !this.disabled ? this._tabindex : void 0;
  }
  /**
   * Sets the padding of the Signature internal controls
   * ([ee example]({% slug appearance_signature %}#toc-size)).
   *
   * @default 'medium'
   */
  size = DEFAULT_SIZE$2;
  /**
   * Sets the border radius of the Signature
   * ([see example](slug:appearance_signature#rounded-corners)).
   *
   * @default 'medium'
   */
  rounded = DEFAULT_ROUNDED$2;
  /**
   * Sets the background and border styles of the Signature
   * ([see example](slug:appearance_signature#toc-fill-mode)).
   *
   * @default 'solid'
   */
  fillMode = DEFAULT_FILL_MODE$2;
  /**
   * Sets the stroke color of the Signature.
   *
   * Accepts CSS color names and hex values.
   * The default value is determined by the theme `$kendo-input-text` variable.
   */
  color;
  /**
   * Sets the background color of the Signature.
   *
   * Accepts CSS color names and hex values.
   * The default value is determined by the theme `$kendo-input-bg` variable.
   */
  backgroundColor;
  /**
   * Sets the stroke width of the Signature.
   *
   * @default 1
   */
  strokeWidth = 1;
  /**
   * When set to `true`, smooths out signature lines.
   *
   * @default false
   */
  smooth = false;
  /**
   * When set to `true`, allows the Signature to be maximized.
   *
   * @default true
   */
  maximizable = true;
  /**
   * @hidden
   */
  maximized = false;
  /**
   * Sets the scale factor for the popup.
   *
   * The Signature width and height are multiplied by this value when showing the popup.
   *
   * @default 3
   */
  popupScale = DEFAULT_POPUP_SCALE;
  /**
   * Sets the scale factor for the exported image.
   *
   * The Signature width and height are multiplied by this value when converting the signature to an image.
   *
   * @default 2
   */
  exportScale = DEFAULT_EXPORT_SCALE2;
  /**
   * @hidden
   */
  parentLocalization;
  /**
   * When set to `true`, hides the dotted line in the background.
   *
   * @default false
   */
  hideLine = false;
  /**
   * Fires when the signature value changes.
   */
  valueChange = new EventEmitter();
  /**
   * Fires before the popup opens.
   *
   * This event is preventable. If you cancel it, the popup stays closed.
   */
  open = new EventEmitter();
  /**
   * Fires before the popup closes.
   *
   * This event is preventable. If you cancel it, the popup stays open.
   */
  close = new EventEmitter();
  /**
   * Fires when the Signature receives focus.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the Signature loses focus.
   */
  onBlur = new EventEmitter();
  /**
   * @hidden
   */
  minimize = new EventEmitter();
  canvas;
  minimizeButton;
  maximizeButton;
  /**
   * Indicates if the Signature wrapper is focused.
   */
  isFocused = false;
  /**
   * Indicates if the Signature popup is open.
   */
  isOpen;
  /**
   * @hidden
   */
  get isEmpty() {
    return !this.value;
  }
  /**
   * @hidden
   */
  get canvasLabel() {
    return this.getMessage("canvasLabel");
  }
  /**
   * @hidden
   */
  get clearTitle() {
    return this.getMessage("clear");
  }
  /**
   * @hidden
   */
  get minimizeTitle() {
    return this.getMessage("minimize");
  }
  /**
   * @hidden
   */
  get maximizeTitle() {
    return this.getMessage("maximize");
  }
  /**
   * @hidden
   */
  get baseWidth() {
    return this.width || this.element.nativeElement.offsetWidth;
  }
  /**
   * @hidden
   */
  get baseHeight() {
    return this.height || this.element.nativeElement.offsetHeight;
  }
  /**
   * @hidden
   */
  get popupWidth() {
    return this.baseWidth * this.popupScale;
  }
  /**
   * @hidden
   */
  get popupHeight() {
    return this.baseHeight * this.popupScale;
  }
  /**
   * @hidden
   */
  isDrawing = false;
  /**
   * @hidden
   */
  get showMaximize() {
    return !(this.maximized || this.isDrawing || !this.maximizable || this.disabled);
  }
  /**
   * @hidden
   */
  get showMinimize() {
    return this.maximized && !this.isDrawing;
  }
  /**
   * @hidden
   */
  get showClear() {
    return !(this.isEmpty || this.isDrawing || this.readonly || this.disabled);
  }
  /**
   * @hidden
   */
  get focused() {
    return this.isFocused;
  }
  set focused(value) {
    if (this.isFocused !== value && this.element) {
      const wrap = this.element.nativeElement;
      if (value && !this.maximized) {
        this.renderer.addClass(wrap, FOCUSED_CLASS);
      } else {
        this.renderer.removeClass(wrap, FOCUSED_CLASS);
      }
      this.isFocused = value;
    }
  }
  get options() {
    return {
      scale: this.maximized ? this.popupScale : 1,
      color: this.color,
      backgroundColor: this.backgroundColor,
      strokeWidth: this.strokeWidth,
      smooth: this.smooth,
      readonly: this.readonly
    };
  }
  notifyNgTouched = noop4;
  notifyNgChanged = noop4;
  instance;
  _value;
  _tabindex = 0;
  subscriptions;
  unsubscribe;
  hostClasses = [];
  constructor(element, renderer, ngZone, cd, localization, cdr) {
    this.element = element;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.cd = cd;
    this.localization = localization;
    this.cdr = cdr;
    validatePackage(packageMetadata2);
    this.direction = localization.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.subscriptions = this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngAfterViewInit() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.applyHostClasses();
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.readThemeColors();
      this.instance.setOptions(this.options);
    });
    this.ngZone.runOutsideAngular(() => {
      const element = this.canvas.nativeElement;
      this.instance = new SignaturePad(element, __spreadProps(__spreadValues({}, this.options), {
        onChange: () => this.onValueChange(),
        onDraw: () => this.onDraw(),
        onDrawEnd: () => this.onDrawEnd()
      }));
      if (this.value) {
        this.instance.loadImage(this.value);
      }
      if (this.maximized) {
        this.ngZone.onStable.pipe(take(1)).subscribe(() => {
          this.minimizeButton?.nativeElement.focus();
        });
      }
      this.addEventListeners();
    });
  }
  ngOnChanges(changes) {
    if (anyChanged(["readonly", "color", "backgroundColor", "strokeWidth", "smooth"], changes, true)) {
      this.instance.setOptions(this.options);
    }
    this.applyHostClasses();
  }
  ngOnDestroy() {
    if (this.instance) {
      this.instance.destroy();
      this.instance = null;
    }
    if (this.subscriptions) {
      this.subscriptions.unsubscribe();
      this.subscriptions = null;
    }
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }
  }
  /**
   * @hidden
   */
  onClear() {
    this.reset();
    this.valueChange.emit(void 0);
    this.canvas.nativeElement.focus();
  }
  /**
   * @hidden
   */
  onValueChange() {
    return __async(this, null, function* () {
      const value = yield this.instance.exportImage({
        width: this.baseWidth * this.exportScale,
        height: this.baseHeight * this.exportScale
      });
      this._value = value;
      this.cd.markForCheck();
      this.ngZone.run(() => {
        this.valueChange.emit(value);
        this.notifyNgChanged(value);
      });
    });
  }
  /**
   * @hidden
   */
  onDialogValueChange(value) {
    this.value = value;
    this.valueChange.emit(value);
    this.notifyNgTouched();
    this.notifyNgChanged(value);
  }
  /**
   * @hidden
   */
  onDialogClick(e) {
    if (e.target.classList.contains("k-overlay")) {
      this.isOpen = false;
      this.maximizeButton?.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onDialogKeydown(e) {
    if (e.keyCode === Keys.Escape) {
      this.isOpen = false;
      this.cd.detectChanges();
      this.maximizeButton?.nativeElement.focus();
    }
  }
  /**
   * @hidden
   */
  onDialogClose() {
    const args = new SignatureCloseEvent();
    this.close.next(args);
    if (!args.isDefaultPrevented()) {
      this.isOpen = false;
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        (this.maximizeButton || this.element)?.nativeElement?.focus();
      });
    }
  }
  /**
   * Clears the value of the Signature.
   */
  reset() {
    if (!isPresent3(this.value)) {
      return;
    }
    this.instance?.clear();
    this.value = this._value = void 0;
    this.notifyNgChanged(void 0);
  }
  /**
   * Toggles the popup of the Signature.
   *
   * Does not trigger the `open` and `close` events.
   *
   * @param open Optional. Set to `true` to open or `false` to close the popup.
   */
  toggle(open) {
    if (this.disabled || this.readonly) {
      return;
    }
    open = isPresent3(open) ? open : !this.isOpen;
    this.isOpen = open;
  }
  /**
   * @hidden
   */
  onMaximize() {
    return __async(this, null, function* () {
      const args = new SignatureOpenEvent();
      this.open.next(args);
      if (!args.isDefaultPrevented()) {
        this.popupValue = yield this.instance.exportImage({
          width: this.popupWidth * this.exportScale,
          height: this.popupHeight * this.exportScale
        });
        this.isOpen = true;
        this.cd.detectChanges();
      }
    });
  }
  /**
   * @hidden
   */
  onMinimize() {
    this.minimize.next();
  }
  applyHostClasses() {
    const classList = this.element.nativeElement.classList;
    this.hostClasses.forEach(([name]) => classList.remove(name));
    this.hostClasses = [[`k-signature-${SIZE_MAP[this.size || DEFAULT_SIZE$2]}`, !isNone(this.size)], [`k-input-${this.fillMode || DEFAULT_FILL_MODE$2}`, !isNone(this.fillMode)], [`k-rounded-${ROUNDED_MAP[this.rounded || DEFAULT_ROUNDED$2]}`, !isNone(this.rounded)]];
    this.hostClasses.forEach(([name, enabled]) => classList.toggle(name, enabled));
  }
  readThemeColors() {
    let defaultColor = DEFAULT_COLOR2;
    let defaultBackgroundColor = DEFAULT_BACKGROUND_COLOR2;
    if (isDocumentAvailable()) {
      const el = this.element.nativeElement;
      defaultColor = getComputedStyle(el).color;
      defaultBackgroundColor = getComputedStyle(el).backgroundColor;
    }
    this.color = this.color || defaultColor;
    this.backgroundColor = this.backgroundColor || defaultBackgroundColor;
  }
  /**
   * Focuses the Signature wrapper container.
   */
  focus() {
    this.focused = true;
    this.element.nativeElement.focus();
  }
  /**
   * @hidden
   */
  onWrapperFocus() {
    if (this.focused) {
      return;
    }
    this.ngZone.run(() => {
      this.focus();
      this.onFocus.emit();
    });
  }
  /**
   * Blurs the Signature.
   */
  blur() {
    this.focused = false;
    this.element.nativeElement.blur();
    this.notifyNgTouched();
  }
  /**
   * @hidden
   */
  onWrapperBlur() {
    if (this.isOpen) {
      return;
    }
    this.ngZone.run(() => {
      this.onBlur.emit();
      this.focused = false;
      this.notifyNgTouched();
    });
  }
  /**
   * @hidden
   */
  onWrapperClick(_event) {
    if (this.disabled) {
      return;
    }
    this.focus();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.notifyNgChanged = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.notifyNgTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  popupValue;
  onDraw() {
    this.isDrawing = true;
    this.cd.markForCheck();
  }
  onDrawEnd() {
    this.isDrawing = false;
    this.cd.markForCheck();
  }
  addEventListeners() {
    const element = this.element.nativeElement;
    const focusIn = this.renderer.listen(element, "focusin", () => this.onWrapperFocus());
    const focusOut = this.renderer.listen(element, "focusout", (e) => {
      const insideWrapper = closest(e.relatedTarget, (element2) => element2 === this.element.nativeElement);
      if (!insideWrapper) {
        this.onWrapperBlur();
      }
    });
    const click = this.renderer.listen(element, "click", () => {
      this.ngZone.run((e) => {
        this.onWrapperClick(e);
      });
    });
    this.unsubscribe = () => {
      focusIn();
      focusOut();
      click();
    };
  }
  getMessage(key) {
    if (this.maximized && this.parentLocalization) {
      return this.parentLocalization.get(key);
    }
    return this.localization.get(key);
  }
  static ɵfac = function SignatureComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SignatureComponent,
    selectors: [["kendo-signature"]],
    viewQuery: function SignatureComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c64, 5);
        ɵɵviewQuery(_c65, 5, ElementRef);
        ɵɵviewQuery(_c66, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.canvas = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.minimizeButton = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.maximizeButton = _t.first);
      }
    },
    hostVars: 13,
    hostBindings: function SignatureComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵstyleProp("width", ctx.width, "px")("height", ctx.height, "px");
        ɵɵclassProp("k-signature", ctx.staticHostClasses)("k-input", ctx.staticHostClasses)("k-readonly", ctx.readonly)("k-disabled", ctx.disabled);
      }
    },
    inputs: {
      focusableId: "focusableId",
      readonly: "readonly",
      disabled: "disabled",
      width: "width",
      height: "height",
      value: "value",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      color: "color",
      backgroundColor: "backgroundColor",
      strokeWidth: "strokeWidth",
      smooth: "smooth",
      maximizable: "maximizable",
      maximized: "maximized",
      popupScale: "popupScale",
      exportScale: "exportScale",
      parentLocalization: "parentLocalization",
      hideLine: "hideLine"
    },
    outputs: {
      valueChange: "valueChange",
      open: "open",
      close: "close",
      onFocus: "focus",
      onBlur: "blur",
      minimize: "minimize"
    },
    exportAs: ["kendoSignature"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.signature"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _SignatureComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 10,
    vars: 8,
    consts: () => {
      let i18n_77;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_77 = goog.getMsg("Clear");
        i18n_77 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_77;
      } else {
        i18n_77 = $localize`:kendo.signature.clear|The message for the Clear button.:Clear`;
      }
      let i18n_78;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78 = goog.getMsg("Maximize");
        i18n_78 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_78;
      } else {
        i18n_78 = $localize`:kendo.signature.maximize|The message for the Maximize button.:Maximize`;
      }
      let i18n_79;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_79 = goog.getMsg("Minimize");
        i18n_79 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_79;
      } else {
        i18n_79 = $localize`:kendo.signature.minimize|The message for the Minimize button.:Minimize`;
      }
      let i18n_80;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80 = goog.getMsg("Signature canvas");
        i18n_80 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_80;
      } else {
        i18n_80 = $localize`:kendo.signature.canvasLabel|The message for the Canvas element aria-label.:Signature canvas`;
      }
      return [["canvas", ""], ["maximize", ""], ["minimize", ""], ["kendoSignatureLocalizedMessages", "", "clear", i18n_77, "maximize", i18n_78, "minimize", i18n_79, "canvasLabel", i18n_80], ["role", "img", 1, "k-signature-canvas", 3, "id"], [1, "k-signature-actions", "k-signature-actions-top"], ["kendoButton", "", "type", "button", "class", "k-signature-action k-signature-maximize", "icon", "hyperlink-open", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["kendoButton", "", "type", "button", "class", "k-signature-action k-signature-minimize k-rotate-180", "icon", "hyperlink-open", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["class", "k-signature-line", 4, "ngIf"], [1, "k-signature-actions", "k-signature-actions-bottom"], ["kendoButton", "", "class", "k-signature-action k-signature-clear", "icon", "close", "type", "button", "fillMode", "flat", 3, "svgIcon", "size", "title", "click", 4, "ngIf"], ["autoFocusedElement", ".k-signature-action.k-signature-minimize", 3, "click", "keydown", 4, "ngIf"], ["kendoButton", "", "type", "button", "icon", "hyperlink-open", "fillMode", "flat", 1, "k-signature-action", "k-signature-maximize", 3, "click", "svgIcon", "size", "title"], ["kendoButton", "", "type", "button", "icon", "hyperlink-open", "fillMode", "flat", 1, "k-signature-action", "k-signature-minimize", "k-rotate-180", 3, "click", "svgIcon", "size", "title"], [1, "k-signature-line"], ["kendoButton", "", "icon", "close", "type", "button", "fillMode", "flat", 1, "k-signature-action", "k-signature-clear", 3, "click", "svgIcon", "size", "title"], ["autoFocusedElement", ".k-signature-action.k-signature-minimize", 3, "click", "keydown"], [3, "valueChange", "minimize", "readonly", "disabled", "size", "rounded", "fillMode", "color", "backgroundColor", "strokeWidth", "smooth", "value", "hideLine", "maximized", "width", "height", "popupScale", "exportScale", "parentLocalization"]];
    },
    template: function SignatureComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 3);
        ɵɵelement(1, "div", 4, 0);
        ɵɵelementStart(3, "div", 5);
        ɵɵtemplate(4, SignatureComponent_button_4_Template, 2, 4, "button", 6)(5, SignatureComponent_button_5_Template, 2, 4, "button", 7);
        ɵɵelementEnd();
        ɵɵtemplate(6, SignatureComponent_div_6_Template, 1, 0, "div", 8);
        ɵɵelementStart(7, "div", 9);
        ɵɵtemplate(8, SignatureComponent_button_8_Template, 1, 4, "button", 10);
        ɵɵelementEnd();
        ɵɵtemplate(9, SignatureComponent_kendo_dialog_9_Template, 2, 19, "kendo-dialog", 11);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId);
        ɵɵattribute("tabindex", ctx.tabindex)("aria-label", ctx.canvasLabel);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.showMaximize);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.showMinimize);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.hideLine);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.showClear);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.isOpen);
      }
    },
    dependencies: [_SignatureComponent, LocalizedSignatureMessagesDirective, NgIf, ButtonComponent, DialogComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoSignature",
      selector: "kendo-signature",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.signature"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => SignatureComponent)
      }],
      template: `
        <ng-container kendoSignatureLocalizedMessages
            i18n-clear="kendo.signature.clear|The message for the Clear button."
            clear="Clear"
            i18n-maximize="kendo.signature.maximize|The message for the Maximize button."
            maximize="Maximize"
            i18n-minimize="kendo.signature.minimize|The message for the Minimize button."
            minimize="Minimize"
            i18n-canvasLabel="kendo.signature.canvasLabel|The message for the Canvas element aria-label."
            canvasLabel="Signature canvas">
        </ng-container>

        <div
            #canvas
            class="k-signature-canvas"
            [attr.tabindex]="tabindex"
            [id]="focusableId"
            role="img"
            [attr.aria-label]="canvasLabel"
        ></div>

        <div class="k-signature-actions k-signature-actions-top">
            <button
                #maximize
                *ngIf="showMaximize"
                kendoButton
                type="button"
                class="k-signature-action k-signature-maximize"
                icon="hyperlink-open"
                [svgIcon]="svgIcon('hyperlinkOpenIcon')"
                fillMode="flat"
                [size]="size"
                (click)="onMaximize()"
                [attr.aria-label]="maximizeTitle"
                [title]="maximizeTitle">
            </button>
            <button
                #minimize
                *ngIf="showMinimize"
                kendoButton
                type="button"
                class="k-signature-action k-signature-minimize k-rotate-180"
                icon="hyperlink-open"
                [svgIcon]="svgIcon('hyperlinkOpenIcon')"
                fillMode="flat"
                [size]="size"
                (click)="onMinimize()"
                [attr.aria-label]="minimizeTitle"
                [title]="minimizeTitle">
            </button>
        </div>
        <div
            *ngIf="!hideLine"
            class="k-signature-line"
        ></div>
        <div class="k-signature-actions k-signature-actions-bottom">
            <button
                *ngIf="showClear"
                kendoButton
                class="k-signature-action k-signature-clear"
                icon="close"
                type="button"
                [svgIcon]="svgIcon('xIcon')"
                fillMode="flat"
                [size]="size"
                [attr.aria-label]="clearTitle"
                [title]="clearTitle"
                (click)="onClear()" >
            </button>
        </div>

        <kendo-dialog
            *ngIf="isOpen"
            autoFocusedElement=".k-signature-action.k-signature-minimize"
            (click)="onDialogClick($event)"
            (keydown)="onDialogKeydown($event)">
            <kendo-signature
                [readonly]="readonly"
                [disabled]="disabled"
                [size]="size"
                [rounded]="rounded"
                [fillMode]="fillMode"
                [color]="color"
                [backgroundColor]="backgroundColor"
                [strokeWidth]="strokeWidth"
                [smooth]="smooth"
                [value]="popupValue"
                (valueChange)="onDialogValueChange($event)"
                [hideLine]="hideLine"
                [class.k-signature-maximized]="true"
                [maximized]="true"
                (minimize)="onDialogClose()"
                [width]="popupWidth"
                [height]="popupHeight"
                [popupScale]="popupScale"
                [exportScale]="(1 / popupScale) * exportScale"
                [parentLocalization]="localization">
            </kendo-signature>
        </kendo-dialog>
    `,
      standalone: true,
      imports: [LocalizedSignatureMessagesDirective, NgIf, ButtonComponent, DialogComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    staticHostClasses: [{
      type: HostBinding,
      args: ["class.k-signature"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    focusableId: [{
      type: Input
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    readonly: [{
      type: HostBinding,
      args: ["class.k-readonly"]
    }, {
      type: Input
    }],
    disabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: Input
    }],
    width: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.width.px"]
    }],
    height: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["style.height.px"]
    }],
    value: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }],
    strokeWidth: [{
      type: Input
    }],
    smooth: [{
      type: Input
    }],
    maximizable: [{
      type: Input
    }],
    maximized: [{
      type: Input
    }],
    popupScale: [{
      type: Input
    }],
    exportScale: [{
      type: Input
    }],
    parentLocalization: [{
      type: Input
    }],
    hideLine: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    minimize: [{
      type: Output
    }],
    canvas: [{
      type: ViewChild,
      args: ["canvas"]
    }],
    minimizeButton: [{
      type: ViewChild,
      args: ["minimize", {
        read: ElementRef
      }]
    }],
    maximizeButton: [{
      type: ViewChild,
      args: ["maximize", {
        read: ElementRef
      }]
    }]
  });
})();
var SliderCustomMessagesComponent = class _SliderCustomMessagesComponent extends SliderMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SliderCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SliderCustomMessagesComponent,
    selectors: [["kendo-slider-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: SliderMessages,
      useExisting: forwardRef(() => _SliderCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function SliderCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: SliderMessages,
        useExisting: forwardRef(() => SliderCustomMessagesComponent)
      }],
      selector: "kendo-slider-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SwitchCustomMessagesComponent = class _SwitchCustomMessagesComponent extends Messages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function SwitchCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SwitchCustomMessagesComponent,
    selectors: [["kendo-switch-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages,
      useExisting: forwardRef(() => _SwitchCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function SwitchCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages,
        useExisting: forwardRef(() => SwitchCustomMessagesComponent)
      }],
      selector: "kendo-switch-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var TextAreaPrefixComponent = class _TextAreaPrefixComponent {
  /**
   * @hidden
   */
  flow = "vertical";
  /**
   * @hidden
   */
  orientation = "horizontal";
  hostClass = true;
  get verticalOrientation() {
    return this.orientation === "vertical";
  }
  get horizontalOrientation() {
    return this.orientation === "horizontal";
  }
  get alignItems() {
    return this.flow === this.orientation;
  }
  static ɵfac = function TextAreaPrefixComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaPrefixComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaPrefixComponent,
    selectors: [["kendo-textarea-prefix"]],
    hostVars: 8,
    hostBindings: function TextAreaPrefixComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-prefix", ctx.hostClass)("k-input-prefix-vertical", ctx.verticalOrientation)("k-input-prefix-horizontal", ctx.horizontalOrientation)("!k-align-items-start", ctx.alignItems);
      }
    },
    inputs: {
      flow: "flow",
      orientation: "orientation"
    },
    exportAs: ["kendoTextAreaPrefix"],
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c58,
    decls: 1,
    vars: 0,
    template: function TextAreaPrefixComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaPrefixComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextAreaPrefix",
      selector: "kendo-textarea-prefix",
      template: `<ng-content></ng-content>`,
      standalone: true
    }]
  }], null, {
    flow: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-prefix"]
    }],
    verticalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-prefix-vertical"]
    }],
    horizontalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-prefix-horizontal"]
    }],
    alignItems: [{
      type: HostBinding,
      args: ["class.!k-align-items-start"]
    }]
  });
})();
var TextAreaSuffixComponent = class _TextAreaSuffixComponent {
  /**
   * @hidden
   */
  flow = "vertical";
  /**
   * @hidden
   */
  orientation = "horizontal";
  hostClass = true;
  get verticalOrientation() {
    return this.orientation === "vertical";
  }
  get horizontalOrientation() {
    return this.orientation === "horizontal";
  }
  get alignItems() {
    return this.flow === this.orientation;
  }
  static ɵfac = function TextAreaSuffixComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaSuffixComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaSuffixComponent,
    selectors: [["kendo-textarea-suffix"]],
    hostVars: 8,
    hostBindings: function TextAreaSuffixComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-input-suffix", ctx.hostClass)("k-input-suffix-vertical", ctx.verticalOrientation)("k-input-suffix-horizontal", ctx.horizontalOrientation)("!k-align-items-start", ctx.alignItems);
      }
    },
    inputs: {
      flow: "flow",
      orientation: "orientation"
    },
    exportAs: ["kendoTextAreaSuffix"],
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c58,
    decls: 1,
    vars: 0,
    template: function TextAreaSuffixComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaSuffixComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextAreaSuffix",
      selector: "kendo-textarea-suffix",
      template: `<ng-content></ng-content>`,
      standalone: true
    }]
  }], null, {
    flow: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-input-suffix"]
    }],
    verticalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-suffix-vertical"]
    }],
    horizontalOrientation: [{
      type: HostBinding,
      args: ["class.k-input-suffix-horizontal"]
    }],
    alignItems: [{
      type: HostBinding,
      args: ["class.!k-align-items-start"]
    }]
  });
})();
var TextFieldsBase = class _TextFieldsBase {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * Sets the `title` attribute of the internal textarea input element of the component.
   */
  title = "";
  /**
   * Sets the disabled state of the TextArea component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_textarea#toc-managing-the-textarea-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the read-only state of the TextArea component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Provides a value for the TextArea component.
   */
  value = null;
  /**
   * Determines whether the whole value will be selected when the TextArea is clicked. Defaults to `false`.
   *
   * @default false
   */
  selectOnFocus = false;
  /**
   * The hint, which is displayed when the Textarea is empty.
   */
  placeholder;
  /**
   * Fires each time the user focuses the internal textarea element of the component.
   * This event is useful when you need to distinguish between focusing the textarea element and focusing one of its adornments.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the internal textarea element gets blurred.
   * This event is useful when adornments are used, in order to distinguish between blurring the textarea element and blurring the whole TextArea component.
   */
  inputBlur = new EventEmitter();
  /**
   * Represents the visible textarea element of the component.
   */
  input;
  get disabledClass() {
    return this.disabled;
  }
  direction;
  /**
   * @hidden
   */
  control;
  subscriptions = new Subscription();
  _isFocused = false;
  focusChangedProgrammatically = false;
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  handleInputBlur = () => {
    this.changeDetector.markForCheck();
    if (hasObservers(this.inputBlur) || requiresZoneOnBlur(this.control)) {
      this.ngZone.run(() => {
        this.ngTouched();
        this.inputBlur.emit();
      });
    }
  };
  /**
   * @hidden
   * Called when the status of the component changes to or from `disabled`.
   * Depending on the value, it enables or disables the appropriate DOM element.
   *
   * @param isDisabled
   */
  setDisabledState(isDisabled2) {
    this.changeDetector.markForCheck();
    this.disabled = isDisabled2;
  }
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  static ɵfac = function TextFieldsBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextFieldsBase)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextFieldsBase,
    selectors: [["kendo-textfield-base"]],
    viewQuery: function TextFieldsBase_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c17, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      }
    },
    hostVars: 5,
    hostBindings: function TextFieldsBase_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-disabled", ctx.disabledClass);
      }
    },
    inputs: {
      title: "title",
      disabled: "disabled",
      readonly: "readonly",
      value: "value",
      selectOnFocus: "selectOnFocus",
      placeholder: "placeholder"
    },
    outputs: {
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    decls: 0,
    vars: 0,
    template: function TextFieldsBase_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextFieldsBase, [{
    type: Component,
    args: [{
      selector: "kendo-textfield-base",
      template: ``
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    title: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    value: [{
      type: Input
    }],
    selectOnFocus: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    input: [{
      type: ViewChild,
      args: ["input", {
        static: true
      }]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var resizeClasses = {
  "vertical": "k-resize-y",
  "horizontal": "k-resize-x",
  "both": "k-resize",
  "none": "k-resize-none",
  "auto": "k-resize-none"
};
var FOCUSED = "k-focus";
var DEFAULT_SIZE$1 = "medium";
var DEFAULT_ROUNDED$1 = "medium";
var DEFAULT_FILL_MODE$1 = "solid";
var TextAreaComponent = class _TextAreaComponent extends TextFieldsBase {
  localizationService;
  ngZone;
  changeDetector;
  renderer;
  injector;
  hostElement;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  hostClasses = true;
  get flowCol() {
    return this.flow === "vertical";
  }
  get flowRow() {
    return this.flow === "horizontal";
  }
  _flow = "vertical";
  /**
   * Specifies the flow direction of the TextArea sections. Use this property to set the position of adornments relative to the text area.
   */
  set flow(flow) {
    this._flow = flow;
    if (this.prefix) {
      this.prefix.flow = flow;
    }
    if (this.suffix) {
      this.suffix.flow = flow;
    }
  }
  get flow() {
    return this._flow;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Some attributes are required for component functionality and cannot be changed.
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Specifies the orientation of the TextArea adornments. Use this property to set the position of adornments relative to each other.
   *
   */
  set adornmentsOrientation(orientation) {
    this._adornmentsOrientation = orientation;
    if (this.prefix) {
      this.prefix.orientation = orientation;
    }
    if (this.suffix) {
      this.suffix.orientation = orientation;
    }
  }
  get adornmentsOrientation() {
    return this._adornmentsOrientation;
  }
  /**
   * Sets the visible height of the text area in lines.
   */
  rows;
  /**
   * Sets the visible width of the text area in average character width.
   */
  cols;
  /**
   * Sets the maximum number of characters allowed in the text area.
   */
  maxlength;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the resize behavior of the TextArea.
   *
   *
   * @default 'vertical'
   */
  resizable = "vertical";
  /**
   * Sets the size of the TextArea. Controls the padding of the text area element ([see example]({% slug appearance_textarea %}#toc-size)).
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$1;
    this.handleClasses(newSize, "size");
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the TextArea ([see example](slug:appearance_textarea#toc-roundness)).
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$1;
    this.handleClasses(newRounded, "rounded");
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the background and border styles of the TextArea ([see example](slug:appearance_textarea#toc-fill-mode)).
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$1;
    this.handleClasses(newFillMode, "fillMode");
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Shows the prefix separator in the TextArea.
   * The separator is rendered only if a prefix template is declared.
   *
   * @default false
   */
  showPrefixSeparator = false;
  /**
   * Shows the suffix separator in the TextArea.
   * The separator is rendered only if a suffix template is declared.
   *
   * @default false
   */
  showSuffixSeparator = false;
  /**
   * Fires when the TextArea is focused.
   *
   * Use the `onFocus` property to subscribe to this event.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the TextArea gets blurred.
   *
   * Use the `onBlur` property to subscribe to this event.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the value changes or the TextArea is blurred ([see example](slug:events_textarea)).
   *
   * The event does not fire when the value changes programmatically or through form control binding.
   */
  valueChange = new EventEmitter();
  initialHeight;
  resizeSubscription;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _adornmentsOrientation = "horizontal";
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.focusableId,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      tabindex: this.disabled ? void 0 : this.tabIndex,
      placeholder: this.placeholder,
      title: this.title,
      maxlength: this.maxlength,
      rows: this.rows,
      cols: this.cols,
      "aria-disabled": this.disabled ? true : void 0,
      "aria-readonly": this.readonly ? true : void 0,
      "aria-invalid": this.isControlInvalid,
      required: this.isControlRequired ? "" : null
    };
  }
  get mutableAttributes() {
    return {
      "aria-multiline": "true"
    };
  }
  constructor(localizationService, ngZone, changeDetector, renderer, injector, hostElement) {
    super(localizationService, ngZone, changeDetector, renderer, injector, hostElement);
    this.localizationService = localizationService;
    this.ngZone = ngZone;
    this.changeDetector = changeDetector;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    validatePackage(packageMetadata2);
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.handleFlow();
    });
    const stylingInputs = ["size", "rounded", "fillMode"];
    stylingInputs.forEach((input) => {
      this.handleClasses(this[input], input);
    });
  }
  ngOnInit() {
    this.control = this.injector.get(NgControl, null);
    if (isDocumentAvailable() && this.resizable === "auto") {
      this.resizeSubscription = fromEvent(window, "resize").pipe(debounceTime(50)).subscribe(() => this.resize());
    }
    if (this.hostElement) {
      this.renderer.removeAttribute(this.hostElement.nativeElement, "tabindex");
    }
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
  }
  ngOnChanges(changes) {
    const hostElement = this.hostElement.nativeElement;
    const element = this.input.nativeElement;
    if (changes.flow) {
      this.handleFlow();
    }
    if (changes.resizable) {
      if (this.resizable === "auto") {
        this.renderer.removeClass(element, "!k-overflow-y-auto");
        this.initialHeight = element.offsetHeight;
      } else if (this.resizable !== "both") {
        this.renderer.addClass(element, "!k-overflow-y-auto");
        element.style.height = `${this.initialHeight}px`;
      }
    }
    if (changes.cols) {
      if (isPresent3(changes.cols.currentValue)) {
        this.renderer.setStyle(hostElement, "width", "auto");
      } else {
        this.renderer.removeStyle(hostElement, "width");
      }
    }
    if (changes.value) {
      this.resize();
    }
  }
  /**
   * @hidden
   */
  prefix;
  /**
   * @hidden
   */
  suffix;
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
    this.resize();
    this.changeDetector.markForCheck();
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  updateValue(value) {
    if (!areSame(this.value, value)) {
      this.ngZone.run(() => {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.changeDetector.markForCheck();
      });
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.resizeSubscription) {
      this.resizeSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  get resizableClass() {
    return resizeClasses[this.resizable];
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.control && this.control.touched && !this.control.valid;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.control?.control);
  }
  /**
   * @hidden
   */
  get separatorOrientation() {
    return this.flow === "horizontal" ? "vertical" : "horizontal";
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      const element = this.hostElement.nativeElement;
      if (value && !this.disabled) {
        this.renderer.addClass(element, FOCUSED);
      } else {
        this.renderer.removeClass(element, FOCUSED);
      }
      this._isFocused = value;
    }
  }
  /**
   * @hidden
   */
  handleInput = (ev) => {
    const incomingValue = ev.target.value;
    this.updateValue(incomingValue);
    this.resize();
  };
  /**
   * @hidden
   */
  handleInputFocus = () => {
    if (!this.disabled) {
      if (this.selectOnFocus && this.value) {
        this.ngZone.run(() => {
          setTimeout(() => {
            this.selectAll();
          });
        });
      }
      if (!this.isFocused) {
        this.handleFocus();
      }
      if (hasObservers(this.inputFocus)) {
        if (!this.focusChangedProgrammatically) {
          this.ngZone.run(() => {
            this.inputFocus.emit();
          });
        }
      }
    }
  };
  /**
   * Focuses the TextArea.
   */
  focus() {
    if (!this.input) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.input.nativeElement.focus();
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the TextArea.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  resize() {
    if (this.resizable !== "auto") {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      setTimeout(() => {
        const hostElement = this.hostElement.nativeElement;
        const element = this.input.nativeElement;
        this.renderer.setStyle(element, "height", `${this.initialHeight}px`);
        const scrollHeight = element.scrollHeight;
        this.renderer.setStyle(hostElement, "min-height", `${scrollHeight}px`);
        if (scrollHeight > this.initialHeight) {
          this.renderer.setStyle(element, "height", `${scrollHeight}px`);
        }
      }, 0);
    });
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.changeDetector.markForCheck();
    this.ngZone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  setSelection(start, end) {
    if (this.isFocused) {
      invokeElementMethod(this.input, "setSelectionRange", start, end);
    }
  }
  selectAll() {
    if (this.value) {
      this.setSelection(0, this.value.length);
    }
  }
  handleClasses(value, input) {
    const elem = this.hostElement.nativeElement;
    const classes = getStylingClasses("input", input, this[input], value);
    if (classes.toRemove) {
      this.renderer.removeClass(elem, classes.toRemove);
    }
    if (classes.toAdd) {
      this.renderer.addClass(elem, classes.toAdd);
    }
  }
  handleFlow() {
    const isVertical = this.flow === "vertical";
    const element = this.input.nativeElement;
    this.renderer[isVertical ? "addClass" : "removeClass"](element, "!k-flex-none");
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function TextAreaComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextAreaComponent,
    selectors: [["kendo-textarea"]],
    contentQueries: function TextAreaComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, TextAreaPrefixComponent, 5);
        ɵɵcontentQuery(dirIndex, TextAreaSuffixComponent, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefix = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffix = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function TextAreaComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-textarea", ctx.hostClasses)("k-input", ctx.hostClasses)("!k-flex-col", ctx.flowCol)("!k-flex-row", ctx.flowRow);
      }
    },
    inputs: {
      focusableId: "focusableId",
      flow: "flow",
      inputAttributes: "inputAttributes",
      adornmentsOrientation: "adornmentsOrientation",
      rows: "rows",
      cols: "cols",
      maxlength: "maxlength",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      resizable: "resizable",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      showPrefixSeparator: "showPrefixSeparator",
      showSuffixSeparator: "showSuffixSeparator"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange"
    },
    exportAs: ["kendoTextArea"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.textarea"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _TextAreaComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _TextAreaComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    ngContentSelectors: _c68,
    decls: 7,
    vars: 26,
    consts: [["input", ""], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], [3, "orientation", 4, "ngIf"], [1, "k-input-inner", "!k-overflow-auto", 3, "id", "ngClass", "value", "disabled", "readonly", "kendoEventsOutsideAngular"], [3, "orientation"]],
    template: function TextAreaComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c67);
        ɵɵelementContainerStart(0, 1);
        ɵɵtwoWayListener("isFocusedChange", function TextAreaComponent_Template_ng_container_isFocusedChange_0_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function TextAreaComponent_Template_ng_container_handleBlur_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function TextAreaComponent_Template_ng_container_onFocus_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵprojection(1);
        ɵɵtemplate(2, TextAreaComponent_kendo_input_separator_2_Template, 1, 1, "kendo-input-separator", 2);
        ɵɵelement(3, "textarea", 3, 0);
        ɵɵtemplate(5, TextAreaComponent_kendo_input_separator_5_Template, 1, 1, "kendo-input-separator", 2);
        ɵɵprojection(6, 1);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.prefix && ctx.showPrefixSeparator);
        ɵɵadvance();
        ɵɵproperty("id", ctx.focusableId)("ngClass", ctx.resizableClass)("value", ctx.value)("disabled", ctx.disabled)("readonly", ctx.readonly)("kendoEventsOutsideAngular", ɵɵpureFunction3(22, _c20, ctx.handleInputFocus, ctx.handleInputBlur, ctx.handleInput));
        ɵɵattribute("aria-multiline", true)("aria-disabled", ctx.disabled ? true : void 0)("aria-readonly", ctx.readonly ? true : void 0)("aria-invalid", ctx.isControlInvalid)("required", ctx.isControlRequired ? "" : null)("placeholder", ctx.placeholder)("rows", ctx.rows)("cols", ctx.cols)("tabindex", ctx.tabIndex)("title", ctx.title)("maxlength", ctx.maxlength)("aria-invalid", ctx.isControlInvalid);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.suffix && ctx.showSuffixSeparator);
      }
    },
    dependencies: [SharedInputEventsDirective, NgIf, InputSeparatorComponent, NgClass, EventsOutsideAngularDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoTextArea",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.textarea"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => TextAreaComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => TextAreaComponent)
      }],
      selector: "kendo-textarea",
      template: `
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <ng-content select="kendo-textarea-prefix"></ng-content>
            <kendo-input-separator
                *ngIf="prefix && showPrefixSeparator"
                [orientation]="separatorOrientation"
            ></kendo-input-separator>
            <textarea #input
                class="k-input-inner !k-overflow-auto"
                [attr.aria-multiline]="true"
                [attr.aria-disabled]="disabled ? true : undefined"
                [attr.aria-readonly]="readonly ? true : undefined"
                [attr.aria-invalid]="isControlInvalid"
                [id]="focusableId"
                [attr.required]="isControlRequired ? '' : null"
                [ngClass]="resizableClass"
                [value]="value"
                [attr.placeholder]="placeholder"
                [disabled]="disabled"
                [readonly]="readonly"
                [attr.rows]="rows"
                [attr.cols]="cols"
                [attr.tabindex]="tabIndex"
                [attr.title]="title"
                [attr.maxlength]="maxlength"
                [attr.aria-invalid]="isControlInvalid"
                [kendoEventsOutsideAngular]="{
                    focus: handleInputFocus,
                    blur: handleInputBlur,
                    input: handleInput}"
            ></textarea>
            <kendo-input-separator
                *ngIf="suffix && showSuffixSeparator"
                [orientation]="separatorOrientation"
            ></kendo-input-separator>
            <ng-content select="kendo-textarea-suffix"></ng-content>
        </ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, NgIf, InputSeparatorComponent, NgClass, EventsOutsideAngularDirective]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }];
  }, {
    focusableId: [{
      type: Input
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-textarea"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    flowCol: [{
      type: HostBinding,
      args: ["class.!k-flex-col"]
    }],
    flowRow: [{
      type: HostBinding,
      args: ["class.!k-flex-row"]
    }],
    flow: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    adornmentsOrientation: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    cols: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    resizable: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    showPrefixSeparator: [{
      type: Input
    }],
    showSuffixSeparator: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    prefix: [{
      type: ContentChild,
      args: [TextAreaPrefixComponent]
    }],
    suffix: [{
      type: ContentChild,
      args: [TextAreaSuffixComponent]
    }]
  });
})();
var TextBoxCustomMessagesComponent = class _TextBoxCustomMessagesComponent extends TextBoxMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function TextBoxCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TextBoxCustomMessagesComponent,
    selectors: [["kendo-textbox-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TextBoxMessages,
      useExisting: forwardRef(() => _TextBoxCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function TextBoxCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TextBoxMessages,
        useExisting: forwardRef(() => TextBoxCustomMessagesComponent)
      }],
      selector: "kendo-textbox-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var OTPInputSeparatorComponent = class _OTPInputSeparatorComponent {
  set separator(otpSeparator) {
    this._separator = otpSeparator;
    this.clearSeparator();
    if (!isPresent(otpSeparator)) {
      return;
    }
    if (typeof otpSeparator === "string") {
      this.hasText = true;
      return;
    }
    if (typeof otpSeparator.value !== "string") {
      this.hasSVGIcon = otpSeparator?.type === "svgIcon";
      this.separatorSVGIcon = otpSeparator.value;
      return;
    }
    this.hasIconClass = otpSeparator?.type === "iconClass";
    this.hasFontIcon = otpSeparator?.type === "fontIcon";
    this.separatorIconString = otpSeparator.value;
  }
  get separator() {
    return this._separator;
  }
  wrapperClass = true;
  hasText;
  hasIconClass;
  hasSVGIcon;
  hasFontIcon;
  separatorIconString;
  separatorSVGIcon;
  _separator;
  clearSeparator() {
    this.hasText = false;
    this.hasFontIcon = false;
    this.hasIconClass = false;
    this.hasSVGIcon = false;
  }
  static ɵfac = function OTPInputSeparatorComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputSeparatorComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputSeparatorComponent,
    selectors: [["kendo-otpinput-separator"]],
    hostVars: 2,
    hostBindings: function OTPInputSeparatorComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-otp-separator", ctx.wrapperClass);
      }
    },
    inputs: {
      separator: "separator"
    },
    exportAs: ["kendoOTPInputSeparator"],
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 3,
    consts: [[4, "ngIf"], [3, "ngClass", 4, "ngIf"], [3, "name", "svgIcon", 4, "ngIf"], [3, "ngClass"], [3, "name", "svgIcon"]],
    template: function OTPInputSeparatorComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, OTPInputSeparatorComponent_ng_container_0_Template, 2, 1, "ng-container", 0)(1, OTPInputSeparatorComponent_span_1_Template, 1, 1, "span", 1)(2, OTPInputSeparatorComponent_kendo_icon_wrapper_2_Template, 1, 2, "kendo-icon-wrapper", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.hasText);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasIconClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.hasFontIcon || ctx.hasSVGIcon);
      }
    },
    dependencies: [NgIf, NgClass, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputSeparatorComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoOTPInputSeparator",
      selector: "kendo-otpinput-separator",
      template: `
        <ng-container *ngIf="hasText">{{this.separator}}</ng-container>
        <span *ngIf="hasIconClass" [ngClass]="separatorIconString"></span>
        <kendo-icon-wrapper
            *ngIf="hasFontIcon || hasSVGIcon"
            [name]="separatorIconString"
            [svgIcon]="separatorSVGIcon"
        ></kendo-icon-wrapper>
    `,
      standalone: true,
      imports: [NgIf, NgClass, IconWrapperComponent]
    }]
  }], null, {
    separator: [{
      type: Input
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-otp-separator"]
    }]
  });
})();
var OTPInputMessages = class _OTPInputMessages extends ComponentMessages {
  /**
   * The aria-label of the OTP Input. Follows the pattern **Input {currentInput} of {totalInputs}, current value {value}** by default.
   * Тhe default label text when the current input is 1, and the total number of inputs is 4 will be
   * **Input 1 of 4, current value null**.
   *
   * The message consists of several parts - the current input number, the total number of inputs, the current value and a localizable string.
   * To allow for reordering its parts, the `ariaLabel` input accepts a string with placeholders for the current input,
   * total number of inputs and current value. The `{currentInput}`, `{totalInputs}` and `{currentValue}` placeholders will be
   * replaced internally with the respective actual values.
   */
  ariaLabel;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵOTPInputMessages_BaseFactory;
    return function OTPInputMessages_Factory(__ngFactoryType__) {
      return (ɵOTPInputMessages_BaseFactory || (ɵOTPInputMessages_BaseFactory = ɵɵgetInheritedFactory(_OTPInputMessages)))(__ngFactoryType__ || _OTPInputMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _OTPInputMessages,
    selectors: [["kendo-otpinput-messages-base"]],
    inputs: {
      ariaLabel: "ariaLabel"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-otpinput-messages-base"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }]
  });
})();
var LocalizedOTPInputMessagesDirective = class _LocalizedOTPInputMessagesDirective extends OTPInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedOTPInputMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedOTPInputMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedOTPInputMessagesDirective,
    selectors: [["", "kendoOTPInputLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: OTPInputMessages,
      useExisting: forwardRef(() => _LocalizedOTPInputMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedOTPInputMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: OTPInputMessages,
        useExisting: forwardRef(() => LocalizedOTPInputMessagesDirective)
      }],
      selector: "[kendoOTPInputLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var DEFAULT_SIZE = "medium";
var DEFAULT_ROUNDED = "medium";
var DEFAULT_FILL_MODE = "solid";
var DEFAULT_OTPINPUT_LENGTH = 4;
var OTPInputComponent = class _OTPInputComponent {
  hostElement;
  cdr;
  injector;
  renderer;
  localizationService;
  zone;
  /**
   * Sets the total number of input fields.
   *
   * @default 4
   */
  set length(value) {
    if (value < 1 || this._length === value) {
      return;
    }
    this._length = value;
    this.inputsArray = new Array(this._length);
  }
  get length() {
    return this._length;
  }
  /**
   * Sets the input type.
   *
   *
   * @default 'text'
   */
  type = "text";
  /**
   * Sets whether the input fields are separate or adjacent.
   *
   * @default true
   */
  spacing = true;
  /**
   * Sets the separator between groups of input fields. You can use this only when `groupLength` is set.
   */
  separator;
  /**
   * When `true`, disables the OTPInput.
   *
   * @default false
   */
  disabled = false;
  /**
   * When `true`, sets the OTPInput to read-only mode.
   *
   * @default false
   */
  readonly = false;
  /**
   * Sets the placeholder for the input fields.
   */
  placeholder;
  /**
   * Sets the length of the groups. If you set a number, all groups have the same length. If you set an array, each group can have a different length.
   */
  get groupLength() {
    return this._groupLength;
  }
  set groupLength(length) {
    const isNumber3 = typeof length === "number";
    if (this._groupLength === length || isPresent(length) && (isNumber3 && (length < 1 || length > this.length) || !isNumber3 && !this.isValidGroupArray(length))) {
      return;
    }
    if (!isPresent(length)) {
      this.clearGroups();
    } else if (isNumber3) {
      this.populateGroupArray(length);
    } else {
      this.groupLengthArray = length;
      if (!this.spacing) {
        this.adjacentGroups = this.groupLengthArray;
      }
    }
    this._groupLength = length;
    this.populateSeparatorPositions();
  }
  /**
   * Sets the value of the component. Unfilled input fields are represented with а space.
   */
  get value() {
    return this._value;
  }
  set value(input) {
    const isInvalidInput = this.type === "number" && isPresent(input) && !this.containsDigitsOrSpaces(input);
    if (this._value === input || isInvalidInput) {
      return;
    }
    if (!isPresent(input)) {
      this.clearInputValues();
      this._value = null;
    } else {
      this._value = input.slice(0, this.length);
      if (!this.inputFieldValueChanged) {
        this.fillInputs(input, 0, true);
      }
    }
    if (this.inputAttributes) {
      this.setInputAttributes();
    } else {
      this.setDefaultAttributes();
    }
  }
  /**
   * Sets the padding of the input fields.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size || DEFAULT_SIZE;
    const elem = this.hostElement.nativeElement;
    this.renderer.removeClass(elem, `k-otp-${SIZE_MAP[this._size]}`);
    this.renderer.addClass(elem, `k-otp-${SIZE_MAP[newSize]}`);
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the OTP Input.
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    this._rounded = rounded || DEFAULT_ROUNDED;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the background and border styles of the OTP Input.
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode || DEFAULT_FILL_MODE;
    this.setGroupFillMode(newFillMode, this._fillMode);
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner input element. You cannot change attributes that are required for the component to work.
   */
  set inputAttributes(attributes) {
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? __spreadValues(__spreadValues({}, this.defaultAttributes), this.inputAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  /**
   * Fires when the user changes the value.
   *
   * This event does not fire when you change the value programmatically or through form bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the user focuses the OTP Input.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the user blurs the OTP Input.
   */
  onBlur = new EventEmitter();
  wrapperClass = true;
  get invalidClass() {
    return this.isControlInvalid;
  }
  direction;
  role = "group";
  /**
   * @hidden
   */
  inputFields;
  /**
   * @hidden
   */
  set inputGroups(elements) {
    this._inputGroups = elements;
    this.setGroupFillMode(this.fillMode);
  }
  get inputGroups() {
    return this._inputGroups;
  }
  /**
   * @hidden
   */
  groupLengthArray;
  /**
   * @hidden
   */
  inputsArray;
  /**
   * @hidden
   */
  inputsValues = [].constructor(DEFAULT_OTPINPUT_LENGTH);
  /**
   * @hidden
   */
  adjacentGroups;
  _length = DEFAULT_OTPINPUT_LENGTH;
  _groupLength;
  _inputGroups;
  separatorPositions = /* @__PURE__ */ new Set();
  _value = null;
  _size = DEFAULT_SIZE;
  _rounded = DEFAULT_ROUNDED;
  _fillMode = DEFAULT_FILL_MODE;
  _isFocused = false;
  focusChangedProgrammatically = false;
  inputFieldValueChanged = false;
  focusedInput;
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      autocomplete: "off"
    };
  }
  subscriptions;
  ngChange = (_) => {
  };
  ngTouched = () => {
  };
  constructor(hostElement, cdr, injector, renderer, localizationService, zone) {
    this.hostElement = hostElement;
    this.cdr = cdr;
    this.injector = injector;
    this.renderer = renderer;
    this.localizationService = localizationService;
    this.zone = zone;
    this.direction = localizationService.rtl ? "rtl" : "ltr";
  }
  ngOnInit() {
    this.inputsArray = Array.from({
      length: this._length
    });
    this.subscriptions = this.localizationService.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
    });
    this.zone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, "paste", this.handlePaste.bind(this)));
      this.subscriptions.add(this.renderer.listen(this.hostElement.nativeElement, "keydown", this.handleKeydown.bind(this)));
    });
  }
  ngAfterViewInit() {
    this.subscriptions.add(this.inputFields.changes.subscribe(this.handleInputChanges.bind(this)));
    this.handleInputChanges();
    this.renderer.addClass(this.hostElement.nativeElement, `k-otp-${SIZE_MAP[this._size]}`);
    this.setGroupFillMode(this.fillMode);
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.fillInputs(this.value);
    });
  }
  ngOnChanges(changes) {
    if (changes.length) {
      if (typeof this.groupLength === "number") {
        this.populateGroupArray(this.groupLength);
      }
      this.populateSeparatorPositions();
    }
    if (changes.spacing) {
      if (this.spacing === true) {
        this.adjacentGroups = null;
      } else {
        this.adjacentGroups = this.groupLengthArray ?? [this.length];
      }
    }
    if (changes.type && this.type === "number") {
      if (isPresent(this.value) && !this.containsDigitsOrSpaces(this.value)) {
        this.value = null;
        this.zone.runOutsideAngular(() => setTimeout(() => this.zone.run(() => {
          this.ngChange(null);
          this.cdr.markForCheck();
        })));
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.ngChange = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.ngTouched = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get isControlInvalid() {
    return this.formControl?.touched && this.formControl.invalid;
  }
  /**
   * @hidden
   */
  get isFocused() {
    return this._isFocused;
  }
  /**
   * @hidden
   */
  set isFocused(value) {
    if (this._isFocused !== value && this.hostElement) {
      this._isFocused = value;
    }
  }
  /**
   * Returns `true` if the component has groups.
   *
   * @hidden
   */
  get hasGroups() {
    if (!this.spacing && isPresent(this.groupLength)) {
      return true;
    }
  }
  /**
   * @hidden
   */
  showGroupSeparator(index) {
    return this.groupLengthArray && index < this.groupLengthArray.length - 1;
  }
  /**
   * @hidden
   */
  showSeparator(index) {
    return this.groupLength ? this.separatorPositions.has(index) : false;
  }
  /**
   * @hidden
   */
  handleValueChange(index, groupIndex) {
    this.inputFieldValueChanged = true;
    if (groupIndex) {
      index = this.getIndexByGroup(groupIndex, index);
    }
    let newValue = "";
    this.inputFields.forEach((input) => newValue = newValue.concat(input.value?.toString() || " "));
    if (!areSame(this.value, newValue)) {
      this.zone.run(() => {
        this.value = newValue;
        this.ngChange(newValue);
        this.valueChange.emit(newValue);
        this.cdr.markForCheck();
      });
    }
    this.inputFieldValueChanged = false;
    if (isPresent(index) && isPresent(this.inputFields?.get(index).value)) {
      this.focusNext();
    }
  }
  /**
   * @hidden
   */
  handleInputFocus(index, groupIndex) {
    if (this.focusChangedProgrammatically) {
      return;
    }
    if (groupIndex) {
      index = this.getIndexByGroup(groupIndex, index);
    }
    this.focusedInput = index;
  }
  /**
   * @hidden
   */
  handleInput(event, index, groupIndex) {
    if (this.type === "number" && !this.isValidNumber(event?.data)) {
      const inputIndex = groupIndex ? this.getIndexByGroup(groupIndex, index) : index;
      const textbox = this.inputFields.get(inputIndex);
      if (this.value && this.isValidNumber(this.value[inputIndex])) {
        textbox.value = this.value[inputIndex];
      } else {
        textbox.value = null;
      }
      this.showInvalidInput(inputIndex);
      return;
    }
    this.handleValueChange(index, groupIndex);
  }
  /**
   * @hidden
   */
  fillInputs(text, start = 0, replaceLast = false) {
    if (!isPresent(text)) {
      return;
    }
    let charCounter = 0;
    this.inputFields?.forEach((otpInput, i) => {
      if (i < start) {
        return;
      }
      if (charCounter < text.length) {
        if (text[charCounter] === " ") {
          otpInput.value = null;
        } else {
          otpInput.value = text[charCounter];
        }
        charCounter++;
      } else if (replaceLast) {
        otpInput.value = null;
      }
    });
  }
  /**
   * Focuses the OTP Input at the specified index provided as an argument.
   *
   * @param index The index of the input to focus.
   */
  focus(index) {
    if (!this.inputFields || index < 0 || index >= this.length) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(index || 0).focus();
    this.focusedInput = index || 0;
    this.focusChangedProgrammatically = false;
  }
  /**
   * Blurs the OTP Input.
   */
  blur() {
    this.focusChangedProgrammatically = true;
    const isFocusedElement = this.hostElement.nativeElement.querySelector(":focus");
    if (isFocusedElement) {
      isFocusedElement.blur();
    }
    this.isFocused = false;
    this.focusChangedProgrammatically = false;
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.zone.run(() => {
      if (!this.focusChangedProgrammatically && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    this.zone.run(() => {
      if (!this.focusChangedProgrammatically) {
        this.ngTouched();
        this.onBlur.emit();
      }
      this.isFocused = false;
    });
  }
  getIndexByGroup(groupIndex, itemIndex) {
    return this.groupLengthArray.slice(0, groupIndex).reduce((sum, current) => sum + current, 0) + itemIndex;
  }
  focusNext() {
    if (!this.inputFields || this.focusedInput === this.length - 1) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(this.focusedInput).blur();
    this.inputFields.get(this.focusedInput + 1).focus();
    this.focusedInput++;
    this.focusChangedProgrammatically = false;
  }
  focusPrevious() {
    if (!this.inputFields || this.focusedInput === 0) {
      return;
    }
    this.focusChangedProgrammatically = true;
    this.isFocused = true;
    this.inputFields.get(this.focusedInput).blur();
    this.inputFields.get(this.focusedInput - 1).focus();
    this.focusedInput--;
    this.focusChangedProgrammatically = false;
  }
  handlePaste(event) {
    event.preventDefault();
    const text = event.clipboardData.getData("text").trim();
    if (text === "") {
      return;
    }
    if (this.type === "number" && !this.isValidNumber(text)) {
      this.showInvalidInput(this.focusedInput);
      return;
    }
    this.inputFieldValueChanged = true;
    this.fillInputs(text, this.focusedInput);
    this.handleValueChange();
    this.inputFieldValueChanged = false;
    const focusedInput = this.focusedInput + text.length < this.inputFields?.length ? this.focusedInput + text.length : this.inputFields.length - 1;
    this.inputFields.get(this.focusedInput).blur();
    this.focusedInput = focusedInput;
    this.inputFields.get(this.focusedInput).focus();
  }
  handleKeydown(event) {
    if (this.readonly) {
      const isCopyCommand = (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyC;
      if (!(event.keyCode === Keys.Tab || isCopyCommand)) {
        event.preventDefault();
        return;
      }
    }
    switch (event.keyCode) {
      case Keys.ArrowRight:
        event.preventDefault();
        this.direction === "ltr" ? this.focusNext() : this.focusPrevious();
        break;
      case Keys.ArrowLeft:
        event.preventDefault();
        this.direction === "ltr" ? this.focusPrevious() : this.focusNext();
        break;
      case Keys.Backspace:
        event.preventDefault();
        this.inputFields.get(this.focusedInput).value = null;
        this.handleValueChange();
        this.focusPrevious();
        break;
      case Keys.Delete:
        event.preventDefault();
        this.inputFields.get(this.focusedInput).value = null;
        this.handleValueChange();
        break;
      default:
        break;
    }
  }
  isValidGroupArray(groups) {
    if (!isPresent(groups)) {
      return;
    }
    const sum = groups.reduce((sum2, current) => sum2 + current, 0);
    return sum === this.length;
  }
  populateGroupArray(length) {
    const groupsCount = Math.floor(this.length / length);
    const remainder2 = this.length % length;
    const result = Array(groupsCount).fill(length);
    if (remainder2 > 0) {
      result.push(remainder2);
    }
    this.groupLengthArray = [...result];
    if (!this.spacing) {
      this.adjacentGroups = [...this.groupLengthArray];
    }
  }
  populateSeparatorPositions() {
    let itemIndex = 0;
    this.separatorPositions.clear();
    if (!isPresent(this.groupLengthArray)) {
      return;
    }
    for (let i = 0; i < this.groupLengthArray.length - 1; i++) {
      itemIndex += this.groupLengthArray[i];
      this.separatorPositions.add(itemIndex - 1);
    }
  }
  clearGroups() {
    this.groupLengthArray = null;
    if (!this.spacing) {
      this.adjacentGroups = [this.length];
    } else {
      this.adjacentGroups = null;
    }
    this.separatorPositions.clear();
  }
  clearInputValues() {
    this.inputFields?.forEach((input) => input.value = null);
  }
  handleInputChanges() {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.fillInputs(this.value?.trim());
      if (this.inputAttributes) {
        this.setInputAttributes();
      } else {
        this.setDefaultAttributes();
      }
      this.cdr.detectChanges();
    });
  }
  setGroupFillMode(fillMode, previousFillMode) {
    this.inputGroups?.forEach((element) => {
      if (previousFillMode !== "none") {
        this.renderer.removeClass(element.nativeElement, `k-input-group-${previousFillMode}`);
      }
      if (fillMode !== "none") {
        this.renderer.addClass(element.nativeElement, `k-input-group-${fillMode}`);
      }
    });
  }
  setInputAttributes() {
    this.inputFields?.forEach((input, index) => {
      if (!this.parsedAttributes || !this.parsedAttributes?.["aria-label"]) {
        input.inputAttributes = __spreadProps(__spreadValues({}, this.parsedAttributes), {
          "aria-label": this.ariaLabel(index)
        });
      } else {
        input.inputAttributes = this.parsedAttributes;
      }
    });
  }
  setDefaultAttributes() {
    this.inputFields?.forEach((input, index) => {
      input.inputAttributes = {
        autocomplete: "off",
        "aria-label": this.ariaLabel(index)
      };
    });
  }
  ariaLabel(index) {
    const localizationMsg = this.localizationService.get("ariaLabel") || "";
    return replaceMessagePlaceholder(replaceMessagePlaceholder(replaceMessagePlaceholder(localizationMsg, "currentInput", (index + 1).toString()), "totalInputs", this.length.toString()), "value", this.value);
  }
  isValidNumber(value) {
    if (!isPresent(value)) {
      return;
    }
    const trimmedValue = value.trim();
    return trimmedValue !== "" && trimmedValue !== "Infinity" && trimmedValue !== "-Infinity" && !isNaN(Number(trimmedValue));
  }
  showInvalidInput(index) {
    const textbox = this.inputFields.get(index);
    const textboxElement = this.inputFields.get(index).hostElement.nativeElement;
    const inputElement = textbox.input.nativeElement;
    this.renderer.addClass(textboxElement, "k-invalid");
    if (textbox.value && this.isValidNumber(textbox.value)) {
      this.zone.onStable.pipe(take(1)).subscribe(() => inputElement.select());
    }
    this.zone.runOutsideAngular(() => {
      setTimeout(() => {
        if (!this.isControlInvalid && textboxElement) {
          this.renderer.removeClass(textboxElement, "k-invalid");
        }
      }, 300);
    });
  }
  containsDigitsOrSpaces(value) {
    const isDigitOrSpace = (char) => char == +char || char === " ";
    for (let i = 0; i < value.length; i++) {
      if (!isDigitOrSpace(value[i])) {
        return false;
      }
    }
    return true;
  }
  static ɵfac = function OTPInputComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputComponent,
    selectors: [["kendo-otpinput"]],
    viewQuery: function OTPInputComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(TextBoxComponent, 5);
        ɵɵviewQuery(_c69, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputFields = _t);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputGroups = _t);
      }
    },
    hostVars: 6,
    hostBindings: function OTPInputComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.direction)("role", ctx.role);
        ɵɵclassProp("k-otp", ctx.wrapperClass)("k-invalid", ctx.invalidClass);
      }
    },
    inputs: {
      length: "length",
      type: "type",
      spacing: "spacing",
      separator: "separator",
      disabled: "disabled",
      readonly: "readonly",
      placeholder: "placeholder",
      groupLength: "groupLength",
      value: "value",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoOTPInput"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.otpinput"
    }, {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _OTPInputComponent),
      multi: true
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _OTPInputComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 7,
    vars: 5,
    consts: () => {
      let i18n_81;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_81 = goog.getMsg("{$interpolation}", {
          "interpolation": "�0�"
        }, {
          original_code: {
            "interpolation": "{{ 'Input {currentInput} of {totalInputs}, current value {value}' }}"
          }
        });
        i18n_81 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_INPUTS_FESM2022_PROGRESS_KENDO_ANGULAR_INPUTS_MJS_81;
      } else {
        i18n_81 = $localize`:kendo.otpinput.ariaLabel|The value of the aria-label attribute of the input fields.:${"�0�"}:INTERPOLATION:`;
      }
      return [["groups", ""], ["inputGroup", ""], ["ariaLabel", i18n_81], ["kendoOTPInputLocalizedMessages", "", 6, "ariaLabel"], ["kendoInputSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], [4, "ngIf", "ngIfElse"], [4, "ngFor", "ngForOf"], [1, "k-otp-input", 3, "focus", "input", "selectOnFocus", "maxlength", "type", "placeholder", "size", "rounded", "fillMode", "disabled", "readonly"], [3, "separator", 4, "ngIf"], [3, "separator"], [1, "k-input-group"], ["class", "k-otp-input", 3, "k-invalid", "selectOnFocus", "maxlength", "type", "placeholder", "size", "rounded", "fillMode", "disabled", "readonly", "focus", "input", 4, "ngFor", "ngForOf"]];
    },
    template: function OTPInputComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainerStart(0, 3);
        ɵɵi18nAttributes(1, 2);
        ɵɵelementContainerEnd();
        ɵɵelementContainerStart(2, 4);
        ɵɵtwoWayListener("isFocusedChange", function OTPInputComponent_Template_ng_container_isFocusedChange_2_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function OTPInputComponent_Template_ng_container_handleBlur_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function OTPInputComponent_Template_ng_container_onFocus_2_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(3, OTPInputComponent_ng_container_3_Template, 2, 1, "ng-container", 5)(4, OTPInputComponent_ng_template_4_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(6);
        ɵɵelementContainerEnd();
      }
      if (rf & 2) {
        const groups_r9 = ɵɵreference(5);
        ɵɵi18nExp("Input {currentInput} of {totalInputs}, current value {value}");
        ɵɵi18nApply(1);
        ɵɵadvance(2);
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.spacing)("ngIfElse", groups_r9);
      }
    },
    dependencies: [SharedInputEventsDirective, TextBoxComponent, OTPInputSeparatorComponent, NgForOf, NgIf, LocalizedOTPInputMessagesDirective],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoOTPInput",
      providers: [LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.otpinput"
      }, {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => OTPInputComponent),
        multi: true
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => OTPInputComponent)
      }],
      selector: "kendo-otpinput",
      template: `
        <ng-container kendoOTPInputLocalizedMessages
            i18n-ariaLabel="kendo.otpinput.ariaLabel|The value of the aria-label attribute of the input fields."
            ariaLabel="{{ 'Input {currentInput} of {totalInputs}, current value {value}' }}"
        ></ng-container>
        <ng-container
            kendoInputSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <ng-container *ngIf="spacing; else groups">
                <ng-container *ngFor="let input of inputsArray; let i = index">
                    <kendo-textbox
                        class="k-otp-input"
                        [class.k-invalid]="isControlInvalid"
                        [selectOnFocus]="true"
                        [maxlength]="1"
                        [type]="type !== 'number' ? type : null"
                        [placeholder]="placeholder"
                        [size]="size"
                        [rounded]="rounded"
                        [fillMode]="fillMode"
                        [disabled]="disabled"
                        [readonly]="readonly"
                        (focus)="handleInputFocus(i)"
                        (input)="handleInput($event, i)"
                    ></kendo-textbox>
                    <kendo-otpinput-separator *ngIf="showSeparator(i)" [separator]="separator"></kendo-otpinput-separator>
                </ng-container>
            </ng-container>
            <ng-template #groups>
                <ng-container *ngFor="let group of adjacentGroups; let i = index">
                    <div #inputGroup class="k-input-group">
                        <kendo-textbox
                            *ngFor="let input of [].constructor(group); let j = index"
                            class="k-otp-input"
                            [class.k-invalid]="isControlInvalid"
                            [selectOnFocus]="true"
                            [maxlength]="1"
                            [type]="type !== 'number' ? type : null"
                            [placeholder]="placeholder"
                            [size]="size"
                            [rounded]="rounded"
                            [fillMode]="fillMode"
                            [disabled]="disabled"
                            [readonly]="readonly"
                            (focus)="handleInputFocus(j, i)"
                            (input)="handleInput($event, j, i)"
                        ></kendo-textbox>
                    </div>
                    <kendo-otpinput-separator *ngIf="showGroupSeparator(i)" [separator]="separator"></kendo-otpinput-separator>
                </ng-container>
            </ng-template>
        <ng-container>
    `,
      standalone: true,
      imports: [SharedInputEventsDirective, TextBoxComponent, OTPInputSeparatorComponent, NgForOf, NgIf, LocalizedOTPInputMessagesDirective]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: LocalizationService
    }, {
      type: NgZone
    }];
  }, {
    length: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    spacing: [{
      type: Input
    }],
    separator: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    groupLength: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    wrapperClass: [{
      type: HostBinding,
      args: ["class.k-otp"]
    }],
    invalidClass: [{
      type: HostBinding,
      args: ["class.k-invalid"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    inputFields: [{
      type: ViewChildren,
      args: [TextBoxComponent]
    }],
    inputGroups: [{
      type: ViewChildren,
      args: ["inputGroup"]
    }]
  });
})();
var OTPInputCustomMessagesComponent = class _OTPInputCustomMessagesComponent extends OTPInputMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function OTPInputCustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputCustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _OTPInputCustomMessagesComponent,
    selectors: [["kendo-otpinput-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: OTPInputMessages,
      useExisting: forwardRef(() => _OTPInputCustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function OTPInputCustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputCustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: OTPInputMessages,
        useExisting: forwardRef(() => OTPInputCustomMessagesComponent)
      }],
      selector: "kendo-otpinput-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var KENDO_TEXTBOX = [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_NUMERICTEXTBOX = [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_MASKEDTEXTBOX = [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent];
var KENDO_OTPINPUT = [OTPInputComponent, OTPInputCustomMessagesComponent];
var KENDO_TEXTAREA = [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent];
var KENDO_CHECKBOX = [CheckBoxComponent, CheckBoxDirective];
var KENDO_RADIOBUTTON = [RadioButtonComponent, RadioButtonDirective];
var KENDO_SWITCH = [SwitchComponent, SwitchCustomMessagesComponent];
var KENDO_FORMFIELD = [FormFieldComponent, HintComponent2, ErrorComponent];
var KENDO_SLIDER = [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective];
var KENDO_RANGESLIDER = [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective];
var KENDO_RATING = [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective];
var KENDO_SIGNATURE = [SignatureComponent, SignatureCustomMessagesComponent];
var KENDO_COLORPICKER = [ColorPickerComponent, ColorPickerCustomMessagesComponent];
var KENDO_FLATCOLORPICKER = [FlatColorPickerComponent, ColorPickerCustomMessagesComponent];
var KENDO_COLORPALETTE = [ColorPaletteComponent, ColorPickerCustomMessagesComponent];
var KENDO_COLORGRADIENT = [ColorGradientComponent, ColorPickerCustomMessagesComponent];
var KENDO_INPUTS = [...KENDO_TEXTBOX, ...KENDO_NUMERICTEXTBOX, ...KENDO_MASKEDTEXTBOX, ...KENDO_TEXTAREA, ...KENDO_CHECKBOX, ...KENDO_RADIOBUTTON, ...KENDO_SWITCH, ...KENDO_FORMFIELD, ...KENDO_SLIDER, ...KENDO_RANGESLIDER, ...KENDO_RATING, ...KENDO_SIGNATURE, ...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE, ...KENDO_OTPINPUT];
var InputsModule = class _InputsModule {
  static ɵfac = function InputsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _InputsModule,
    imports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, CheckBoxComponent, CheckBoxDirective, RadioButtonComponent, RadioButtonDirective, SwitchComponent, SwitchCustomMessagesComponent, FormFieldComponent, HintComponent2, ErrorComponent, SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective, RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective, RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective, SignatureComponent, SignatureCustomMessagesComponent, ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent, OTPInputComponent, OTPInputCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, CheckBoxComponent, CheckBoxDirective, RadioButtonComponent, RadioButtonDirective, SwitchComponent, SwitchCustomMessagesComponent, FormFieldComponent, HintComponent2, ErrorComponent, SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective, RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective, RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective, SignatureComponent, SignatureCustomMessagesComponent, ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent, OTPInputComponent, OTPInputCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [TextBoxComponent, SeparatorComponent, NumericTextBoxComponent, SeparatorComponent, SeparatorComponent, SeparatorComponent, SliderComponent, RangeSliderComponent, RatingComponent, SignatureComponent, ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent, OTPInputComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputsModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_INPUTS, ...KENDO_ADORNMENTS],
      exports: [...KENDO_INPUTS, ...KENDO_ADORNMENTS],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var SliderModule = class _SliderModule {
  static ɵfac = function SliderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SliderModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SliderModule,
    imports: [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective],
    exports: [SliderComponent, SliderCustomMessagesComponent, LabelTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService],
    imports: [SliderComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SliderModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SLIDER],
      exports: [...KENDO_SLIDER],
      providers: [IconsService, PopupService, ResizeBatchService]
    }]
  }], null, null);
})();
var RangeSliderModule = class _RangeSliderModule {
  static ɵfac = function RangeSliderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RangeSliderModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RangeSliderModule,
    imports: [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective],
    exports: [RangeSliderComponent, RangeSliderCustomMessagesComponent, LabelTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [ResizeBatchService],
    imports: [RangeSliderComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeSliderModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RANGESLIDER],
      exports: [...KENDO_RANGESLIDER],
      providers: [ResizeBatchService]
    }]
  }], null, null);
})();
var SwitchModule = class _SwitchModule {
  static ɵfac = function SwitchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SwitchModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SwitchModule,
    imports: [SwitchComponent, SwitchCustomMessagesComponent],
    exports: [SwitchComponent, SwitchCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [ResizeBatchService]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SWITCH],
      exports: [...KENDO_SWITCH],
      providers: [ResizeBatchService]
    }]
  }], null, null);
})();
var OTPInputModule = class _OTPInputModule {
  static ɵfac = function OTPInputModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OTPInputModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _OTPInputModule,
    imports: [OTPInputComponent, OTPInputCustomMessagesComponent],
    exports: [OTPInputComponent, OTPInputCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [OTPInputComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OTPInputModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_OTPINPUT],
      exports: [...KENDO_OTPINPUT],
      providers: [IconsService]
    }]
  }], null, null);
})();
var NumericTextBoxModule = class _NumericTextBoxModule {
  static ɵfac = function NumericTextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NumericTextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _NumericTextBoxModule,
    imports: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [NumericTextBoxComponent, NumericTextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [NumericTextBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumericTextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_NUMERICTEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_NUMERICTEXTBOX, ...KENDO_ADORNMENTS],
      providers: [IconsService]
    }]
  }], null, null);
})();
var MaskedTextBoxModule = class _MaskedTextBoxModule {
  static ɵfac = function MaskedTextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MaskedTextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MaskedTextBoxModule,
    imports: [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [MaskedTextBoxComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaskedTextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_MASKEDTEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_MASKEDTEXTBOX, ...KENDO_ADORNMENTS]
    }]
  }], null, null);
})();
var TextBoxModule = class _TextBoxModule {
  static ɵfac = function TextBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TextBoxModule,
    imports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextBoxDirective, TextBoxComponent, InputSeparatorComponent, TextBoxSuffixTemplateDirective, TextBoxPrefixTemplateDirective, TextBoxCustomMessagesComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [TextBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TEXTBOX, ...KENDO_ADORNMENTS],
      exports: [...KENDO_TEXTBOX, ...KENDO_ADORNMENTS],
      providers: [IconsService]
    }]
  }], null, null);
})();
var TextAreaModule = class _TextAreaModule {
  static ɵfac = function TextAreaModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TextAreaModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TextAreaModule,
    imports: [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [TextAreaComponent, TextAreaDirective, TextAreaPrefixComponent, TextAreaSuffixComponent, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    imports: [SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TextAreaModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TEXTAREA, ...KENDO_ADORNMENTS],
      exports: [...KENDO_TEXTAREA, ...KENDO_ADORNMENTS]
    }]
  }], null, null);
})();
var CheckBoxModule = class _CheckBoxModule {
  static ɵfac = function CheckBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _CheckBoxModule,
    imports: [CheckBoxComponent, CheckBoxDirective],
    exports: [CheckBoxComponent, CheckBoxDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_CHECKBOX],
      exports: [...KENDO_CHECKBOX]
    }]
  }], null, null);
})();
var RadioButtonModule = class _RadioButtonModule {
  static ɵfac = function RadioButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioButtonModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RadioButtonModule,
    imports: [RadioButtonComponent, RadioButtonDirective],
    exports: [RadioButtonComponent, RadioButtonDirective]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioButtonModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RADIOBUTTON],
      exports: [...KENDO_RADIOBUTTON]
    }]
  }], null, null);
})();
var ColorPickerModule = class _ColorPickerModule {
  static ɵfac = function ColorPickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColorPickerModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ColorPickerModule,
    imports: [ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent],
    exports: [ColorPickerComponent, ColorPickerCustomMessagesComponent, FlatColorPickerComponent, ColorPickerCustomMessagesComponent, ColorGradientComponent, ColorPickerCustomMessagesComponent, ColorPaletteComponent, ColorPickerCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, IconsService, ResizeBatchService, AdaptiveService],
    imports: [ColorPickerComponent, FlatColorPickerComponent, ColorGradientComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColorPickerModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE],
      exports: [...KENDO_COLORPICKER, ...KENDO_FLATCOLORPICKER, ...KENDO_COLORGRADIENT, ...KENDO_COLORPALETTE],
      providers: [PopupService, IconsService, ResizeBatchService, AdaptiveService]
    }]
  }], null, null);
})();
var FormFieldModule = class _FormFieldModule {
  static ɵfac = function FormFieldModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormFieldModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _FormFieldModule,
    imports: [FormFieldComponent, HintComponent2, ErrorComponent],
    exports: [FormFieldComponent, HintComponent2, ErrorComponent]
  });
  static ɵinj = ɵɵdefineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormFieldModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_FORMFIELD],
      exports: [...KENDO_FORMFIELD]
    }]
  }], null, null);
})();
var SignatureModule = class _SignatureModule {
  static ɵfac = function SignatureModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SignatureModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _SignatureModule,
    imports: [SignatureComponent, SignatureCustomMessagesComponent],
    exports: [SignatureComponent, SignatureCustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [SignatureComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignatureModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_SIGNATURE],
      exports: [...KENDO_SIGNATURE],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();
var RatingModule = class _RatingModule {
  static ɵfac = function RatingModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RatingModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _RatingModule,
    imports: [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective],
    exports: [RatingComponent, RatingItemTemplateDirective, RatingHoveredItemTemplateDirective, RatingSelectedItemTemplateDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService],
    imports: [RatingComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RatingModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_RATING],
      exports: [...KENDO_RATING],
      providers: [IconsService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-treeview/fesm2022/progress-kendo-angular-treeview.mjs
var _c03 = ["kendoTreeViewGroup", ""];
var _c110 = (a0, a1) => ({
  $implicit: a0,
  index: a1
});
var _c210 = (a0) => ({
  index: a0
});
function TreeViewGroupComponent_li_0_span_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 13);
    ɵɵlistener("click", function TreeViewGroupComponent_li_0_span_2_Template_span_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      const node_r3 = ctx_r1.$implicit;
      const index_r4 = ctx_r1.index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.expandNode(ctx_r4.nodeIndex(index_r4), node_r3, !ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4))));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-disabled", !ctx_r4.isItemExpandable(node_r3, index_r4));
    ɵɵproperty("kendoTreeViewLoading", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance();
    ɵɵproperty("name", ctx_r4.getFontIcon(node_r3, ctx_r4.nodeIndex(index_r4)))("svgIcon", ctx_r4.getSvgIcon(node_r3, ctx_r4.nodeIndex(index_r4)));
  }
}
function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-checkbox", 15, 0);
    ɵɵlistener("checkedStateChange", function TreeViewGroupComponent_li_0_kendo_checkbox_3_Template_kendo_checkbox_checkedStateChange_0_listener() {
      ɵɵrestoreView(_r6);
      const checkbox_r7 = ɵɵreference(1);
      const index_r4 = ɵɵnextContext().index;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.checkNode(ctx_r4.nodeIndex(index_r4), checkbox_r7));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r4.isItemDisabled(node_r3, index_r4))("size", ctx_r4.size)("checkedState", ctx_r4.getCheckBoxState(node_r3, ctx_r4.nodeIndex(index_r4)))("tabindex", -1)("inputAttributes", ctx_r4.getCheckboxAttributes(index_r4));
  }
}
function TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template(rf, ctx) {
}
function TreeViewGroupComponent_li_0_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, TreeViewGroupComponent_li_0_ng_container_7_ng_template_1_Template, 0, 0, "ng-template", 16);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r4.nodeTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c110, node_r3, ctx_r4.nodeIndex(index_r4)));
  }
}
function TreeViewGroupComponent_li_0_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const node_r3 = ɵɵnextContext().$implicit;
    const ctx_r4 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.nodeText(node_r3), " ");
  }
}
function TreeViewGroupComponent_li_0_ul_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "ul", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const node_r3 = ctx_r1.$implicit;
    const index_r4 = ctx_r1.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("size", ctx_r4.size)("nodes", ctx_r4.fetchChildren)("loadOnDemand", ctx_r4.loadOnDemand)("checkboxes", ctx_r4.checkboxes)("expandIcons", ctx_r4.expandIcons)("selectable", ctx_r4.selectable)("touchActions", ctx_r4.touchActions)("children", ctx_r4.children)("hasChildren", ctx_r4.hasChildren)("isChecked", ctx_r4.isChecked)("isDisabled", ctx_r4.isDisabled)("hasCheckbox", ctx_r4.hasCheckbox)("disabled", ctx_r4.isItemDisabled(node_r3, index_r4))("expandDisabledNodes", ctx_r4.expandDisabledNodes)("isExpanded", ctx_r4.isExpanded)("isSelected", ctx_r4.isSelected)("isVisible", ctx_r4.isVisible)("nodeTemplateRef", ctx_r4.nodeTemplateRef)("loadMoreButtonTemplateRef", ctx_r4.loadMoreButtonTemplateRef)("parentIndex", ctx_r4.nodeIndex(index_r4))("parentDataItem", node_r3)("textField", ctx_r4.nextFields)("loadMoreService", ctx_r4.loadMoreService)("@toggle", true)("trackBy", ctx_r4.trackBy)("disableParentNodesOnly", ctx_r4.disableParentNodesOnly);
  }
}
function TreeViewGroupComponent_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 3)(1, "div", 4);
    ɵɵtemplate(2, TreeViewGroupComponent_li_0_span_2_Template, 2, 5, "span", 5)(3, TreeViewGroupComponent_li_0_kendo_checkbox_3_Template, 2, 5, "kendo-checkbox", 6);
    ɵɵelementStart(4, "span", 7)(5, "span", 8);
    ɵɵelementContainerStart(6, 9);
    ɵɵtemplate(7, TreeViewGroupComponent_li_0_ng_container_7_Template, 2, 5, "ng-container", 10)(8, TreeViewGroupComponent_li_0_ng_container_8_Template, 2, 1, "ng-container", 11);
    ɵɵelementContainerEnd();
    ɵɵelementEnd()()();
    ɵɵtemplate(9, TreeViewGroupComponent_li_0_ul_9_Template, 1, 26, "ul", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const node_r3 = ctx.$implicit;
    const index_r4 = ctx.index;
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-hidden", !ctx_r4.isVisible(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵproperty("dataItem", node_r3)("index", ctx_r4.nodeIndex(index_r4))("parentDataItem", ctx_r4.parentDataItem)("parentIndex", ctx_r4.parentIndex)("loadOnDemand", ctx_r4.loadOnDemand)("checkable", ctx_r4.checkboxes)("isChecked", ctx_r4.isChecked(node_r3, ctx_r4.nodeIndex(index_r4)))("isDisabled", ctx_r4.isItemDisabled(node_r3, index_r4))("isVisible", ctx_r4.isVisible(node_r3, ctx_r4.nodeIndex(index_r4)))("expandable", ctx_r4.expandIcons && ctx_r4.hasChildren(node_r3))("isExpanded", ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4)))("selectable", ctx_r4.selectable)("isSelected", ctx_r4.isSelected(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵattribute("aria-setsize", ctx_r4.totalNodesCount)("data-treeindex", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r4.setItemClasses(ctx_r4.data.length, index_r4));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.expandIcons && ctx_r4.hasChildren(node_r3));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r4.checkboxes && ctx_r4.hasCheckbox(node_r3, ctx_r4.nodeIndex(index_r4)));
    ɵɵadvance();
    ɵɵstyleProp("touch-action", ctx_r4.touchActions ? "" : "none");
    ɵɵclassProp("k-disabled", ctx_r4.isItemDisabled(node_r3, index_r4));
    ɵɵproperty("id", ctx_r4.nodeIndex(index_r4))("dataItem", node_r3)("index", ctx_r4.nodeIndex(index_r4))("initialSelection", ctx_r4.isSelected(node_r3, ctx_r4.nodeIndex(index_r4)))("isSelected", ctx_r4.isSelected);
    ɵɵattribute("data-treeindex", ctx_r4.nodeIndex(index_r4));
    ɵɵadvance(2);
    ɵɵproperty("ngSwitch", ctx_r4.hasTemplate);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", true);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.isExpanded(node_r3, ctx_r4.nodeIndex(index_r4)) && ctx_r4.hasChildren(node_r3));
  }
}
function TreeViewGroupComponent_li_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 23);
  }
}
function TreeViewGroupComponent_li_1_5_ng_template_0_Template(rf, ctx) {
}
function TreeViewGroupComponent_li_1_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TreeViewGroupComponent_li_1_5_ng_template_0_Template, 0, 0, "ng-template", 16);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r4.loadMoreButtonTemplateRef)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c210, ctx_r4.loadMoreButtonIndex));
  }
}
function TreeViewGroupComponent_li_1_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r4.loadMoreTitle, " ");
  }
}
function TreeViewGroupComponent_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 18)(1, "div", 19);
    ɵɵtemplate(2, TreeViewGroupComponent_li_1_span_2_Template, 1, 0, "span", 20);
    ɵɵelementStart(3, "span", 21)(4, "span", 8);
    ɵɵtemplate(5, TreeViewGroupComponent_li_1_5_Template, 1, 4, null, 22)(6, TreeViewGroupComponent_li_1_ng_container_6_Template, 2, 1, "ng-container", 22);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    ɵɵclassProp("k-treeview-load-more-checkboxes-container", ctx_r4.checkboxes);
    ɵɵproperty("selectable", false)("checkable", false)("expandable", false)("index", ctx_r4.loadMoreButtonIndex)("parentDataItem", ctx_r4.parentDataItem)("parentIndex", ctx_r4.parentIndex);
    ɵɵattribute("data-treeindex", ctx_r4.loadMoreButtonIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.loadingMoreNodes);
    ɵɵadvance();
    ɵɵproperty("index", ctx_r4.loadMoreButtonIndex);
    ɵɵattribute("data-treeindex", ctx_r4.loadMoreButtonIndex);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r4.loadMoreButtonTemplateRef);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r4.loadMoreButtonTemplateRef);
  }
}
var _c310 = ["assetsContainer"];
var _c410 = ["searchbox"];
function TreeViewComponent_span_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon-wrapper", 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
  }
}
function TreeViewComponent_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 5)(1, "kendo-textbox", 6, 1);
    ɵɵlistener("valueChange", function TreeViewComponent_span_1_Template_kendo_textbox_valueChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.filterChange.emit($event));
    });
    ɵɵtemplate(3, TreeViewComponent_span_1_ng_template_3_Template, 1, 1, "ng-template", 7);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.size)("value", ctx_r1.filter)("clearButton", true)("placeholder", ctx_r1.filterInputPlaceholder);
  }
}
var _c510 = (a0, a1, a2, a3) => ({
  text: a0,
  action: a1,
  sourceItem: a2,
  destinationItem: a3
});
function DragClueComponent_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "kendo-icon-wrapper", 1);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("name", ctx_r0.statusIconClass)("svgIcon", ctx_r0.statusSVGIcon);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.text);
  }
}
function DragClueComponent_1_ng_template_0_Template(rf, ctx) {
}
function DragClueComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DragClueComponent_1_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c510, ctx_r0.text, ctx_r0.action, ctx_r0.sourceItem, ctx_r0.destinationItem));
  }
}
var _c610 = (a0, a1, a2) => ({
  action: a0,
  sourceItem: a1,
  destinationItem: a2
});
function DropHintComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵelement(1, "div", 3)(2, "div", 4);
    ɵɵelementEnd();
  }
}
function DropHintComponent_1_ng_template_0_ng_template_0_Template(rf, ctx) {
}
function DropHintComponent_1_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropHintComponent_1_ng_template_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function DropHintComponent_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropHintComponent_1_ng_template_0_Template, 1, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c610, ctx_r0.action, ctx_r0.sourceItem, ctx_r0.destinationItem));
  }
}
var packageMetadata3 = {
  name: "@progress/kendo-angular-treeview",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1751463060,
  version: "19.2.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var DataChangeNotificationService = class {
  changes = new EventEmitter();
  notify() {
    this.changes.emit();
  }
};
var hasChildren = () => false;
var isChecked = () => "none";
var isDisabled = () => false;
var hasCheckbox = () => true;
var isExpanded = () => true;
var isSelected = () => false;
var isVisible = () => true;
var trackBy = (_, item) => item;
var ExpandStateService = class _ExpandStateService {
  changes = new Subject();
  expand(index, dataItem) {
    this.changes.next({
      dataItem,
      index,
      expand: true
    });
  }
  collapse(index, dataItem) {
    this.changes.next({
      dataItem,
      index,
      expand: false
    });
  }
  static ɵfac = function ExpandStateService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandStateService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExpandStateService,
    factory: _ExpandStateService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandStateService, [{
    type: Injectable
  }], null, null);
})();
var IndexBuilderService = class _IndexBuilderService {
  INDEX_SEPARATOR = "_";
  nodeIndex(index = "", parentIndex = "") {
    return `${parentIndex}${parentIndex ? this.INDEX_SEPARATOR : ""}${index}`;
  }
  indexForLevel(index, level) {
    return index.split(this.INDEX_SEPARATOR).slice(0, level).join(this.INDEX_SEPARATOR);
  }
  lastLevelIndex(index = "") {
    const parts = index.split(this.INDEX_SEPARATOR);
    if (!parts.length) {
      return NaN;
    }
    return parseInt(parts[parts.length - 1], 10);
  }
  level(index) {
    return index.split(this.INDEX_SEPARATOR).length;
  }
  static ɵfac = function IndexBuilderService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _IndexBuilderService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _IndexBuilderService,
    factory: _IndexBuilderService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IndexBuilderService, [{
    type: Injectable
  }], null, null);
})();
var LoadingNotificationService = class _LoadingNotificationService {
  changes = new Subject();
  notifyLoaded(index) {
    this.changes.next(index);
  }
  static ɵfac = function LoadingNotificationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingNotificationService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _LoadingNotificationService,
    factory: _LoadingNotificationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingNotificationService, [{
    type: Injectable
  }], null, null);
})();
var focusableRegex = /^(?:a|input|select|option|textarea|button|object)$/i;
var match = (element, selector) => {
  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  if (!matcher) {
    return false;
  }
  return matcher.call(element, selector.toLowerCase());
};
var closestWithMatch = (element, selector) => {
  if (!document.documentElement.contains(element)) {
    return null;
  }
  let parent = element;
  while (parent !== null && parent.nodeType === 1) {
    if (match(parent, selector)) {
      return parent;
    }
    parent = parent.parentElement || parent.parentNode;
  }
  return null;
};
var noop5 = () => {
};
var isPresent4 = (value) => value !== null && value !== void 0;
var isBlank = (value) => value === null || value === void 0;
var isArray = (value) => Array.isArray(value);
var isNullOrEmptyString = (value) => isBlank(value) || value.trim().length === 0;
var isBoolean = (value) => typeof value === "boolean";
var closestNode = (element) => {
  const selector = "li.k-treeview-item";
  if (!isDocumentAvailable()) {
    return null;
  }
  if (element.closest) {
    return element.closest(selector);
  } else {
    return closestWithMatch(element, selector);
  }
};
var isFocusable = (element) => {
  if (element.tagName) {
    const tagName = element.tagName.toLowerCase();
    const tabIndex = element.getAttribute("tabIndex");
    const skipTab = tabIndex === "-1";
    let focusable = tabIndex !== null && !skipTab;
    if (focusableRegex.test(tagName)) {
      focusable = !element.disabled && !skipTab;
    }
    return focusable;
  }
  return false;
};
var isContent = (element) => {
  const scopeSelector = ".k-treeview-leaf:not(.k-treeview-load-more-button),.k-treeview-item,.k-treeview";
  if (!isDocumentAvailable()) {
    return null;
  }
  let node = element;
  while (node && !match(node, scopeSelector)) {
    node = node.parentNode;
  }
  if (node) {
    return match(node, ".k-treeview-leaf:not(.k-treeview-load-more-button)");
  }
};
var getContentElement = (parent) => {
  if (!isPresent4(parent)) {
    return null;
  }
  const selector = ".k-treeview-leaf:not(.k-treeview-load-more-button)";
  if (match(parent, selector)) {
    return parent;
  }
  return parent.querySelector(selector);
};
var isLoadMoreButton = (element) => {
  return isPresent4(closestWithMatch(element, ".k-treeview-leaf.k-treeview-load-more-button"));
};
var closest3 = (node, predicate) => {
  while (node && !predicate(node)) {
    node = node.parentNode;
  }
  return node;
};
var hasParent = (element, container) => {
  return Boolean(closest3(element, (node) => node === container));
};
var focusableNode = (element) => element.nativeElement.querySelector('li[tabindex="0"]');
var nodeId = (node) => node ? node.getAttribute("data-treeindex") : "";
var nodeIndex = (item) => (item || {}).index;
var dataItemsEqual = (first, second) => {
  if (!isPresent4(first) && !isPresent4(second)) {
    return true;
  }
  return isPresent4(first) && isPresent4(second) && first.item.dataItem === second.item.dataItem;
};
var getDataItem = (lookup) => {
  if (!isPresent4(lookup)) {
    return lookup;
  }
  return lookup.item.dataItem;
};
var isArrayWithAtLeastOneItem = (v) => v && Array.isArray(v) && v.length !== 0;
var filterTree = (items, term, {
  operator,
  ignoreCase,
  mode
}, textField, depth = 0) => {
  const field = typeof textField === "string" ? textField : textField[depth];
  items.forEach((wrapper) => {
    const matcher = typeof operator === "string" ? matchByFieldAndCase(field, operator, ignoreCase) : operator;
    const isMatch = matcher(wrapper.dataItem, term);
    wrapper.isMatch = isMatch;
    wrapper.visible = isMatch;
    wrapper.containsMatches = false;
    if (isMatch) {
      setParentChain(wrapper.parent);
    }
    if (wrapper.children && wrapper.children.length > 0) {
      if (mode === "strict" || !isMatch) {
        filterTree(wrapper.children, term, {
          operator,
          ignoreCase,
          mode
        }, textField, depth + 1);
      } else {
        makeAllVisible(wrapper.children);
      }
    }
  });
};
var setParentChain = (node) => {
  if (!isPresent4(node)) {
    return;
  }
  node.containsMatches = true;
  node.visible = true;
  if (isPresent4(node.parent) && !node.parent.containsMatches) {
    setParentChain(node.parent);
  }
};
var makeAllVisible = (nodes) => {
  nodes.forEach((node) => {
    node.visible = true;
    if (node.children) {
      makeAllVisible(node.children);
    }
  });
};
var operators = {
  contains: (a, b) => a.indexOf(b) >= 0,
  doesnotcontain: (a, b) => a.indexOf(b) === -1,
  startswith: (a, b) => a.lastIndexOf(b, 0) === 0,
  doesnotstartwith: (a, b) => a.lastIndexOf(b, 0) === -1,
  endswith: (a, b) => a.indexOf(b, a.length - b.length) >= 0,
  doesnotendwith: (a, b) => a.indexOf(b, a.length - b.length) < 0
};
var matchByCase = (matcher, ignoreCase) => (a, b) => {
  if (ignoreCase) {
    return matcher(a.toLowerCase(), b.toLowerCase());
  }
  return matcher(a, b);
};
var matchByFieldAndCase = (field, operator, ignoreCase) => (dataItem, term) => matchByCase(operators[operator], ignoreCase)(getter(field)(dataItem), term);
var buildTreeIndex = (parentIndex, itemIndex) => {
  return [parentIndex, itemIndex].filter((part) => isPresent4(part)).join("_");
};
var buildTreeItem = (dataItem, currentLevelIndex, parentIndex) => {
  if (!isPresent4(dataItem)) {
    return null;
  }
  return {
    dataItem,
    index: buildTreeIndex(parentIndex, currentLevelIndex)
  };
};
var fetchLoadedDescendants = (lookup, filterExpression) => {
  if (!isPresent4(lookup) || lookup.children.length === 0) {
    return [];
  }
  let descendants = lookup.children;
  if (isPresent4(filterExpression)) {
    descendants = descendants.filter(filterExpression);
  }
  descendants.forEach((child) => descendants = descendants.concat(fetchLoadedDescendants(child, filterExpression)));
  return descendants;
};
var sameValues = (as, bs) => {
  if (as.size !== bs.size) {
    return false;
  }
  return Array.from(as).every((v) => bs.has(v));
};
var getSizeClass = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var safe = (node) => node || {};
var safeChildren = (node) => safe(node).children || [];
var lastVisibleNode = (nodes) => {
  if (!Array.isArray(nodes) || nodes.length === 0) {
    return null;
  }
  const nodesCount = nodes.length;
  const lastIndex = nodesCount - 1;
  for (let index = lastIndex; index >= 0; index -= 1) {
    const node = nodes[index];
    if (node.visible) {
      return node;
    }
  }
  return null;
};
var NavigationModel = class {
  ib = new IndexBuilderService();
  nodes = [];
  firstVisibleNode() {
    return (this.nodes || []).find((node) => node.visible);
  }
  lastVisibleNode() {
    let node = lastVisibleNode(this.nodes);
    while (isPresent4(node) && safeChildren(node).length > 0) {
      const children = safeChildren(node);
      const lastVisibleChild = lastVisibleNode(children);
      if (!isPresent4(lastVisibleChild)) {
        return node;
      }
      node = lastVisibleChild;
    }
    return node;
  }
  closestNode(index) {
    const {
      prev
    } = safe(this.findNode(index));
    const sibling = prev || this.firstVisibleNode();
    return safe(sibling).index === index ? this.visibleSibling(sibling, 1) : sibling;
  }
  firstFocusableNode() {
    return this.nodes.find((node) => {
      return !node.disabled && node.visible;
    });
  }
  findNode(index) {
    return this.find(index, this.nodes);
  }
  findParent(index) {
    const parentLevel = this.ib.level(index) - 1;
    return this.findNode(this.ib.indexForLevel(index, parentLevel));
  }
  findVisibleChild(index) {
    const node = this.findNode(index);
    const children = safeChildren(node);
    return children.find((child) => child.visible);
  }
  findVisiblePrev(item) {
    const index = item.index;
    const parent = this.findParent(index);
    const levelIndex = this.ib.lastLevelIndex(index);
    const prevNodes = this.container(parent).slice(0, levelIndex);
    const prevNodesHidden = prevNodes.every((node) => !node.visible);
    if (levelIndex === 0 || prevNodesHidden) {
      return parent;
    }
    const currentNode = this.findNode(index);
    let prev = this.visibleSibling(currentNode, -1);
    if (prev) {
      let children = this.container(prev);
      while (children.length > 0 && children.some((node) => node.visible)) {
        prev = lastVisibleNode(children);
        children = this.container(prev);
      }
    }
    return prev;
  }
  findVisibleNext(item) {
    const children = this.container(item);
    const hasVisibleChildren = children.some((child) => child.visible);
    if (children.length === 0 || !hasVisibleChildren) {
      return this.visibleSibling(item, 1);
    }
    return children.find((child) => child.visible);
  }
  registerItem(id2, index, disabled, loadMoreButton = false, visible = true) {
    const children = [];
    const level = this.ib.level(index);
    const parent = this.findParent(index);
    if (parent || level === 1) {
      const node = {
        id: id2,
        children,
        index,
        parent,
        disabled,
        loadMoreButton,
        visible
      };
      this.insert(node, parent);
    }
  }
  unregisterItem(id2, index) {
    const node = this.find(index, this.nodes);
    if (!node || node.id !== id2) {
      return;
    }
    const children = this.container(node.parent);
    children.splice(children.indexOf(node), 1);
  }
  childLevel(nodes) {
    const children = nodes.filter((node) => isPresent4(node));
    if (!children || !children.length) {
      return 1;
    }
    return this.ib.level(children[0].index);
  }
  container(node) {
    return node ? node.children : this.nodes;
  }
  find(index, nodes) {
    const childLevel = this.childLevel(nodes);
    const indexToMatch = this.ib.indexForLevel(index, childLevel);
    const isLeaf = childLevel === this.ib.level(index);
    const node = nodes.find((n) => n && n.index === indexToMatch);
    if (!node) {
      return null;
    }
    return isLeaf ? node : this.find(index, node.children);
  }
  insert(node, parent) {
    const nodes = this.container(parent);
    nodes.splice(this.ib.lastLevelIndex(node.index), 0, node);
  }
  visibleSibling(node, offset) {
    if (!node) {
      return null;
    }
    const parent = this.findParent(node.index);
    const container = this.container(parent);
    let nextItemIndex = container.indexOf(node) + offset;
    let nextItem = container[nextItemIndex];
    while (isPresent4(nextItem)) {
      if (nextItem.visible) {
        return nextItem;
      }
      nextItemIndex += offset;
      nextItem = container[nextItemIndex];
    }
    return this.visibleSibling(parent, offset);
  }
};
var NavigationService = class _NavigationService {
  localization;
  expands = new Subject();
  moves = new Subject();
  checks = new Subject();
  selects = new Subject();
  deselectAllButCurrentItem = new Subject();
  loadMore = new Subject();
  navigable = true;
  selection = "single";
  isTreeViewActive = false;
  get model() {
    return this._model;
  }
  set model(model) {
    this._model = model;
  }
  actions = {
    [Keys.ArrowUp]: () => this.activate(this.model.findVisiblePrev(this.focusableItem), true),
    [Keys.ArrowDown]: () => this.activate(this.model.findVisibleNext(this.focusableItem), true),
    [Keys.ArrowLeft]: () => !this.isLoadMoreButton && this.expand({
      expand: this.localization.rtl,
      intercept: this.localization.rtl ? this.moveToFirstVisibleChild : this.moveToParent
    }),
    [Keys.ArrowRight]: () => !this.isLoadMoreButton && this.expand({
      expand: !this.localization.rtl,
      intercept: this.localization.rtl ? this.moveToParent : this.moveToFirstVisibleChild
    }),
    [Keys.Home]: () => this.activate(this.model.firstVisibleNode(), true),
    [Keys.End]: () => this.activate(this.model.lastVisibleNode(), true),
    [Keys.Enter]: (e) => this.handleEnter(e),
    [Keys.Space]: () => this.handleSpace()
  };
  activeItem;
  isFocused = false;
  shouldScroll = false;
  _model = new NavigationModel();
  get activeIndex() {
    return nodeIndex(this.activeItem) || null;
  }
  get isActiveExpanded() {
    return this.activeItem && this.activeItem.children.length > 0;
  }
  get isLoadMoreButton() {
    return this.activeItem && this.activeItem.loadMoreButton;
  }
  get focusableItem() {
    return this.activeItem || this.model.firstFocusableNode();
  }
  constructor(localization) {
    this.localization = localization;
    this.moveToFirstVisibleChild = this.moveToFirstVisibleChild.bind(this);
    this.moveToParent = this.moveToParent.bind(this);
  }
  activate(item, shouldScroll = false) {
    if (!this.navigable || !item || this.isActive(nodeIndex(item))) {
      return;
    }
    this.isFocused = true;
    this.activeItem = item || this.activeItem;
    this.shouldScroll = shouldScroll;
    this.notifyMove();
  }
  activateParent(index) {
    this.activate(this.model.findParent(index));
  }
  activateIndex(index) {
    if (!index) {
      return;
    }
    this.activate(this.model.findNode(index));
  }
  activateClosest(index) {
    if (!index || nodeIndex(this.focusableItem) !== index) {
      return;
    }
    this.activeItem = this.model.closestNode(index);
    this.notifyMove();
  }
  activateFocusable() {
    if (this.activeItem) {
      return;
    }
    this.activeItem = this.model.firstVisibleNode();
    this.notifyMove();
  }
  deactivate() {
    if (!this.navigable || !this.isFocused) {
      return;
    }
    this.isFocused = false;
    this.notifyMove();
  }
  checkIndex(index) {
    if (!this.isDisabled(index)) {
      this.checks.next(index);
    }
  }
  selectIndex(index) {
    if (!this.isDisabled(index)) {
      this.selects.next(index);
    }
  }
  notifyLoadMore(index) {
    if (!isPresent4(index)) {
      return;
    }
    this.loadMore.next(index);
  }
  isActive(index) {
    if (!index) {
      return false;
    }
    return this.isFocused && this.activeIndex === index;
  }
  isFocusable(index) {
    return nodeIndex(this.focusableItem) === index;
  }
  isDisabled(index) {
    if (!index) {
      return false;
    }
    return this.model.findNode(index).disabled;
  }
  registerItem(id2, index, disabled, loadMoreButton = false, visible = true) {
    const itemAtIndex = this.model.findNode(index);
    if (isPresent4(itemAtIndex)) {
      this.model.unregisterItem(itemAtIndex.id, itemAtIndex.index);
      if (this.isActive(index)) {
        this.deactivate();
      }
    }
    this.model.registerItem(id2, index, disabled, loadMoreButton, visible);
  }
  updateItem(index, disabled, visible = true) {
    const itemAtIndex = this.model.findNode(index);
    if (isPresent4(itemAtIndex)) {
      if (this.isActive(index)) {
        this.deactivate();
      }
    }
    itemAtIndex.disabled = disabled;
    itemAtIndex.visible = visible;
  }
  unregisterItem(id2, index) {
    if (this.isActive(index)) {
      this.activateParent(index);
    }
    this.model.unregisterItem(id2, index);
  }
  move(e) {
    if (!this.navigable) {
      return;
    }
    const moveAction = this.actions[e.keyCode];
    if (!moveAction) {
      return;
    }
    moveAction(e);
    e.preventDefault();
  }
  expand({
    expand,
    intercept
  }) {
    const index = nodeIndex(this.activeItem);
    if (!index || intercept(index)) {
      return;
    }
    this.notifyExpand(expand);
  }
  moveToParent() {
    if (this.isActiveExpanded) {
      return false;
    }
    this.activate(this.model.findParent(nodeIndex(this.activeItem)));
    return true;
  }
  moveToFirstVisibleChild() {
    if (!this.isActiveExpanded) {
      return false;
    }
    this.activate(this.model.findVisibleChild(nodeIndex(this.activeItem)));
    return true;
  }
  notifyExpand(expand) {
    this.expands.next(this.navigationState(expand));
  }
  notifyMove() {
    this.moves.next(this.navigationState());
  }
  navigationState(expand = false) {
    return {
      expand,
      index: this.activeIndex,
      isFocused: this.isFocused,
      shouldScroll: this.shouldScroll
    };
  }
  handleEnter(event) {
    if (!this.navigable) {
      return;
    }
    if (this.isLoadMoreButton) {
      this.notifyLoadMore(this.activeIndex);
    } else {
      const isCtrlPressed = event.ctrlKey || event.metaKey;
      if (isCtrlPressed) {
        this.selectIndex(this.activeIndex);
      } else {
        if (this.selection === "multiple") {
          this.deselectAllButCurrentItem.next({
            dataItem: this.activeItem,
            index: this.activeIndex
          });
        } else {
          this.selectIndex(this.activeIndex);
        }
      }
    }
  }
  handleSpace() {
    if (!this.navigable) {
      return;
    }
    if (this.isLoadMoreButton) {
      this.notifyLoadMore(this.activeIndex);
    } else {
      this.checkIndex(this.activeIndex);
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(LocalizationService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var NodeChildrenService = class _NodeChildrenService {
  changes = new Subject();
  childrenLoaded(item, children) {
    this.changes.next({
      item,
      children
    });
  }
  static ɵfac = function NodeChildrenService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeChildrenService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NodeChildrenService,
    factory: _NodeChildrenService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeChildrenService, [{
    type: Injectable
  }], null, null);
})();
var NodeTemplateDirective = class _NodeTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NodeTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NodeTemplateDirective,
    selectors: [["", "kendoTreeViewNodeTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewNodeTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var LoadMoreButtonTemplateDirective = class _LoadMoreButtonTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function LoadMoreButtonTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadMoreButtonTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadMoreButtonTemplateDirective,
    selectors: [["", "kendoTreeViewLoadMoreButtonTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadMoreButtonTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoadMoreButtonTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DataBoundComponent = class _DataBoundComponent {
  static ɵfac = function DataBoundComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataBoundComponent)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DataBoundComponent,
    factory: _DataBoundComponent.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataBoundComponent, [{
    type: Injectable
  }], null, null);
})();
var ExpandableComponent = class _ExpandableComponent {
  static ɵfac = function ExpandableComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandableComponent)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _ExpandableComponent,
    factory: _ExpandableComponent.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableComponent, [{
    type: Injectable
  }], null, null);
})();
var SelectionService = class _SelectionService {
  changes = new Subject();
  firstIndex;
  isFirstSelected(index) {
    return this.firstIndex === index;
  }
  setFirstSelected(index, selected) {
    if (this.firstIndex === index && selected === false) {
      this.firstIndex = null;
    } else if (!this.firstIndex && selected) {
      this.firstIndex = index;
    }
  }
  select(index, dataItem) {
    this.changes.next({
      dataItem,
      index
    });
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService, [{
    type: Injectable
  }], null, null);
})();
var INDEX_REGEX = /\d+$/;
var TreeViewLookupService = class _TreeViewLookupService {
  map = /* @__PURE__ */ new Map();
  reset() {
    this.map.clear();
  }
  registerItem(item, parent) {
    const currentLookup = {
      children: [],
      item,
      parent: this.item(nodeIndex(parent))
    };
    this.map.set(item.index, currentLookup);
  }
  registerChildren(index, children) {
    const item = this.item(index);
    if (!item) {
      return;
    }
    item.children = children;
  }
  unregisterItem(index, dataItem) {
    const current = this.item(index);
    if (current && current.item.dataItem === dataItem) {
      this.map.delete(index);
      if (current.parent && current.parent.children) {
        current.parent.children = current.parent.children.filter((item) => item.dataItem !== dataItem);
      }
    }
  }
  replaceItem(index, item, parent) {
    if (!item) {
      return;
    }
    this.unregisterItem(index, item.dataItem);
    this.registerItem(item, parent);
    this.addToParent(item, parent);
  }
  itemLookup(index) {
    const item = this.item(index);
    if (!item) {
      return null;
    }
    return {
      children: this.mapChildren(item.children),
      item: item.item,
      parent: item.parent
    };
  }
  hasItem(index) {
    return this.map.has(index);
  }
  item(index) {
    return this.map.get(index) || null;
  }
  addToParent(item, parent) {
    if (parent) {
      const parentItem = this.item(parent.index);
      const index = parseInt(INDEX_REGEX.exec(item.index)[0], 10);
      parentItem.children = parentItem.children || [];
      parentItem.children.splice(index, 0, item);
    }
  }
  mapChildren(children = []) {
    return children.map((c) => {
      const {
        item,
        parent,
        children: children2
      } = this.item(c.index);
      return {
        children: this.mapChildren(children2),
        item,
        parent
      };
    });
  }
  static ɵfac = function TreeViewLookupService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewLookupService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _TreeViewLookupService,
    factory: _TreeViewLookupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewLookupService, [{
    type: Injectable
  }], null, null);
})();
var TreeViewItemContentDirective = class _TreeViewItemContentDirective {
  element;
  navigationService;
  selectionService;
  renderer;
  dataItem;
  index;
  initialSelection = false;
  isSelected = isSelected;
  subscriptions = new Subscription();
  constructor(element, navigationService, selectionService, renderer) {
    this.element = element;
    this.navigationService = navigationService;
    this.selectionService = selectionService;
    this.renderer = renderer;
    this.subscriptions.add(this.navigationService.moves.subscribe(this.updateFocusClass.bind(this)));
    this.subscriptions.add(this.navigationService.selects.pipe(filter((index) => index === this.index)).subscribe((index) => this.selectionService.select(index, this.dataItem)));
    this.subscriptions.add(this.selectionService.changes.subscribe(() => {
      this.updateSelectionClass(this.isSelected(this.dataItem, this.index));
    }));
  }
  ngOnChanges(changes) {
    if (changes["initialSelection"]) {
      this.updateSelectionClass(this.initialSelection);
    }
    if (changes["index"]) {
      this.updateFocusClass();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  updateFocusClass() {
    this.render(this.navigationService.isActive(this.index), "k-focus");
  }
  updateSelectionClass(selected) {
    this.render(selected, "k-selected");
  }
  render(addClass, className) {
    const action = addClass ? "addClass" : "removeClass";
    this.renderer[action](this.element.nativeElement, className);
  }
  static ɵfac = function TreeViewItemContentDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewItemContentDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewItemContentDirective,
    selectors: [["", "kendoTreeViewItemContent", ""]],
    inputs: {
      dataItem: "dataItem",
      index: "index",
      initialSelection: "initialSelection",
      isSelected: "isSelected"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewItemContentDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewItemContent]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NavigationService
    }, {
      type: SelectionService
    }, {
      type: Renderer2
    }];
  }, {
    dataItem: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    initialSelection: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }]
  });
})();
var LoadingIndicatorDirective = class _LoadingIndicatorDirective {
  expandService;
  loadingService;
  cd;
  get loading() {
    return this._loading;
  }
  set loading(value) {
    this._loading = value;
    this.cd.markForCheck();
  }
  index;
  _loading = false;
  subscription;
  constructor(expandService, loadingService, cd) {
    this.expandService = expandService;
    this.loadingService = loadingService;
    this.cd = cd;
  }
  ngOnInit() {
    const loadingNotifications = this.loadingService.changes.pipe(filter((index) => index === this.index));
    this.subscription = this.expandService.changes.pipe(filter(({
      index
    }) => index === this.index), tap(({
      expand
    }) => {
      if (!expand && this.loading) {
        this.loading = false;
      }
    }), filter(({
      expand
    }) => expand), switchMap((x) => of(x).pipe(delay(100), takeUntil(loadingNotifications)))).subscribe(() => this.loading = true);
    this.subscription.add(loadingNotifications.subscribe(() => this.loading = false));
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  static ɵfac = function LoadingIndicatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadingIndicatorDirective)(ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(LoadingNotificationService), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadingIndicatorDirective,
    selectors: [["", "kendoTreeViewLoading", ""]],
    hostVars: 2,
    hostBindings: function LoadingIndicatorDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-i-loading", ctx.loading);
      }
    },
    inputs: {
      index: [0, "kendoTreeViewLoading", "index"]
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadingIndicatorDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoading]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandStateService
    }, {
      type: LoadingNotificationService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    loading: [{
      type: HostBinding,
      args: ["class.k-i-loading"]
    }],
    index: [{
      type: Input,
      args: ["kendoTreeViewLoading"]
    }]
  });
})();
var buildItem = (index, dataItem) => ({
  dataItem,
  index
});
var id = 0;
var TREE_ITEM_ROLE = "treeitem";
var BUTTON_ROLE = "button";
var TreeViewItemDirective = class _TreeViewItemDirective {
  element;
  expandService;
  navigationService;
  selectionService;
  lookupService;
  renderer;
  ib;
  dataItem;
  index;
  parentDataItem;
  parentIndex;
  role = TREE_ITEM_ROLE;
  loadOnDemand = true;
  checkable;
  selectable;
  expandable;
  set isChecked(checked) {
    if (checked === "checked") {
      this.ariaChecked = "true";
    } else if (checked === "indeterminate") {
      this.ariaChecked = "mixed";
    } else {
      this.ariaChecked = "false";
    }
  }
  isDisabled = false;
  isVisible = true;
  get isExpanded() {
    return this._isExpanded || false;
  }
  set isExpanded(isExpanded2) {
    this._isExpanded = isExpanded2;
  }
  get isSelected() {
    return this._isSelected || false;
  }
  set isSelected(isSelected2) {
    this._isSelected = isSelected2;
  }
  get isButton() {
    return this.role === BUTTON_ROLE;
  }
  get treeItem() {
    return buildItem(this.index, this.dataItem);
  }
  get parentTreeItem() {
    return this.parentDataItem ? buildItem(this.parentIndex, this.parentDataItem) : null;
  }
  ariaChecked = "false";
  id = id++;
  _isExpanded;
  _isSelected;
  isInitialized = false;
  subscriptions = [];
  constructor(element, expandService, navigationService, selectionService, lookupService, renderer, ib) {
    this.element = element;
    this.expandService = expandService;
    this.navigationService = navigationService;
    this.selectionService = selectionService;
    this.lookupService = lookupService;
    this.renderer = renderer;
    this.ib = ib;
    this.subscribe();
  }
  ngOnInit() {
    if (this.loadOnDemand && !this.isButton) {
      this.lookupService.registerItem(this.treeItem, this.parentTreeItem);
    }
    this.registerNavigationItem();
    this.isInitialized = true;
    this.setAttribute("role", this.role);
    this.setAriaAttributes();
    this.updateTabIndex();
  }
  ngOnChanges(changes) {
    const {
      index
    } = changes;
    if (anyChanged(["index", "checkable", "isChecked", "expandable", "isExpanded", "selectable", "isSelected"], changes)) {
      this.setAriaAttributes();
    }
    if (this.loadOnDemand && !this.isButton) {
      this.moveLookupItem(changes);
    }
    this.moveNavigationItem(index);
    if (anyChanged(["isDisabled", "isVisible"], changes)) {
      this.updateNodeAvailability();
    }
  }
  ngOnDestroy() {
    this.navigationService.unregisterItem(this.id, this.index);
    if (this.loadOnDemand && !this.isButton) {
      this.lookupService.unregisterItem(this.index, this.dataItem);
    }
    this.subscriptions = this.subscriptions.reduce((list, callback) => (callback.unsubscribe(), list), []);
  }
  subscribe() {
    this.subscriptions = [this.navigationService.moves.subscribe((navState) => {
      this.updateTabIndex();
      this.focusItem(navState.shouldScroll);
    }), this.navigationService.expands.pipe(filter(({
      index
    }) => index === this.index && !this.isDisabled)).subscribe(({
      expand
    }) => this.expand(expand))];
  }
  registerNavigationItem() {
    this.navigationService.registerItem(this.id, this.index, this.isDisabled, this.isButton, this.isVisible);
    this.activateItem();
  }
  activateItem() {
    if (this.isDisabled) {
      return;
    }
    const navigationService = this.navigationService;
    const selectionService = this.selectionService;
    const index = this.index;
    selectionService.setFirstSelected(index, this.isSelected);
    if (!navigationService.isActive(index) && selectionService.isFirstSelected(index)) {
      navigationService.activateIndex(index);
    }
  }
  expand(shouldExpand) {
    this.expandService[shouldExpand ? "expand" : "collapse"](this.index, this.dataItem);
  }
  isFocusable() {
    return !this.isDisabled && this.navigationService.isFocusable(this.index);
  }
  focusItem(scrollIntoView = false) {
    if (this.isInitialized && this.navigationService.isActive(this.index)) {
      this.element.nativeElement.focus({
        preventScroll: !scrollIntoView
      });
    }
  }
  moveLookupItem(changes = {}) {
    const {
      dataItem,
      index,
      parentDataItem,
      parentIndex
    } = changes;
    if (index && index.firstChange || //skip first change
    !dataItem && !index && !parentDataItem && !parentIndex) {
      return;
    }
    const oldIndex = (index || {}).previousValue || this.index;
    this.lookupService.replaceItem(oldIndex, this.treeItem, this.parentTreeItem);
  }
  moveNavigationItem(indexChange = {}) {
    const {
      currentValue,
      firstChange,
      previousValue
    } = indexChange;
    if (!firstChange && isPresent4(currentValue) && isPresent4(previousValue)) {
      this.navigationService.unregisterItem(this.id, previousValue);
      this.navigationService.registerItem(this.id, currentValue, this.isDisabled, this.isButton);
    }
  }
  updateNodeAvailability() {
    const service = this.navigationService;
    if (this.isDisabled || !this.isVisible && this.navigationService.isTreeViewActive) {
      service.activateClosest(this.index);
    } else {
      service.activateFocusable();
    }
    service.updateItem(this.index, this.isDisabled, this.isVisible);
  }
  setAriaAttributes() {
    this.setAttribute("aria-level", this.ib.level(this.index).toString());
    this.setAttribute("aria-expanded", this.expandable ? this.isExpanded.toString() : null);
    this.setAttribute("aria-selected", this.selectable ? this.isSelected.toString() : null);
    this.setAttribute("aria-checked", this.checkable ? this.ariaChecked : null);
  }
  updateTabIndex() {
    this.setAttribute("tabIndex", this.isFocusable() ? "0" : "-1");
  }
  setAttribute(attr, value) {
    if (!isPresent4(value)) {
      this.renderer.removeAttribute(this.element.nativeElement, attr);
      return;
    }
    this.renderer.setAttribute(this.element.nativeElement, attr, value);
  }
  static ɵfac = function TreeViewItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewItemDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(IndexBuilderService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewItemDirective,
    selectors: [["", "kendoTreeViewItem", ""]],
    inputs: {
      dataItem: "dataItem",
      index: "index",
      parentDataItem: "parentDataItem",
      parentIndex: "parentIndex",
      role: "role",
      loadOnDemand: "loadOnDemand",
      checkable: "checkable",
      selectable: "selectable",
      expandable: "expandable",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      isVisible: "isVisible",
      isExpanded: "isExpanded",
      isSelected: "isSelected"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewItemDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewItem]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ExpandStateService
    }, {
      type: NavigationService
    }, {
      type: SelectionService
    }, {
      type: TreeViewLookupService
    }, {
      type: Renderer2
    }, {
      type: IndexBuilderService
    }];
  }, {
    dataItem: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    parentDataItem: [{
      type: Input
    }],
    parentIndex: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    checkable: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    expandable: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }]
  });
})();
var TOP_ITEM = "k-treeview-top";
var MID_ITEM = "k-treeview-mid";
var BOT_ITEM = "k-treeview-bot";
var TreeViewGroupComponent = class _TreeViewGroupComponent {
  expandService;
  loadingService;
  indexBuilder;
  treeViewLookupService;
  navigationService;
  nodeChildrenService;
  dataChangeNotification;
  changeDetectorRef;
  localization;
  renderer;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  caretAltRightIcon = caretAltRightIcon;
  /**
   * @hidden
   */
  caretAltLeftIcon = caretAltLeftIcon;
  /**
   * @hidden
   */
  loadMoreTitle;
  kGroupClass = true;
  get role() {
    return this.parentIndex ? "group" : "tree";
  }
  checkboxes;
  expandIcons;
  disabled;
  selectable;
  touchActions;
  disableParentNodesOnly;
  loadOnDemand = true;
  trackBy;
  nodes;
  textField = "";
  parentDataItem;
  parentIndex;
  nodeTemplateRef;
  loadMoreButtonTemplateRef;
  loadMoreService;
  size = "medium";
  expandDisabledNodes;
  initialNodesLoaded = false;
  loadingMoreNodes = false;
  isItemExpandable = (node, index) => this.expandDisabledNodes || !this.isItemDisabled(node, index);
  getFontIcon(node, index) {
    return this.isExpanded(node, index) ? "caret-alt-down" : !this.localization.rtl ? "caret-alt-right" : "caret-alt-left";
  }
  getSvgIcon(node, index) {
    return this.isExpanded(node, index) ? caretAltDownIcon : !this.localization.rtl ? caretAltRightIcon : caretAltLeftIcon;
  }
  get moreNodesAvailable() {
    if (!isPresent4(this.loadMoreService) || this.data.length === 0) {
      return false;
    }
    return this.pageSize < this.totalNodesCount;
  }
  get pageSize() {
    if (!isPresent4(this.loadMoreService)) {
      return null;
    }
    return this.loadMoreService.getGroupSize(this.parentDataItem);
  }
  set pageSize(pageSize) {
    this.loadMoreService.setGroupSize(this.parentDataItem, pageSize);
  }
  get data() {
    if (isPresent4(this.pageSize)) {
      const normalizedSizeValue = this.pageSize > 0 ? this.pageSize : 0;
      return this._data.slice(0, normalizedSizeValue);
    }
    return this._data;
  }
  set data(data) {
    this._data = data;
    this.registerLoadedNodes(this.data);
  }
  get loadMoreButtonIndex() {
    if (!this.loadMoreService) {
      return null;
    }
    return this.nodeIndex(this.data.length);
  }
  /**
   * Represents the total number of nodes for the current level.
   */
  get totalNodesCount() {
    if (!this.loadMoreService) {
      return this.data.length;
    }
    return this.loadMoreService.getTotalNodesCount(this.parentDataItem, this._data.length);
  }
  _data = [];
  nodesSubscription;
  loadMoreNodesSubscription;
  singleRecordSubscriptions = new Subscription();
  localizationSubscriptions = new Subscription();
  constructor(expandService, loadingService, indexBuilder2, treeViewLookupService, navigationService, nodeChildrenService, dataChangeNotification, changeDetectorRef, localization, renderer) {
    this.expandService = expandService;
    this.loadingService = loadingService;
    this.indexBuilder = indexBuilder2;
    this.treeViewLookupService = treeViewLookupService;
    this.navigationService = navigationService;
    this.nodeChildrenService = nodeChildrenService;
    this.dataChangeNotification = dataChangeNotification;
    this.changeDetectorRef = changeDetectorRef;
    this.localization = localization;
    this.renderer = renderer;
  }
  isChecked = () => "none";
  isDisabled = () => false;
  hasCheckbox = () => true;
  isExpanded = () => false;
  isVisible = () => true;
  isSelected = () => false;
  children = () => of([]);
  hasChildren = () => false;
  get hasTemplate() {
    return isPresent4(this.nodeTemplateRef);
  }
  expandNode(index, dataItem, expand) {
    if (expand) {
      this.expandService.expand(index, dataItem);
    } else {
      this.expandService.collapse(index, dataItem);
    }
  }
  checkNode(index, checkBox) {
    this.navigationService.checkIndex(index);
    this.navigationService.activateIndex(index);
    if (checkBox?.input) {
      this.renderer.removeClass(checkBox.input.nativeElement, "k-focus");
    }
  }
  nodeIndex(index) {
    return this.indexBuilder.nodeIndex(index.toString(), this.parentIndex);
  }
  nodeText(dataItem) {
    const textField = isArray(this.textField) ? this.textField[0] : this.textField;
    return getter(textField)(dataItem);
  }
  getCheckBoxState(item, index) {
    const state = this.isChecked(item, index);
    if (state === "indeterminate") {
      return state;
    }
    return state === "checked";
  }
  getCheckboxAttributes(index) {
    return {
      "aria-hidden": "true",
      role: "none",
      "aria-labelledby": this.nodeIndex(index)
    };
  }
  ngOnDestroy() {
    if (isPresent4(this.nodesSubscription)) {
      this.nodesSubscription.unsubscribe();
    }
    if (isPresent4(this.loadMoreNodesSubscription)) {
      this.loadMoreNodesSubscription.unsubscribe();
    }
    this.singleRecordSubscriptions.unsubscribe();
    this.localizationSubscriptions.unsubscribe();
  }
  ngOnInit() {
    this.subscribeToNodesChange();
    this.singleRecordSubscriptions.add(this.dataChangeNotification.changes.subscribe(this.subscribeToNodesChange.bind(this)));
    this.singleRecordSubscriptions.add(this.navigationService.loadMore.pipe(filter((index) => index === this.loadMoreButtonIndex)).subscribe(this.loadMoreNodes.bind(this)));
    this.localizationSubscriptions.add(this.localization.changes.subscribe(this.l10nChange.bind(this)));
  }
  ngOnChanges(changes) {
    if (changes.parentIndex && this.loadOnDemand) {
      this.setNodeChildren(this.mapToTreeItem(this.data));
    }
    if (this.localization.get("loadMore")) {
      this.loadMoreTitle = this.localization.get("loadMore");
    }
  }
  l10nChange() {
    if (this.localization.get("loadMore")) {
      this.loadMoreTitle = this.localization.get("loadMore");
    }
    this.changeDetectorRef.markForCheck();
  }
  fetchChildren(node, index) {
    return this.children(node).pipe(catchError(() => {
      this.loadingService.notifyLoaded(index);
      return EMPTY;
    }), tap(() => this.loadingService.notifyLoaded(index)));
  }
  get nextFields() {
    if (isArray(this.textField)) {
      return this.textField.length > 1 ? this.textField.slice(1) : this.textField;
    }
    return [this.textField];
  }
  loadMoreNodes() {
    if (isPresent4(this.loadMoreService.loadMoreNodes)) {
      this.fetchMoreNodes();
    } else {
      this.loadMoreLocalNodes();
    }
  }
  /**
   * @hidden
   */
  isItemDisabled(node, index) {
    return this.disabled && !this.disableParentNodesOnly || this.isDisabled(node, this.nodeIndex(index));
  }
  /**
   * @hidden
   */
  setItemClasses(dataLength, index) {
    if (dataLength === 1) {
      return this.parentIndex ? BOT_ITEM : `${TOP_ITEM} ${BOT_ITEM}`;
    }
    if (index === 0) {
      return TOP_ITEM;
    }
    if (index > 0 && index < dataLength - 1) {
      return MID_ITEM;
    }
    return index === this.totalNodesCount - 1 ? BOT_ITEM : MID_ITEM;
  }
  loadMoreLocalNodes() {
    const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
    this.pageSize += this.loadMoreService.getInitialPageSize(this.parentDataItem);
    this.registerLoadedNodes(this.data);
    this.changeDetectorRef.detectChanges();
    this.reselectItemAt(initialLoadMoreButtonIndex);
  }
  fetchMoreNodes() {
    if (this.loadingMoreNodes) {
      return;
    }
    this.loadingMoreNodes = true;
    if (isPresent4(this.loadMoreNodesSubscription)) {
      this.loadMoreNodesSubscription.unsubscribe();
    }
    this.loadMoreNodesSubscription = this.loadMoreService.loadMoreNodes({
      dataItem: this.parentDataItem,
      skip: this.data.length,
      take: this.loadMoreService.getInitialPageSize(this.parentDataItem)
    }).pipe(finalize(() => this.loadingMoreNodes = false)).subscribe((items) => {
      if (!(Array.isArray(items) && items.length > 0)) {
        return;
      }
      const initialLoadMoreButtonIndex = this.loadMoreButtonIndex;
      this.pageSize += items.length;
      this.data = this.data.concat(items);
      if (this.navigationService.isActive(initialLoadMoreButtonIndex)) {
        this.changeDetectorRef.detectChanges();
        this.reselectItemAt(initialLoadMoreButtonIndex);
      }
    });
  }
  setNodeChildren(children) {
    this.treeViewLookupService.registerChildren(this.parentIndex, children);
  }
  mapToTreeItem(data) {
    if (!this.parentIndex) {
      return [];
    }
    return data.map((dataItem, idx) => ({
      dataItem,
      index: this.nodeIndex(idx)
    }));
  }
  emitChildrenLoaded(children) {
    if (!this.parentIndex) {
      return;
    }
    const contentChildren = children.filter((item) => item.dataItem);
    this.nodeChildrenService.childrenLoaded({
      dataItem: this.parentDataItem,
      index: this.parentIndex
    }, contentChildren);
  }
  subscribeToNodesChange() {
    if (this.nodesSubscription) {
      this.nodesSubscription.unsubscribe();
    }
    this.nodesSubscription = this.nodes(this.parentDataItem, this.parentIndex).subscribe((data) => {
      this.data = data;
      this.initialNodesLoaded = true;
    });
  }
  reselectItemAt(index) {
    if (!isPresent4(index)) {
      return;
    }
    this.navigationService.deactivate();
    this.navigationService.activateIndex(index);
  }
  registerLoadedNodes(nodes = []) {
    const mappedChildren = this.mapToTreeItem(nodes);
    if (this.loadOnDemand) {
      this.setNodeChildren(mappedChildren);
    }
    this.emitChildrenLoaded(mappedChildren);
  }
  static ɵfac = function TreeViewGroupComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewGroupComponent)(ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(LoadingNotificationService), ɵɵdirectiveInject(IndexBuilderService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(NodeChildrenService), ɵɵdirectiveInject(DataChangeNotificationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TreeViewGroupComponent,
    selectors: [["", "kendoTreeViewGroup", ""]],
    hostVars: 3,
    hostBindings: function TreeViewGroupComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("role", ctx.role);
        ɵɵclassProp("k-treeview-group", ctx.kGroupClass);
      }
    },
    inputs: {
      checkboxes: "checkboxes",
      expandIcons: "expandIcons",
      disabled: "disabled",
      selectable: "selectable",
      touchActions: "touchActions",
      disableParentNodesOnly: "disableParentNodesOnly",
      loadOnDemand: "loadOnDemand",
      trackBy: "trackBy",
      nodes: "nodes",
      textField: "textField",
      parentDataItem: "parentDataItem",
      parentIndex: "parentIndex",
      nodeTemplateRef: "nodeTemplateRef",
      loadMoreButtonTemplateRef: "loadMoreButtonTemplateRef",
      loadMoreService: "loadMoreService",
      size: "size",
      expandDisabledNodes: "expandDisabledNodes",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      hasCheckbox: "hasCheckbox",
      isExpanded: "isExpanded",
      isVisible: "isVisible",
      isSelected: "isSelected",
      children: "children",
      hasChildren: "hasChildren"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c03,
    decls: 2,
    vars: 3,
    consts: [["checkbox", ""], ["class", "k-treeview-item", "kendoTreeViewItem", "", 3, "k-hidden", "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "k-treeview-item", "kendoTreeViewItem", "", "role", "button", 3, "k-treeview-load-more-checkboxes-container", "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex", 4, "ngIf"], ["kendoTreeViewItem", "", 1, "k-treeview-item", 3, "dataItem", "index", "parentDataItem", "parentIndex", "loadOnDemand", "checkable", "isChecked", "isDisabled", "isVisible", "expandable", "isExpanded", "selectable", "isSelected"], [3, "ngClass"], ["class", "k-treeview-toggle", 3, "k-disabled", "kendoTreeViewLoading", "click", 4, "ngIf"], [3, "disabled", "size", "checkedState", "tabindex", "inputAttributes", "checkedStateChange", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", 3, "id", "dataItem", "index", "initialSelection", "isSelected"], [1, "k-treeview-leaf-text"], [3, "ngSwitch"], [4, "ngSwitchCase"], [4, "ngSwitchDefault"], ["kendoTreeViewGroup", "", "role", "group", 3, "size", "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disabled", "expandDisabledNodes", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy", "disableParentNodesOnly", 4, "ngIf"], [1, "k-treeview-toggle", 3, "click", "kendoTreeViewLoading"], [3, "name", "svgIcon"], [3, "checkedStateChange", "disabled", "size", "checkedState", "tabindex", "inputAttributes"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["kendoTreeViewGroup", "", "role", "group", 3, "size", "nodes", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disabled", "expandDisabledNodes", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "parentIndex", "parentDataItem", "textField", "loadMoreService", "trackBy", "disableParentNodesOnly"], ["kendoTreeViewItem", "", "role", "button", 1, "k-treeview-item", 3, "selectable", "checkable", "expandable", "index", "parentDataItem", "parentIndex"], [1, "k-treeview-bot"], ["class", "k-icon k-i-loading", 4, "ngIf"], ["kendoTreeViewItemContent", "", 1, "k-treeview-leaf", "k-treeview-load-more-button", 3, "index"], [4, "ngIf"], [1, "k-icon", "k-i-loading"]],
    template: function TreeViewGroupComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, TreeViewGroupComponent_li_0_Template, 10, 33, "li", 1)(1, TreeViewGroupComponent_li_1_Template, 7, 14, "li", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.data)("ngForTrackBy", ctx.trackBy);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.initialNodesLoaded && ctx.moreNodesAvailable);
      }
    },
    dependencies: [_TreeViewGroupComponent, NgForOf, TreeViewItemDirective, NgClass, NgIf, LoadingIndicatorDirective, IconWrapperComponent, CheckBoxComponent, TreeViewItemContentDirective, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault],
    encapsulation: 2,
    data: {
      animation: [trigger("toggle", [transition("void => *", [style({
        height: 0
      }), animate("0.1s ease-in", style({
        height: "*"
      }))]), transition("* => void", [style({
        height: "*"
      }), animate("0.1s ease-in", style({
        height: 0
      }))])])]
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewGroupComponent, [{
    type: Component,
    args: [{
      animations: [trigger("toggle", [transition("void => *", [style({
        height: 0
      }), animate("0.1s ease-in", style({
        height: "*"
      }))]), transition("* => void", [style({
        height: "*"
      }), animate("0.1s ease-in", style({
        height: 0
      }))])])],
      // eslint-disable-next-line
      selector: "[kendoTreeViewGroup]",
      template: `
        <li
            *ngFor="let node of data; let index = index; trackBy: trackBy"
            class="k-treeview-item"
            [class.k-hidden]="!isVisible(node, nodeIndex(index))"
            kendoTreeViewItem
            [attr.aria-setsize]="totalNodesCount"
            [dataItem]="node"
            [index]="nodeIndex(index)"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [loadOnDemand]="loadOnDemand"
            [checkable]="checkboxes"
            [isChecked]="isChecked(node, nodeIndex(index))"
            [isDisabled]="isItemDisabled(node, index)"
            [isVisible]="isVisible(node, nodeIndex(index))"
            [expandable]="expandIcons && hasChildren(node)"
            [isExpanded]="isExpanded(node, nodeIndex(index))"
            [selectable]="selectable"
            [isSelected]="isSelected(node, nodeIndex(index))"
            [attr.data-treeindex]="nodeIndex(index)"
        >
            <div [ngClass]="setItemClasses(data.length, index)">
                <span
                    [class.k-disabled]="!isItemExpandable(node, index)"
                    class="k-treeview-toggle"
                    [kendoTreeViewLoading]="nodeIndex(index)"
                    (click)="expandNode(nodeIndex(index), node, !isExpanded(node, nodeIndex(index)))"
                    *ngIf="expandIcons && hasChildren(node)"
                >
                    <kendo-icon-wrapper
                        [name]="getFontIcon(node, nodeIndex(index))"
                        [svgIcon]="getSvgIcon(node, nodeIndex(index))">
                    </kendo-icon-wrapper>
                </span>
                <kendo-checkbox
                    #checkbox
                    *ngIf="checkboxes && hasCheckbox(node, nodeIndex(index))"
                    [disabled]="isItemDisabled(node, index)"
                    [size]="size"
                    [checkedState]="getCheckBoxState(node, nodeIndex(index))"
                    (checkedStateChange)="checkNode(nodeIndex(index), checkbox)"
                    [tabindex]="-1"
                    [inputAttributes]="getCheckboxAttributes(index)"
                ></kendo-checkbox>
                <span kendoTreeViewItemContent
                    [id]="nodeIndex(index)"
                    [attr.data-treeindex]="nodeIndex(index)"
                    [dataItem]="node"
                    [index]="nodeIndex(index)"
                    [initialSelection]="isSelected(node, nodeIndex(index))"
                    [isSelected]="isSelected"
                    class="k-treeview-leaf"
                    [style.touch-action]="touchActions ? '' : 'none'"
                    [class.k-disabled]="isItemDisabled(node, index)"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-container [ngSwitch]="hasTemplate">
                            <ng-container *ngSwitchCase="true">
                                <ng-template
                                    [ngTemplateOutlet]="nodeTemplateRef"
                                    [ngTemplateOutletContext]="{
                                        $implicit: node,
                                        index: nodeIndex(index)
                                    }"
                                >
                                </ng-template>
                            </ng-container>
                            <ng-container *ngSwitchDefault>
                                {{nodeText(node)}}
                            </ng-container>
                        </ng-container>
                    </span>
                </span>
            </div>
            <ul
                *ngIf="isExpanded(node, nodeIndex(index)) && hasChildren(node)"
                kendoTreeViewGroup
                role="group"
                [size]="size"
                [nodes]="fetchChildren"
                [loadOnDemand]="loadOnDemand"
                [checkboxes]="checkboxes"
                [expandIcons]="expandIcons"
                [selectable]="selectable"
                [touchActions]="touchActions"
                [children]="children"
                [hasChildren]="hasChildren"
                [isChecked]="isChecked"
                [isDisabled]="isDisabled"
                [hasCheckbox]="hasCheckbox"
                [disabled]="isItemDisabled(node, index)"
                [expandDisabledNodes]="expandDisabledNodes"
                [isExpanded]="isExpanded"
                [isSelected]="isSelected"
                [isVisible]="isVisible"
                [nodeTemplateRef]="nodeTemplateRef"
                [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef"
                [parentIndex]="nodeIndex(index)"
                [parentDataItem]="node"
                [textField]="nextFields"
                [loadMoreService]="loadMoreService"
                [@toggle]="true"
                [trackBy]="trackBy"
                [disableParentNodesOnly]="disableParentNodesOnly"
            >
            </ul>
        </li>
        <li
            *ngIf="initialNodesLoaded && moreNodesAvailable"
            class="k-treeview-item"
            [class.k-treeview-load-more-checkboxes-container]="checkboxes"
            kendoTreeViewItem
            role="button"
            [selectable]="false"
            [checkable]="false"
            [expandable]="false"
            [index]="loadMoreButtonIndex"
            [parentDataItem]="parentDataItem"
            [parentIndex]="parentIndex"
            [attr.data-treeindex]="loadMoreButtonIndex"
        >
            <div class="k-treeview-bot">
                <span
                    *ngIf="loadingMoreNodes"
                    class="k-icon k-i-loading"
                >
                </span>
                <span
                    class="k-treeview-leaf k-treeview-load-more-button"
                    [attr.data-treeindex]="loadMoreButtonIndex"
                    kendoTreeViewItemContent
                    [index]="loadMoreButtonIndex"
                >
                    <span class="k-treeview-leaf-text">
                        <ng-template
                            *ngIf="loadMoreButtonTemplateRef"
                            [ngTemplateOutlet]="loadMoreButtonTemplateRef"
                            [ngTemplateOutletContext]="{
                                index: loadMoreButtonIndex
                            }"
                        >
                        </ng-template>
                        <ng-container *ngIf="!loadMoreButtonTemplateRef">
                            {{ loadMoreTitle }}
                        </ng-container>
                    </span>
                </span>
            </div>
        </li>
    `,
      standalone: true,
      imports: [NgForOf, TreeViewItemDirective, NgClass, NgIf, LoadingIndicatorDirective, IconWrapperComponent, CheckBoxComponent, TreeViewItemContentDirective, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault]
    }]
  }], function() {
    return [{
      type: ExpandStateService
    }, {
      type: LoadingNotificationService
    }, {
      type: IndexBuilderService
    }, {
      type: TreeViewLookupService
    }, {
      type: NavigationService
    }, {
      type: NodeChildrenService
    }, {
      type: DataChangeNotificationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: Renderer2
    }];
  }, {
    kGroupClass: [{
      type: HostBinding,
      args: ["class.k-treeview-group"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    checkboxes: [{
      type: Input
    }],
    expandIcons: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    touchActions: [{
      type: Input
    }],
    disableParentNodesOnly: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    parentDataItem: [{
      type: Input
    }],
    parentIndex: [{
      type: Input
    }],
    nodeTemplateRef: [{
      type: Input
    }],
    loadMoreButtonTemplateRef: [{
      type: Input
    }],
    loadMoreService: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    expandDisabledNodes: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    hasCheckbox: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }],
    children: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }]
  });
})();
var TreeViewMessages = class _TreeViewMessages extends ComponentMessages {
  /**
   * Sets the text for the `Load More` button title.
   */
  loadMore;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵTreeViewMessages_BaseFactory;
    return function TreeViewMessages_Factory(__ngFactoryType__) {
      return (ɵTreeViewMessages_BaseFactory || (ɵTreeViewMessages_BaseFactory = ɵɵgetInheritedFactory(_TreeViewMessages)))(__ngFactoryType__ || _TreeViewMessages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _TreeViewMessages,
    selectors: [["kendo-treeview-messages-base"]],
    inputs: {
      loadMore: "loadMore"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewMessages, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line @angular-eslint/directive-selector
      selector: "kendo-treeview-messages-base"
    }]
  }], null, {
    loadMore: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective = class _LocalizedMessagesDirective extends TreeViewMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoTreeViewLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TreeViewMessages,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective, [{
    type: Directive,
    args: [{
      providers: [{
        provide: TreeViewMessages,
        useExisting: forwardRef(() => LocalizedMessagesDirective)
      }],
      selector: "[kendoTreeViewLocalizedMessages]",
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var nextId2 = 0;
var LOAD_MORE_DOC_LINK$1 = "https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/";
var providers = [ExpandStateService, IndexBuilderService, TreeViewLookupService, LoadingNotificationService, NodeChildrenService, NavigationService, SelectionService, DataChangeNotificationService, LocalizationService, {
  provide: L10N_PREFIX,
  useValue: "kendo.treeview"
}, {
  provide: DataBoundComponent,
  useExisting: forwardRef(() => TreeViewComponent)
}, {
  provide: ExpandableComponent,
  useExisting: forwardRef(() => TreeViewComponent)
}];
var TreeViewComponent = class _TreeViewComponent {
  element;
  changeDetectorRef;
  expandService;
  navigationService;
  nodeChildrenService;
  selectionService;
  treeViewLookupService;
  ngZone;
  renderer;
  dataChangeNotification;
  localization;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  classNames = true;
  /** @hidden */
  get direction() {
    return this.localization.rtl ? "rtl" : "ltr";
  }
  /**
   * @hidden
   */
  assetsContainer;
  /**
   * @hidden
   */
  searchbox;
  /**
   * Sets the placeholder text for the filter input when the component is empty.
   */
  filterInputPlaceholder = "";
  /**
   * Allows expanding disabled nodes.
   *
   * @default false
   */
  expandDisabledNodes;
  /**
   * Enables or disables content animation.
   */
  set animate(value) {
    this._animate = value;
  }
  get animate() {
    return !this._animate;
  }
  /** @hidden */
  fetchNodes = () => this.data;
  /**
   * Fires when the children of the expanded node are loaded.
   */
  childrenLoaded = new EventEmitter();
  /**
    * Fires when the component loses focus.
    */
  onBlur = new EventEmitter();
  /**
   * Fires when the component receives focus.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when a TreeView node expands.
   */
  expand = new EventEmitter();
  /**
   * Fires when a TreeView node collapses.
   */
  collapse = new EventEmitter();
  /**
   * Fires just before node dragging starts ([see example](slug:draganddrop_treeview#setup)). This event is preventable.
   * Prevent the default event to stop drag hint creation and further drag events.
   */
  nodeDragStart = new EventEmitter();
  /**
   * Fires when an item is being dragged ([see example](slug:draganddrop_treeview#setup)).
   */
  nodeDrag = new EventEmitter();
  /**
   * Emits when the built-in filtering mechanism updates node visibility.
   * Used for the built-in auto-expand functionalities. Handle this event for custom implementations.
   */
  filterStateChange = new EventEmitter();
  /**
   * Fires on the target TreeView when a dragged item is dropped ([see example](slug:draganddrop_treeview#setup)).
   *
   * Prevent the default event (`event.preventDefault()`) or set the event as invalid (`event.setValid(false)`) to stop the `addItem` and `removeItem` events from triggering.
   *
   * Use `preventDefault` to handle add/remove manually, or `setValid(false)` to indicate an unsuccessful operation. While `setValid(false)` animates the drag clue to its original position, `event.preventDefault()` simply removes the clue.
   */
  nodeDrop = new EventEmitter();
  /**
   * Fires on the source TreeView after the dragged item is dropped ([see example](slug:draganddrop_treeview#setup)).
   */
  nodeDragEnd = new EventEmitter();
  /**
   * Fires after a dragged item is dropped ([see example](slug:draganddrop_treeview#setup)). Called on the TreeView where the item is dropped.
   */
  addItem = new EventEmitter();
  /**
   * Fires after a dragged item is dropped ([see example](slug:draganddrop_treeview#setup)). Called on the TreeView from where the item is dragged.
   */
  removeItem = new EventEmitter();
  /**
   * Fires when a TreeView node checkbox is selected ([see example](slug:checkboxes_treeview#toc-modifying-the-checked-state)).
   */
  checkedChange = new EventEmitter();
  /**
   * Fires when a TreeView node is selected ([see example](slug:selection_treeview#toc-modifying-the-selection)).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires when the value of the built-in filter input changes.
   */
  filterChange = new EventEmitter();
  /**
   * Fires when a TreeView node is clicked.
   */
  nodeClick = new EventEmitter();
  /**
   * Fires when a TreeView node is double-clicked.
   */
  nodeDblClick = new EventEmitter();
  /**
   * @hidden
   *
   * Queries the template for a node template declaration.
   * Ignored if a `[nodeTemplate]` value is explicitly provided.
   */
  nodeTemplateQuery;
  /**
   * @hidden
   *
   * Defines the template for each node.
   * Takes precedence over nested templates in the TreeView tag.
   */
  set nodeTemplateRef(template) {
    this._nodeTemplateRef = template;
  }
  get nodeTemplateRef() {
    return this._nodeTemplateRef || this.nodeTemplateQuery;
  }
  /**
   * @hidden
   *
   * Queries the template for a load-more button template declaration.
   * Ignored if a `[loadMoreButtonTemplate]` value is explicitly provided.
   */
  loadMoreButtonTemplateQuery;
  /**
   * @hidden
   *
   * Defines the template for each load-more button.
   * Takes precedence over nested templates in the TreeView tag.
   */
  set loadMoreButtonTemplateRef(template) {
    this._loadMoreButtonTemplateRef = template;
  }
  get loadMoreButtonTemplateRef() {
    return this._loadMoreButtonTemplateRef || this.loadMoreButtonTemplateQuery;
  }
  /**
   * A function that defines how to track node changes.
   * By default, the TreeView tracks the nodes by data item object reference.
   */
  trackBy = trackBy;
  /**
   * The nodes displayed by the TreeView ([see example](slug:databinding_treeview)).
   */
  set nodes(value) {
    this.data.next(value || []);
    this.dataChangeNotification.notify();
  }
  get nodes() {
    return this.data.value;
  }
  /**
   * The fields of the data item that provide the text content of the nodes ([see example](slug:databinding_treeview)).
   * If set to an array, each level uses the field at the same index or the last item in the array.
   */
  textField;
  /**
   * A function that determines if a node has child nodes ([see example](slug:databinding_treeview)).
   */
  get hasChildren() {
    return this._hasChildren || hasChildren;
  }
  set hasChildren(callback) {
    this._hasChildren = callback;
    this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
  }
  /**
   * A function that determines if a node is checked ([see example](slug:checkboxes_treeview#toc-modifying-the-checked-state)).
   */
  get isChecked() {
    return this._isChecked || isChecked;
  }
  set isChecked(callback) {
    this._isChecked = callback;
    this.checkboxes = Boolean(this._isChecked);
  }
  /**
   * A function that determines if a node is disabled.
   */
  isDisabled = isDisabled;
  /**
   * A function that determines if a node has a checkbox. If there is no checkbox, the node is not checkable and is excluded from built-in check functionality.
   */
  hasCheckbox = hasCheckbox;
  /**
   * A function that determines if a node is expanded.
   */
  get isExpanded() {
    return this._isExpanded || isExpanded;
  }
  set isExpanded(callback) {
    this._isExpanded = callback;
    this.expandIcons = Boolean(this._isExpanded && this._hasChildren);
  }
  /**
   * A function that determines if a node is selected ([see example](slug:selection_treeview#modifying-the-selection)).
   */
  get isSelected() {
    return this._isSelected || isSelected;
  }
  set isSelected(callback) {
    this._isSelected = callback;
    this.selectable = Boolean(this._isSelected);
  }
  /**
   * A callback that determines whether a TreeView node should be rendered as hidden. Uses the `.k-hidden` utility class. Useful for custom filtering.
   *
   */
  isVisible = isVisible;
  /**
   * Enables keyboard navigation for the TreeView.
   *
   * @default true
   */
  navigable = true;
  /**
   * A function that provides the child nodes for a given parent node ([see example](slug:databinding_treeview)).
   */
  children = () => of([]);
  /**
   * Indicates whether child nodes are fetched on expand or initally prefetched.
   *
   * @default true
   */
  loadOnDemand = true;
  /**
   * Renders the built-in input element for filtering. If `true`, emits the `filterChange` event that can be handled for [manual filtering](slug:filtering_treeview#toc-manual-filtering).
   * Built-in filtering is available with [`kendoTreeViewHierarchyBinding`](slug:api_treeview_hierarchybindingdirective) and [`kendoTreeViewFlatDataBinding`](slug:api_treeview_flatdatabindingdirective) directives.
   *
   * @default false
   */
  filterable = false;
  /**
   * Sets the initial value of the built-in filter input.
   */
  filter = "";
  /**
   * Sets the size of the component.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : "medium";
    if (this.size !== "none") {
      this.renderer.removeClass(this.element.nativeElement, getSizeClass("treeview", this.size));
    }
    this.renderer.addClass(this.element.nativeElement, getSizeClass("treeview", newSize));
    this._size = size;
  }
  get size() {
    return this._size;
  }
  get isActive() {
    return this.navigationService.isTreeViewActive;
  }
  /**
   * @hidden
   */
  get treeviewId() {
    return `treeview_${this._nextId}`;
  }
  /**
   * Indicates whether only parent nodes should be disabled or their child nodes as well.
   *
   * @default false
   */
  disableParentNodesOnly = false;
  /**
   * @hidden
   */
  loadMoreService;
  /**
   * @hidden
   */
  editService;
  checkboxes = false;
  expandIcons = false;
  selectable = false;
  touchActions = true;
  data = new BehaviorSubject([]);
  _animate = true;
  _isChecked;
  _isExpanded;
  _isSelected;
  _hasChildren;
  _nodeTemplateRef;
  _loadMoreButtonTemplateRef;
  _size = "medium";
  subscriptions = new Subscription();
  domSubscriptions = [];
  _nextId = nextId2;
  constructor(element, changeDetectorRef, expandService, navigationService, nodeChildrenService, selectionService, treeViewLookupService, ngZone, renderer, dataChangeNotification, localization) {
    this.element = element;
    this.changeDetectorRef = changeDetectorRef;
    this.expandService = expandService;
    this.navigationService = navigationService;
    this.nodeChildrenService = nodeChildrenService;
    this.selectionService = selectionService;
    this.treeViewLookupService = treeViewLookupService;
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.dataChangeNotification = dataChangeNotification;
    this.localization = localization;
    validatePackage(packageMetadata3);
    nextId2++;
  }
  ngOnChanges(changes) {
    this.navigationService.navigable = Boolean(this.navigable);
    if (anyChanged(["nodes", "children", "hasChildren", "loadOnDemand"], changes, false) && !this.loadOnDemand) {
      this.preloadChildNodes();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.domSubscriptions.forEach((subscription) => subscription());
  }
  ngOnInit() {
    this.subscriptions.add(this.nodeChildrenService.changes.subscribe((x) => this.childrenLoaded.emit(x)));
    this.subscriptions.add(this.expandService.changes.subscribe(({
      index,
      dataItem,
      expand
    }) => expand ? this.expand.emit({
      index,
      dataItem
    }) : this.collapse.emit({
      index,
      dataItem
    })));
    this.subscriptions.add(this.navigationService.checks.subscribe((x) => this.checkedChange.emit(this.treeViewLookupService.itemLookup(x))));
    this.subscriptions.add(this.selectionService.changes.subscribe((x) => {
      if (hasObservers(this.selectionChange)) {
        this.ngZone.run(() => {
          this.selectionChange.emit(x);
        });
      }
    }));
    if (this.element) {
      this.ngZone.runOutsideAngular(() => {
        this.attachDomHandlers();
      });
    }
    if (this.size) {
      this.renderer.addClass(this.element.nativeElement, getSizeClass("treeview", this.size));
    }
  }
  ngAfterViewInit() {
    if (this.searchbox) {
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "role", "searchbox");
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "aria-controls", this.treeviewId);
      this.renderer.setAttribute(this.searchbox.input.nativeElement, "aria-label", "searchbar");
    }
  }
  /**
   * Blurs the focused TreeView item.
   */
  blur() {
    if (!isDocumentAvailable()) {
      return;
    }
    const target = focusableNode(this.element);
    if (document.activeElement === target) {
      target.blur();
    }
  }
  /**
   * Focuses the first focusable item in the TreeView if no hierarchical index is provided.
   */
  focus(index) {
    const focusIndex = index || nodeIndex(this.navigationService.focusableItem);
    this.navigationService.activateIndex(focusIndex);
    const target = focusableNode(this.element);
    if (target) {
      target.focus();
    }
  }
  /**
   * Returns the `TreeItemLookup` node for the specified index.
   *
   * @param index - The index of the node.
   * @returns {TreeItemLookup} - The looked up item.
   */
  itemLookup(index) {
    return this.treeViewLookupService.itemLookup(index);
  }
  /**
   * Calls the [`children`](slug:api_treeview_treeviewcomponent#children) function for every expanded node and fetches all rendered child nodes again.
   */
  rebindChildren() {
    this.dataChangeNotification.notify();
  }
  /**
   * Triggers the `expand` event for the provided node and shows its loading indicator.
   */
  expandNode(item, index) {
    this.expandService.expand(index, item);
  }
  /**
   * Triggers the `collapse` event for the provided node.
   */
  collapseNode(item, index) {
    this.expandService.collapse(index, item);
  }
  /**
   * Gets the current page size of the data item's children collection ([see example](slug:loadmorebutton_treeview#managing-page-sizes)).
   * Pass `null` as `dataItem` to get the root collection's page size.
   *
   * @param dataItem {any} - The parent data item of the targeted collection.
   * @returns {number} - The page size of the data item's children collection.
   */
  getNodePageSize(dataItem) {
    this.verifyLoadMoreService();
    return this.loadMoreService.getGroupSize(dataItem);
  }
  /**
   * Sets the page size of the data item's children collection ([see example](slug:loadmorebutton_treeview#managing-page-sizes)).
   * Pass `null` as `dataItem` to set the root collection's page size.
   *
   * @param dataItem {any} - The parent data item of the targeted collection.
   * @param pageSize {number} - The new page size.
   */
  setNodePageSize(dataItem, pageSize) {
    this.verifyLoadMoreService();
    this.loadMoreService.setGroupSize(dataItem, pageSize);
  }
  /**
   * @hidden
   *
   * Clears the current TreeViewLookupService node map and re-registers all nodes anew.
   * Child nodes are acquired through the provided `children` callback.
   */
  preloadChildNodes() {
    this.treeViewLookupService.reset();
    this.registerLookupItems(this.nodes);
  }
  attachDomHandlers() {
    const element = this.element.nativeElement;
    this.clickHandler = this.clickHandler.bind(this);
    this.domSubscriptions.push(this.renderer.listen(element, "contextmenu", this.clickHandler), this.renderer.listen(element, "click", this.clickHandler), this.renderer.listen(element, "dblclick", this.clickHandler), this.renderer.listen(element, "focusin", this.focusHandler.bind(this)), this.renderer.listen(element, "focusout", this.blurHandler.bind(this)), this.renderer.listen(element, "keydown", this.keydownHandler.bind(this)));
  }
  focusHandler(e) {
    let focusItem;
    if (match(e.target, ".k-treeview-item")) {
      focusItem = e.target;
    } else if (!isFocusable(e.target)) {
      focusItem = closestNode(e.target);
    }
    if (focusItem) {
      const nodeIndex3 = nodeId(e.target);
      if (this.navigationService.isDisabled(nodeIndex3)) {
        return;
      }
      this.navigationService.activateIndex(nodeIndex3);
      if (!this.isActive && hasObservers(this.onFocus)) {
        this.ngZone.run(() => {
          this.onFocus.emit();
        });
      }
      this.navigationService.isTreeViewActive = true;
    }
  }
  blurHandler(e) {
    if (this.isActive && match(e.target, ".k-treeview-item") && (!e.relatedTarget || !match(e.relatedTarget, ".k-treeview-item") || !hasParent(e.relatedTarget, this.element.nativeElement))) {
      this.navigationService.deactivate();
      this.navigationService.isTreeViewActive = false;
      if (hasObservers(this.onBlur)) {
        this.ngZone.run(() => {
          this.onBlur.emit();
        });
      }
    }
  }
  clickHandler(e) {
    const target = e.target;
    if (e.type === "contextmenu" && !hasObservers(this.nodeClick) || e.type === "click" && !hasObservers(this.nodeClick) && !hasObservers(this.selectionChange) && !isLoadMoreButton(target) || e.type === "dblclick" && !hasObservers(this.nodeDblClick) || isFocusable(target) || !isContent(target) && !isLoadMoreButton(target) || !hasParent(target, this.element.nativeElement)) {
      return;
    }
    const index = nodeId(closestNode(target));
    if (!index || this.navigationService.isDisabled(index)) {
      return;
    }
    this.ngZone.run(() => {
      const lookup = this.treeViewLookupService.itemLookup(index);
      if (e.type === "click") {
        const loadMoreButton = this.navigationService.model.findNode(index).loadMoreButton;
        if (loadMoreButton) {
          this.navigationService.notifyLoadMore(index);
          return;
        } else {
          this.navigationService.selectIndex(index);
        }
      }
      const emitter = e.type === "dblclick" ? this.nodeDblClick : this.nodeClick;
      emitter.emit({
        item: lookup.item,
        originalEvent: e,
        type: e.type
      });
    });
  }
  keydownHandler(e) {
    if (this.isActive && this.navigable) {
      this.ngZone.run(() => {
        this.navigationService.move(e);
      });
    }
  }
  verifyLoadMoreService() {
    if (isDevMode() && !isPresent4(this.loadMoreService)) {
      throw new Error(`To use the TreeView paging functionality, you need to assign the \`kendoTreeViewLoadMore\` directive. See ${LOAD_MORE_DOC_LINK$1}.`);
    }
  }
  registerLookupItems(data, parentItem = null) {
    if (!isPresent4(data) || data.length === 0) {
      return;
    }
    const parentIndex = nodeIndex(parentItem);
    const treeItems = data.map((node, index) => buildTreeItem(node, index, parentIndex));
    if (isPresent4(parentItem)) {
      this.treeViewLookupService.registerChildren(parentIndex, treeItems);
    }
    treeItems.forEach((item) => {
      this.treeViewLookupService.registerItem(item, parentItem);
      if (this.hasChildren(item.dataItem)) {
        this.children(item.dataItem).subscribe((children) => this.registerLookupItems(children, item));
      }
    });
  }
  static ɵfac = function TreeViewComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ExpandStateService), ɵɵdirectiveInject(NavigationService), ɵɵdirectiveInject(NodeChildrenService), ɵɵdirectiveInject(SelectionService), ɵɵdirectiveInject(TreeViewLookupService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DataChangeNotificationService), ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TreeViewComponent,
    selectors: [["kendo-treeview"]],
    contentQueries: function TreeViewComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, LoadMoreButtonTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplateQuery = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.loadMoreButtonTemplateQuery = _t.first);
      }
    },
    viewQuery: function TreeViewComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c310, 7, ViewContainerRef);
        ɵɵviewQuery(_c410, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.assetsContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbox = _t.first);
      }
    },
    hostVars: 4,
    hostBindings: function TreeViewComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵsyntheticHostProperty("@.disabled", ctx.animate);
        ɵɵattribute("dir", ctx.direction);
        ɵɵclassProp("k-treeview", ctx.classNames);
      }
    },
    inputs: {
      filterInputPlaceholder: "filterInputPlaceholder",
      expandDisabledNodes: "expandDisabledNodes",
      animate: "animate",
      nodeTemplateRef: [0, "nodeTemplate", "nodeTemplateRef"],
      loadMoreButtonTemplateRef: [0, "loadMoreButtonTemplate", "loadMoreButtonTemplateRef"],
      trackBy: "trackBy",
      nodes: "nodes",
      textField: "textField",
      hasChildren: "hasChildren",
      isChecked: "isChecked",
      isDisabled: "isDisabled",
      hasCheckbox: "hasCheckbox",
      isExpanded: "isExpanded",
      isSelected: "isSelected",
      isVisible: "isVisible",
      navigable: "navigable",
      children: "children",
      loadOnDemand: "loadOnDemand",
      filterable: "filterable",
      filter: "filter",
      size: "size",
      disableParentNodesOnly: "disableParentNodesOnly"
    },
    outputs: {
      childrenLoaded: "childrenLoaded",
      onBlur: "blur",
      onFocus: "focus",
      expand: "expand",
      collapse: "collapse",
      nodeDragStart: "nodeDragStart",
      nodeDrag: "nodeDrag",
      filterStateChange: "filterStateChange",
      nodeDrop: "nodeDrop",
      nodeDragEnd: "nodeDragEnd",
      addItem: "addItem",
      removeItem: "removeItem",
      checkedChange: "checkedChange",
      selectionChange: "selectionChange",
      filterChange: "filterChange",
      nodeClick: "nodeClick",
      nodeDblClick: "nodeDblClick"
    },
    exportAs: ["kendoTreeView"],
    standalone: true,
    features: [ɵɵProvidersFeature(providers), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 5,
    vars: 24,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_0 = goog.getMsg("Load more...");
        i18n_0 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_TREEVIEW_FESM2022_PROGRESS_KENDO_ANGULAR_TREEVIEW_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.treeview.loadMore|The title of the Load More button:Load more...`;
      }
      return [["assetsContainer", ""], ["searchbox", ""], ["kendoTreeViewLocalizedMessages", "", "loadMore", i18n_0], ["class", "k-treeview-filter", 4, "ngIf"], ["kendoTreeViewGroup", "", "role", "tree", 1, "k-treeview-lines", 3, "size", "loadOnDemand", "checkboxes", "expandIcons", "selectable", "touchActions", "children", "hasChildren", "isChecked", "isDisabled", "hasCheckbox", "disableParentNodesOnly", "isExpanded", "isSelected", "isVisible", "nodeTemplateRef", "loadMoreButtonTemplateRef", "textField", "nodes", "loadMoreService", "trackBy", "expandDisabledNodes"], [1, "k-treeview-filter"], [3, "valueChange", "size", "value", "clearButton", "placeholder"], ["kendoTextBoxPrefixTemplate", ""], ["innerCssClass", "k-input-icon", "name", "search", 3, "svgIcon"]];
    },
    template: function TreeViewComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵelementContainer(0, 2);
        ɵɵtemplate(1, TreeViewComponent_span_1_Template, 4, 4, "span", 3);
        ɵɵelement(2, "ul", 4);
        ɵɵelementContainer(3, null, 0);
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.filterable);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("loadOnDemand", ctx.loadOnDemand)("checkboxes", ctx.checkboxes)("expandIcons", ctx.expandIcons)("selectable", ctx.selectable)("touchActions", ctx.touchActions)("children", ctx.children)("hasChildren", ctx.hasChildren)("isChecked", ctx.isChecked)("isDisabled", ctx.isDisabled)("hasCheckbox", ctx.hasCheckbox)("disableParentNodesOnly", ctx.disableParentNodesOnly)("isExpanded", ctx.isExpanded)("isSelected", ctx.isSelected)("isVisible", ctx.isVisible)("nodeTemplateRef", ctx.nodeTemplateRef == null ? null : ctx.nodeTemplateRef.templateRef)("loadMoreButtonTemplateRef", ctx.loadMoreButtonTemplateRef == null ? null : ctx.loadMoreButtonTemplateRef.templateRef)("textField", ctx.textField)("nodes", ctx.fetchNodes)("loadMoreService", ctx.loadMoreService)("trackBy", ctx.trackBy)("expandDisabledNodes", ctx.expandDisabledNodes);
        ɵɵattribute("id", ctx.treeviewId);
      }
    },
    dependencies: [LocalizedMessagesDirective, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, TreeViewGroupComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.Default,
      exportAs: "kendoTreeView",
      providers,
      selector: "kendo-treeview",
      template: `
        <ng-container kendoTreeViewLocalizedMessages
            i18n-loadMore="kendo.treeview.loadMore|The title of the Load More button"
            loadMore="Load more..."
        >
        </ng-container>
        <span
            class="k-treeview-filter"
            *ngIf="filterable"
        >
            <kendo-textbox
                #searchbox
                [size]="size"
                [value]="filter"
                [clearButton]="true"
                (valueChange)="filterChange.emit($event)"
                [placeholder]="filterInputPlaceholder"
            >
                <ng-template kendoTextBoxPrefixTemplate>
                    <kendo-icon-wrapper
                        innerCssClass="k-input-icon"
                        name="search"
                        [svgIcon]="searchIcon"
                        >
                    </kendo-icon-wrapper>
                </ng-template>
            </kendo-textbox>
        </span>
        <ul class="k-treeview-lines"
            kendoTreeViewGroup
            [attr.id]="treeviewId"
            role="tree"
            [size]="size"
            [loadOnDemand]="loadOnDemand"
            [checkboxes]="checkboxes"
            [expandIcons]="expandIcons"
            [selectable]="selectable"
            [touchActions]="touchActions"
            [children]="children"
            [hasChildren]="hasChildren"
            [isChecked]="isChecked"
            [isDisabled]="isDisabled"
            [hasCheckbox]="hasCheckbox"
            [disableParentNodesOnly]="disableParentNodesOnly"
            [isExpanded]="isExpanded"
            [isSelected]="isSelected"
            [isVisible]="isVisible"
            [nodeTemplateRef]="nodeTemplateRef?.templateRef"
            [loadMoreButtonTemplateRef]="loadMoreButtonTemplateRef?.templateRef"
            [textField]="textField"
            [nodes]="fetchNodes"
            [loadMoreService]="loadMoreService"
            [trackBy]="trackBy"
            [expandDisabledNodes]="expandDisabledNodes"
        >
        </ul>
        <ng-container #assetsContainer></ng-container>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconWrapperComponent, TreeViewGroupComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: ExpandStateService
    }, {
      type: NavigationService
    }, {
      type: NodeChildrenService
    }, {
      type: SelectionService
    }, {
      type: TreeViewLookupService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: DataChangeNotificationService
    }, {
      type: LocalizationService
    }];
  }, {
    classNames: [{
      type: HostBinding,
      args: ["class.k-treeview"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    assetsContainer: [{
      type: ViewChild,
      args: ["assetsContainer", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    searchbox: [{
      type: ViewChild,
      args: ["searchbox"]
    }],
    filterInputPlaceholder: [{
      type: Input
    }],
    expandDisabledNodes: [{
      type: Input
    }],
    animate: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["@.disabled"]
    }],
    childrenLoaded: [{
      type: Output
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    expand: [{
      type: Output
    }],
    collapse: [{
      type: Output
    }],
    nodeDragStart: [{
      type: Output
    }],
    nodeDrag: [{
      type: Output
    }],
    filterStateChange: [{
      type: Output
    }],
    nodeDrop: [{
      type: Output
    }],
    nodeDragEnd: [{
      type: Output
    }],
    addItem: [{
      type: Output
    }],
    removeItem: [{
      type: Output
    }],
    checkedChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    nodeClick: [{
      type: Output
    }],
    nodeDblClick: [{
      type: Output
    }],
    nodeTemplateQuery: [{
      type: ContentChild,
      args: [NodeTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplateRef: [{
      type: Input,
      args: ["nodeTemplate"]
    }],
    loadMoreButtonTemplateQuery: [{
      type: ContentChild,
      args: [LoadMoreButtonTemplateDirective, {
        static: false
      }]
    }],
    loadMoreButtonTemplateRef: [{
      type: Input,
      args: ["loadMoreButtonTemplate"]
    }],
    trackBy: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    isChecked: [{
      type: Input
    }],
    isDisabled: [{
      type: Input
    }],
    hasCheckbox: [{
      type: Input
    }],
    isExpanded: [{
      type: Input
    }],
    isSelected: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    navigable: [{
      type: Input
    }],
    children: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    disableParentNodesOnly: [{
      type: Input
    }]
  });
})();
var indexChecked = (keys, index) => keys.filter((k) => k === index).length > 0;
var matchKey = (index) => (k) => {
  if (index === k) {
    return true;
  }
  if (!k.split) {
    return false;
  }
  return k.split("_").reduce(({
    key,
    result
  }, part) => {
    key += part;
    if (index === key || result) {
      return {
        result: true
      };
    }
    key += "_";
    return {
      key,
      result: false
    };
  }, {
    key: "",
    result: false
  }).result;
};
var CheckDirective = class _CheckDirective {
  treeView;
  zone;
  /**
   * @hidden
   */
  set isChecked(value) {
    this.treeView.isChecked = value;
  }
  /**
   * Defines the item key stored in the `checkedKeys` collection.
   */
  checkKey;
  /**
   * Defines the collection that stores the checked keys
   * ([see example](slug:checkboxes_treeview)).
   */
  checkedKeys;
  /**
   * Defines the checkable settings
   * ([see example](slug:checkboxes_treeview#setup)).
   * If you do not provide a value, the default [`CheckableSettings`](slug:api_treeview_checkablesettings) apply.
   */
  checkable;
  /**
   * Fires when the `checkedKeys` collection updates.
   */
  checkedKeysChange = new EventEmitter();
  subscriptions = new Subscription();
  get options() {
    const defaultOptions = {
      checkChildren: true,
      checkParents: true,
      enabled: true,
      mode: "multiple",
      uncheckCollapsedChildren: false
    };
    if (!isPresent4(this.checkable) || typeof this.checkable === "string") {
      return defaultOptions;
    }
    const checkSettings = isBoolean(this.checkable) ? {
      enabled: this.checkable
    } : this.checkable;
    return Object.assign(defaultOptions, checkSettings);
  }
  checkActions = {
    "multiple": (e) => this.checkMultiple(e),
    "single": (e) => this.checkSingle(e)
  };
  /**
   * Reflects the internal `checkedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  clickSubscription;
  /**
   * Holds the last emitted `checkedKeys` collection.
   */
  lastChange;
  constructor(treeView, zone) {
    this.treeView = treeView;
    this.zone = zone;
    this.subscriptions.add(this.treeView.checkedChange.subscribe((e) => this.check(e)));
    const expandedItems = [];
    this.subscriptions.add(this.treeView.childrenLoaded.pipe(filter(() => this.options.checkChildren && this.treeView.loadOnDemand), tap((item) => expandedItems.push(item)), switchMap(() => this.zone.onStable.pipe(take(1)))).subscribe(() => this.addCheckedItemsChildren(expandedItems)));
    this.treeView.isChecked = this.isItemChecked.bind(this);
  }
  ngOnChanges(changes) {
    if (changes.checkable) {
      this.treeView.checkboxes = this.options.enabled;
      this.toggleCheckOnClick();
    }
    if (isChanged("checkedKeys", changes, false) && changes.checkedKeys.currentValue !== this.lastChange) {
      this.state = new Set(changes.checkedKeys.currentValue);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribeClick();
  }
  isItemChecked(dataItem, index) {
    if (!this.checkKey) {
      return this.isIndexChecked(index);
    }
    const hasKey = this.state.has(this.itemKey({
      dataItem,
      index
    }));
    return hasKey ? "checked" : "none";
  }
  isIndexChecked(index) {
    const checkedKeys = Array.from(this.state).filter(matchKey(index));
    if (indexChecked(checkedKeys, index)) {
      return "checked";
    }
    const {
      mode,
      checkParents
    } = this.options;
    if (mode === "multiple" && checkParents && checkedKeys.length) {
      return "indeterminate";
    }
    return "none";
  }
  itemKey(item) {
    if (!isPresent4(this.checkKey)) {
      return item.index;
    }
    if (typeof this.checkKey === "string" && isPresent4(item.dataItem)) {
      return item.dataItem[this.checkKey];
    }
    if (typeof this.checkKey === "function") {
      return this.checkKey(item);
    }
  }
  check(e) {
    const {
      enabled,
      mode
    } = this.options;
    const performSelection = this.checkActions[mode] || noop5;
    if (!enabled) {
      return;
    }
    performSelection(e);
  }
  checkSingle(node) {
    const key = this.itemKey(node.item);
    const hasKey = this.state.has(key);
    this.state.clear();
    if (!hasKey) {
      this.state.add(key);
    }
    this.notify();
  }
  checkMultiple(node) {
    this.checkNode(node);
    if (this.options.checkParents) {
      this.checkParents(node.parent);
    }
    this.notify();
  }
  toggleCheckOnClick() {
    this.unsubscribeClick();
    if (this.options.checkOnClick) {
      this.clickSubscription = this.treeView.nodeClick.subscribe((args) => {
        if (args.type === "click") {
          const lookup = this.treeView.itemLookup(args.item.index);
          this.check(lookup);
        }
      });
    }
  }
  unsubscribeClick() {
    if (this.clickSubscription) {
      this.clickSubscription.unsubscribe();
      this.clickSubscription = null;
    }
  }
  checkNode(node) {
    if (!isPresent4(node.item.dataItem) || this.treeView.isDisabled(node.item.dataItem, node.item.index) || !this.treeView.hasCheckbox(node.item.dataItem, node.item.index)) {
      return;
    }
    const currentKey = this.itemKey(node.item);
    if (!isPresent4(currentKey)) {
      return;
    }
    const pendingCheck = [currentKey];
    if (this.options.checkChildren) {
      const descendants = fetchLoadedDescendants(node, ({
        item
      }) => this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren ? this.treeView.isVisible(item.dataItem, item.index) : this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(item.dataItem, item.index));
      pendingCheck.push(...descendants.filter((item) => this.options.checkDisabledChildren || !this.treeView.isDisabled(item.item.dataItem, item.item.index) || this.treeView.hasCheckbox(item.item.dataItem, item.item.index)).map(({
        item
      }) => this.itemKey(item)));
    }
    const shouldCheck = !this.state.has(currentKey);
    pendingCheck.forEach((key) => {
      if (shouldCheck) {
        this.state.add(key);
      } else {
        this.state.delete(key);
        if (this.options.uncheckCollapsedChildren && this.options.mode === "multiple" && this.treeView.loadOnDemand) {
          if (this.checkKey && this.treeView.hasChildren(node.item.dataItem)) {
            this.uncheckChildren(node.item.dataItem, node.item.index);
            return;
          }
          const checkedKeys = Array.from(this.state).filter(matchKey(node.item.index));
          checkedKeys.forEach((key2) => this.state.delete(key2));
        }
      }
    });
  }
  uncheckChildren(dataItem, parentNodeIndex) {
    this.treeView.children(dataItem).subscribe((children) => children.forEach((item, index) => {
      const nodeIndex3 = `${parentNodeIndex}_${index}`;
      this.state.delete(this.itemKey({
        dataItem: item,
        index: nodeIndex3
      }));
      if (this.treeView.hasChildren(item)) {
        this.uncheckChildren(item, nodeIndex3);
      }
    }));
  }
  checkParents(parent) {
    if (!isPresent4(parent)) {
      return;
    }
    let currentParent = parent;
    while (currentParent) {
      const parentKey = this.itemKey(currentParent.item);
      const isDisabled2 = this.treeView.isDisabled(currentParent.item.dataItem, currentParent.item.index);
      const allChildrenSelected = currentParent.children.every((item) => this.state.has(this.itemKey(item)));
      const hasCheckbox2 = this.treeView.hasCheckbox(currentParent.item.dataItem, currentParent.item.index);
      if (hasCheckbox2 && (!isDisabled2 || this.options.checkDisabledChildren) && allChildrenSelected) {
        this.state.add(parentKey);
      } else {
        this.state.delete(parentKey);
      }
      currentParent = currentParent.parent;
    }
  }
  allChildrenSelected(children) {
    return children.every((item) => {
      const childrenSel = this.allChildrenSelected(item.children);
      return this.state.has(this.itemKey(item.item)) && childrenSel;
    });
  }
  notify() {
    this.lastChange = Array.from(this.state);
    this.checkedKeysChange.emit(this.lastChange);
  }
  addCheckedItemsChildren(lookups) {
    if (!isPresent4(lookups) || lookups.length === 0) {
      return;
    }
    const initiallyCheckedItemsCount = this.state.size;
    const disabledItems = /* @__PURE__ */ new Set();
    lookups.forEach((lookup) => {
      const itemKey = this.itemKey(lookup.item);
      if (!this.state.has(itemKey)) {
        return;
      }
      lookup.children.forEach((item) => {
        if (!this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index) && !this.treeView.isDisabled(item.dataItem, item.index) && this.treeView.hasCheckbox(lookup.item.dataItem, lookup.item.index) && this.treeView.hasCheckbox(item.dataItem, item.index) || this.treeView.disableParentNodesOnly || this.options.checkDisabledChildren) {
          this.state.add(this.itemKey(item));
        }
        if (this.treeView.disableParentNodesOnly && !this.options.checkDisabledChildren && (this.treeView.isDisabled(item.dataItem, item.index) || !this.treeView.hasCheckbox(item.dataItem, item.index))) {
          disabledItems.add(this.itemKey(item));
        }
      });
    });
    disabledItems.forEach((item) => this.state.delete(item));
    const hasNewlyCheckedItems = initiallyCheckedItemsCount !== this.state.size;
    if (hasNewlyCheckedItems) {
      this.zone.run(() => this.notify());
    }
  }
  static ɵfac = function CheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckDirective,
    selectors: [["", "kendoTreeViewCheckable", ""]],
    inputs: {
      isChecked: "isChecked",
      checkKey: [0, "checkBy", "checkKey"],
      checkedKeys: "checkedKeys",
      checkable: [0, "kendoTreeViewCheckable", "checkable"]
    },
    outputs: {
      checkedKeysChange: "checkedKeysChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewCheckable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: NgZone
    }];
  }, {
    isChecked: [{
      type: Input
    }],
    checkKey: [{
      type: Input,
      args: ["checkBy"]
    }],
    checkedKeys: [{
      type: Input
    }],
    checkable: [{
      type: Input,
      args: ["kendoTreeViewCheckable"]
    }],
    checkedKeysChange: [{
      type: Output
    }]
  });
})();
var DisableDirective = class _DisableDirective {
  treeView;
  cdr;
  /**
   * @hidden
   */
  set isDisabled(value) {
    this.treeView.isDisabled = value;
  }
  /**
   * Defines the item key that will be stored in the `disabledKeys` collection.
   */
  disableKey;
  /**
   * Defines the collection that will store the disabled keys.
   */
  disabledKeys = [];
  constructor(treeView, cdr) {
    this.treeView = treeView;
    this.cdr = cdr;
    this.treeView.isDisabled = (dataItem, index) => this.disabledKeys.indexOf(this.itemKey({
      dataItem,
      index
    })) > -1;
  }
  ngOnChanges(changes = {}) {
    const {
      disabledKeys
    } = changes;
    if (disabledKeys && !disabledKeys.firstChange) {
      this.cdr.markForCheck();
    }
  }
  itemKey(e) {
    if (!this.disableKey) {
      return e.index;
    }
    if (typeof this.disableKey === "string") {
      return e.dataItem[this.disableKey];
    }
    if (typeof this.disableKey === "function") {
      return this.disableKey(e);
    }
  }
  static ɵfac = function DisableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisableDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DisableDirective,
    selectors: [["", "kendoTreeViewDisable", ""]],
    inputs: {
      isDisabled: "isDisabled",
      disableKey: [0, "kendoTreeViewDisable", "disableKey"],
      disabledKeys: "disabledKeys"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDisable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    isDisabled: [{
      type: Input
    }],
    disableKey: [{
      type: Input,
      args: ["kendoTreeViewDisable"]
    }],
    disabledKeys: [{
      type: Input
    }]
  });
})();
var DragAndDropEditingDirective = class _DragAndDropEditingDirective {
  treeview;
  /**
   * Specifies the handlers called on drag-and-drop [`addItem`](slug:api_treeview_treeviewcomponent#additem)
   * and [`removeItem`](slug:api_treeview_treeviewcomponent#removeitem) events.
   */
  set editService(service) {
    this.treeview.editService = service;
  }
  subscriptions = new Subscription();
  constructor(treeview) {
    this.treeview = treeview;
    this.subscriptions.add(this.treeview.addItem.subscribe(this.handleAdd.bind(this)));
    this.subscriptions.add(this.treeview.removeItem.subscribe(this.handleRemove.bind(this)));
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  handleAdd(args) {
    if (!isPresent4(this.treeview.editService)) {
      throw new Error("No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).");
    }
    this.treeview.editService.add(args);
  }
  handleRemove(args) {
    if (!isPresent4(this.treeview.editService)) {
      throw new Error("No `editService` provided. Either provide your own implementation or use this directive in combination with one of the data binding directives (`kendoTreeViewHierarchyBinding` or `kendoTreeViewFlatDataBinding`).");
    }
    this.treeview.editService.remove(args);
  }
  static ɵfac = function DragAndDropEditingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropEditingDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragAndDropEditingDirective,
    selectors: [["", "kendoTreeViewDragAndDropEditing", ""]],
    inputs: {
      editService: "editService"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropEditingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragAndDropEditing]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    editService: [{
      type: Input
    }]
  });
})();
var DropAction;
(function(DropAction2) {
  DropAction2[DropAction2["Add"] = 0] = "Add";
  DropAction2[DropAction2["InsertTop"] = 1] = "InsertTop";
  DropAction2[DropAction2["InsertBottom"] = 2] = "InsertBottom";
  DropAction2[DropAction2["InsertMiddle"] = 3] = "InsertMiddle";
  DropAction2[DropAction2["Invalid"] = 4] = "Invalid";
})(DropAction || (DropAction = {}));
var DropPosition;
(function(DropPosition2) {
  DropPosition2[DropPosition2["Over"] = 0] = "Over";
  DropPosition2[DropPosition2["Before"] = 1] = "Before";
  DropPosition2[DropPosition2["After"] = 2] = "After";
})(DropPosition || (DropPosition = {}));
var ScrollDirection;
(function(ScrollDirection2) {
  ScrollDirection2[ScrollDirection2["Up"] = -1] = "Up";
  ScrollDirection2[ScrollDirection2["Down"] = 1] = "Down";
})(ScrollDirection || (ScrollDirection = {}));
var PreventableEvent2 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var TreeItemDropEvent = class extends PreventableEvent2 {
  /**
   * Reference to the TreeView from which the dragged item originates.
   */
  sourceTree;
  /**
   * Reference to the TreeView onto which the dragged item is dropped.
   */
  destinationTree;
  /**
   * Lookup information for the dragged item.
   */
  sourceItem;
  /**
   * Lookup information for the item onto which the dragged item is dropped.
   */
  destinationItem;
  /**
   * Represents the drop position relative to the target item.
   */
  dropPosition;
  /**
   * The original pointer event containing details about the pointer position.
   */
  originalEvent;
  /**
   * @hidden
   */
  isValid = true;
  /**
   * @hidden
   */
  constructor(initializer, originalEvent) {
    super();
    Object.assign(this, initializer);
    this.originalEvent = originalEvent;
  }
  /**
   * Sets whether the drop action is valid.
   * If set to `false`, the `addItem` and `removeItem` events will not be fired and the drag clue
   * will animate back to the source item to indicate the action is invalid.
   */
  setValid(isValid) {
    this.isValid = isValid;
  }
};
var TreeItemDragStartEvent = class extends PreventableEvent2 {
  /**
   * Lookup information for the dragged item.
   */
  sourceItem;
  /**
   * The original pointer event containing details about the pointer position.
   */
  originalEvent;
  /**
   * @hidden
   */
  constructor(initializer) {
    super();
    Object.assign(this, initializer);
  }
};
var DragClueComponent = class _DragClueComponent {
  cdr;
  hostClasses = true;
  /**
   * The text value of the dragged TreeView item.
   */
  text;
  /**
   * The attempted operation according to the current drop target.
   */
  action;
  /**
   * The look-up info for the currently dragged item.
   */
  sourceItem;
  /**
   * The look-up info for the destination item (if hovering a valid drop target).
   */
  destinationItem;
  /**
   * Defines the drag clue content template.
   */
  template;
  posistionStyle = "fixed";
  get statusIconClass() {
    switch (this.action) {
      case DropAction.Add:
        return "plus";
      case DropAction.InsertTop:
        return "insert-top";
      case DropAction.InsertBottom:
        return "insert-bottom";
      case DropAction.InsertMiddle:
        return "insert-middle";
      case DropAction.Invalid:
      default:
        return "cancel";
    }
  }
  get statusSVGIcon() {
    switch (this.action) {
      case DropAction.Add:
        return plusIcon;
      case DropAction.InsertTop:
        return insertTopIcon;
      case DropAction.InsertBottom:
        return insertBottomIcon;
      case DropAction.InsertMiddle:
        return insertMiddleIcon;
      case DropAction.Invalid:
      default:
        return cancelIcon;
    }
  }
  constructor(cdr) {
    this.cdr = cdr;
  }
  // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
  detectChanges() {
    this.cdr.detectChanges();
  }
  static ɵfac = function DragClueComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DragClueComponent,
    selectors: [["kendo-treeview-drag-clue"]],
    hostVars: 6,
    hostBindings: function DragClueComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("position", ctx.posistionStyle);
        ɵɵclassProp("k-header", ctx.hostClasses)("k-drag-clue", ctx.hostClasses);
      }
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 2,
    vars: 2,
    consts: [[4, "ngIf"], ["innerCssClass", "k-drag-status", 3, "name", "svgIcon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function DragClueComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, DragClueComponent_ng_container_0_Template, 4, 3, "ng-container", 0)(1, DragClueComponent_1_Template, 1, 7, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.template);
      }
    },
    dependencies: [NgIf, IconWrapperComponent, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-treeview-drag-clue",
      template: `
        <ng-container *ngIf="!template">
            <kendo-icon-wrapper
                innerCssClass="k-drag-status"
                [name]="statusIconClass"
                [svgIcon]="statusSVGIcon"
                >
            </kendo-icon-wrapper>
            <span>{{text}}</span>
        </ng-container>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                text: text,
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        </ng-template>
    `,
      standalone: true,
      imports: [NgIf, IconWrapperComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-header"]
    }, {
      type: HostBinding,
      args: ["class.k-drag-clue"]
    }],
    posistionStyle: [{
      type: HostBinding,
      args: ["style.position"]
    }]
  });
})();
var DragAndDropAssetService = class _DragAndDropAssetService {
  get componentRef() {
    if (!isPresent4(this._componentRef)) {
      throw new Error("The `initalize` method must be called before calling other service methods.");
    }
    return this._componentRef;
  }
  set componentRef(componentRef) {
    this._componentRef = componentRef;
  }
  get element() {
    return this.componentRef.location.nativeElement;
  }
  _componentRef;
  ngOnDestroy() {
    if (!isPresent4(this._componentRef)) {
      return;
    }
    this.element.parentElement.removeChild(this.element);
    this.componentRef.destroy();
    this.componentRef = null;
  }
  show() {
    this.element.style.display = "";
  }
  hide() {
    this.element.style.display = "none";
  }
  move(left, top, offset = 0) {
    this.element.style.left = `${left + offset}px`;
    this.element.style.top = `${top + offset}px`;
  }
  static ɵfac = function DragAndDropAssetService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropAssetService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragAndDropAssetService,
    factory: _DragAndDropAssetService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropAssetService, [{
    type: Injectable
  }], null, null);
})();
var hasRelativeStackingContext = memoize(() => {
  if (!(isDocumentAvailable() && isPresent4(document.body))) {
    return false;
  }
  const top = 10;
  const parent = document.createElement("div");
  parent.style.transform = "matrix(10, 0, 0, 10, 0, 0)";
  const innerDiv = document.createElement("div");
  innerDiv.innerText = "child";
  innerDiv.style.position = "fixed";
  innerDiv.style.top = `${top}px`;
  parent.appendChild(innerDiv);
  document.body.appendChild(parent);
  const isDifferent = parent.children[0].getBoundingClientRect().top !== top;
  document.body.removeChild(parent);
  return isDifferent;
});
function memoize(fn) {
  let result;
  let called = false;
  return (...args) => {
    if (called) {
      return result;
    }
    result = fn(...args);
    called = true;
    return result;
  };
}
var getContainerOffset = (element) => {
  if (!(element && hasRelativeStackingContext())) {
    return {
      left: 0,
      top: 0
    };
  }
  let offsetParent = element.parentElement;
  while (offsetParent) {
    if (window.getComputedStyle(offsetParent).transform !== "none") {
      break;
    }
    offsetParent = offsetParent.parentElement;
  }
  if (offsetParent) {
    const rect = offsetParent.getBoundingClientRect();
    return {
      left: rect.left - offsetParent.scrollLeft,
      top: rect.top - offsetParent.scrollTop
    };
  }
  return {
    left: 0,
    top: 0
  };
};
var getDropAction = (dropPosition, dropTarget) => {
  if (!(isPresent4(dropPosition) && isPresent4(dropTarget))) {
    return DropAction.Invalid;
  }
  switch (dropPosition) {
    case DropPosition.Over:
      return DropAction.Add;
    case DropPosition.Before:
      return isPresent4(closestNode(dropTarget).previousElementSibling) ? DropAction.InsertMiddle : DropAction.InsertTop;
    case DropPosition.After:
      return isPresent4(closestNode(dropTarget).nextElementSibling) ? DropAction.InsertMiddle : DropAction.InsertBottom;
    default:
      return DropAction.Invalid;
  }
};
var getDropPosition = (draggedItem, target, clientY, targetTreeView, containerOffset) => {
  if (!(isPresent4(draggedItem) && isPresent4(target) && isPresent4(targetTreeView) && isPresent4(containerOffset))) {
    return;
  }
  const item = closestWithMatch(target, ".k-treeview-top, .k-treeview-mid, .k-treeview-bot");
  if (!isPresent4(item)) {
    return;
  }
  const content = getContentElement(item);
  const targetChildOfDraggedItem = hasParent(item, closestNode(draggedItem));
  if (!isPresent4(content) || content === draggedItem || targetChildOfDraggedItem) {
    return;
  }
  const itemViewPortCoords = content.getBoundingClientRect();
  const itemDivisionHeight = itemViewPortCoords.height / (isContent(target) ? 4 : 2);
  const pointerPosition = clientY - containerOffset.top;
  const itemTop = itemViewPortCoords.top - containerOffset.top;
  if (pointerPosition < itemTop + itemDivisionHeight) {
    return DropPosition.Before;
  }
  if (pointerPosition >= itemTop + itemViewPortCoords.height - itemDivisionHeight) {
    return DropPosition.After;
  }
  return DropPosition.Over;
};
var treeItemFromEventTarget = (treeView, dropTarget) => {
  if (!(isPresent4(treeView) && isPresent4(dropTarget))) {
    return null;
  }
  const node = closestNode(dropTarget);
  const index = nodeId(node);
  const lookup = treeView.itemLookup(index);
  if (!(isPresent4(lookup) && isPresent4(lookup.item.dataItem))) {
    return null;
  }
  return lookup;
};
var collapseEmptyParent = (parent, parentNodes, treeview) => {
  if (isPresent4(parent) && parentNodes.length === 0 && treeview.isExpanded(parent.item.dataItem, parent.item.index)) {
    treeview.collapseNode(parent.item.dataItem, parent.item.index);
  }
};
var expandDropTarget = (dropTarget, treeView) => {
  if (!treeView.isExpanded(dropTarget.item.dataItem, dropTarget.item.index)) {
    treeView.expandNode(dropTarget.item.dataItem, dropTarget.item.index);
  }
};
var getDropTarget = (event) => {
  if (!(isDocumentAvailable() && isPresent4(document.elementFromPoint))) {
    return event.target;
  }
  return document.elementFromPoint(event.clientX, event.clientY);
};
var updateMovedItemIndex = (newIndex, originalIndex) => {
  const movedItemNewIndexParts = newIndex.split("_");
  const originalItemIndexParts = originalIndex.split("_");
  if (movedItemNewIndexParts.length < originalItemIndexParts.length) {
    return newIndex;
  }
  const originalItemParentPathLength = originalItemIndexParts.length - 1;
  const originalItemParentPath = originalItemIndexParts.slice(0, originalItemParentPathLength).join("_");
  const movedItemParentPath = movedItemNewIndexParts.slice(0, originalItemParentPathLength).join("_");
  const originalItemIndexLevel = originalItemIndexParts.length - 1;
  const originalItemLevelIndex = Number(originalItemIndexParts[originalItemIndexLevel]);
  const movedItemLevelIndex = Number(movedItemNewIndexParts[originalItemIndexLevel]);
  if (originalItemParentPath === movedItemParentPath && movedItemLevelIndex > originalItemLevelIndex) {
    movedItemNewIndexParts[originalItemIndexLevel] = String(movedItemLevelIndex - 1);
    return movedItemNewIndexParts.join("_");
  }
  return newIndex;
};
var SCROLLBAR_REG_EXP = new RegExp("(auto|scroll)");
var getScrollableContainer = (node) => {
  while (isPresent4(node) && node.nodeName !== "HTML") {
    const hasOverflow = node.scrollHeight > node.clientHeight;
    const hasScrollbar = SCROLLBAR_REG_EXP.test(getComputedStyle(node).overflowY);
    if (hasOverflow && hasScrollbar) {
      return node;
    }
    node = node.parentNode;
  }
  return node;
};
var isTopReached = (element) => Math.floor(element.scrollTop) <= 0;
var isBottomReached = (element) => Math.ceil(element.scrollTop) >= element.scrollHeight - element.clientHeight;
var scrollElementBy = (element, step, direction) => {
  if (!(isPresent4(element) && isDocumentAvailable())) {
    return;
  }
  const initialScrollTop = element.scrollTop;
  let currentStep = step;
  let iterations = 0;
  while (initialScrollTop === element.scrollTop && !(direction === ScrollDirection.Up && isTopReached(element)) && !(direction === ScrollDirection.Down && isBottomReached(element)) && iterations < 20) {
    element.scrollTop += currentStep * direction;
    currentStep += 1;
    iterations += 1;
  }
};
var CLUE_OFFSET = 10;
var RETURN_ANIMATION_DURATION = 200;
var DragClueService = class _DragClueService extends DragAndDropAssetService {
  returnAnimation;
  scrollInterval;
  constructor() {
    super();
  }
  initialize(container, template) {
    if (isPresent4(this._componentRef)) {
      this.ngOnDestroy();
    }
    this.componentRef = container.createComponent(DragClueComponent);
    this.hide();
    this.componentRef.instance.template = template;
    this.componentRef.changeDetectorRef.detectChanges();
  }
  ngOnDestroy() {
    this.cancelReturnAnimation();
    this.cancelScroll();
    super.ngOnDestroy();
  }
  move(left, top) {
    super.move(left, top, CLUE_OFFSET);
  }
  animateDragClueToElementPosition(target) {
    if (!(isPresent4(target) && isPresent4(this.element.animate))) {
      this.hide();
      return;
    }
    const targetElementViewPortCoords = target.getBoundingClientRect();
    const clueElementViewPortCoords = this.element.getBoundingClientRect();
    this.returnAnimation = this.element.animate([{
      transform: "translate(0, 0)"
    }, {
      transform: `translate(${targetElementViewPortCoords.left - clueElementViewPortCoords.left}px, ${targetElementViewPortCoords.top - clueElementViewPortCoords.top}px)`
    }], RETURN_ANIMATION_DURATION);
    this.returnAnimation.onfinish = () => this.hide();
  }
  cancelReturnAnimation() {
    if (!isPresent4(this.returnAnimation)) {
      return;
    }
    this.returnAnimation.cancel();
    this.returnAnimation = null;
  }
  updateDragClueData(action, sourceItem, destinationItem) {
    const dragClue = this.componentRef.instance;
    if (action === dragClue.action && dataItemsEqual(sourceItem, dragClue.sourceItem) && dataItemsEqual(destinationItem, dragClue.destinationItem)) {
      return;
    }
    dragClue.action = action;
    dragClue.sourceItem = sourceItem;
    dragClue.destinationItem = destinationItem;
    dragClue.detectChanges();
  }
  updateText(text) {
    if (text === this.componentRef.instance.text) {
      return;
    }
    this.componentRef.instance.text = text;
    this.componentRef.instance.detectChanges();
  }
  /**
   * Triggers the first scrollable parent to scroll upwards or downwards.
   * Uses setInterval, so should be called outside the angular zone.
   */
  scrollIntoView({
    step,
    interval: interval2
  }) {
    this.cancelScroll();
    const scrollableContainer = getScrollableContainer(this.element);
    if (!isPresent4(scrollableContainer)) {
      return;
    }
    const containerRect = scrollableContainer.getBoundingClientRect();
    const clueRect = this.element.getBoundingClientRect();
    const firstVisibleClientTopPart = Math.max(containerRect.top, 0);
    const topLimit = firstVisibleClientTopPart + clueRect.height;
    const bottomLimit = firstVisibleClientTopPart + Math.min(containerRect.bottom, scrollableContainer.clientHeight);
    if (clueRect.top < topLimit) {
      this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Up), interval2);
    } else if (clueRect.bottom > bottomLimit) {
      this.scrollInterval = setInterval(() => scrollElementBy(scrollableContainer, step, ScrollDirection.Down), interval2);
    }
  }
  /**
   * Cancels out the on-going scroll animation, if present.
   */
  cancelScroll() {
    if (isPresent4(this.scrollInterval)) {
      clearInterval(this.scrollInterval);
      this.scrollInterval = null;
    }
  }
  static ɵfac = function DragClueService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DragClueService,
    factory: _DragClueService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DropHintComponent = class _DropHintComponent {
  changeDetectorRef;
  hostClass = true;
  /**
   * Defines the drag hint content template.
   */
  template;
  position = "fixed";
  pointerEvents = "none";
  /**
   * The attempted operation according to the current drop target.
   */
  action;
  /**
   * The look-up info for the currently dragged item.
   */
  sourceItem;
  /**
   * The look-up info for the destination item.
   */
  destinationItem;
  constructor(changeDetectorRef) {
    this.changeDetectorRef = changeDetectorRef;
  }
  // exposed as a public method that can be called from outside as the component uses `OnPush` strategy
  detectChanges() {
    this.changeDetectorRef.detectChanges();
  }
  static ɵfac = function DropHintComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintComponent)(ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropHintComponent,
    selectors: [["kendo-treeview-drop-hint"]],
    hostVars: 6,
    hostBindings: function DropHintComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("position", ctx.position)("pointer-events", ctx.pointerEvents);
        ɵɵclassProp("k-drop-hint-container", ctx.hostClass);
      }
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 2,
    vars: 2,
    consts: [["class", "k-drop-hint k-drop-hint-h", 4, "ngIf"], [4, "ngIf"], [1, "k-drop-hint", "k-drop-hint-h"], [1, "k-drop-hint-start"], [1, "k-drop-hint-line"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function DropHintComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵtemplate(0, DropHintComponent_div_0_Template, 3, 0, "div", 0)(1, DropHintComponent_1_Template, 1, 6, null, 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.template);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "kendo-treeview-drop-hint",
      template: `
        <div
            *ngIf="!template"
            class="k-drop-hint k-drop-hint-h"
        >
            <div class='k-drop-hint-start'></div>
            <div class='k-drop-hint-line'></div>
        </div>

        <ng-template
            *ngIf="template"
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="{
                action: action,
                sourceItem: sourceItem,
                destinationItem: destinationItem
            }"
        >
        <ng-template>
    `,
      standalone: true,
      imports: [NgIf, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }];
  }, {
    hostClass: [{
      type: HostBinding,
      args: ["class.k-drop-hint-container"]
    }],
    position: [{
      type: HostBinding,
      args: ["style.position"]
    }],
    pointerEvents: [{
      type: HostBinding,
      args: ["style.pointer-events"]
    }]
  });
})();
var DropHintService = class _DropHintService extends DragAndDropAssetService {
  constructor() {
    super();
  }
  initialize(container, template) {
    if (isPresent4(this._componentRef)) {
      this.ngOnDestroy();
    }
    this.componentRef = container.createComponent(DropHintComponent);
    this.hide();
    this.componentRef.instance.template = template;
    this.componentRef.changeDetectorRef.detectChanges();
  }
  updateDropHintData(action, sourceItem, destinationItem) {
    const dropHint = this.componentRef.instance;
    if (action === dropHint.action && dataItemsEqual(sourceItem, dropHint.sourceItem) && dataItemsEqual(destinationItem, dropHint.destinationItem)) {
      return;
    }
    dropHint.action = action;
    dropHint.sourceItem = sourceItem;
    dropHint.destinationItem = destinationItem;
    dropHint.detectChanges();
  }
  static ɵfac = function DropHintService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DropHintService,
    factory: _DropHintService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DragClueTemplateDirective = class _DragClueTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DragClueTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragClueTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragClueTemplateDirective,
    selectors: [["", "kendoTreeViewDragClueTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragClueTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragClueTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DropHintTemplateDirective = class _DropHintTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function DropHintTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropHintTemplateDirective)(ɵɵdirectiveInject(TemplateRef, 8));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropHintTemplateDirective,
    selectors: [["", "kendoTreeViewDropHintTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropHintTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDropHintTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var DEFAULT_SCROLL_SETTINGS = {
  enabled: true,
  step: 1,
  interval: 1
};
var DragAndDropDirective = class _DragAndDropDirective {
  element;
  zone;
  treeview;
  dragClueService;
  dropHintService;
  /**
   * Specifies whether the `removeItem` event fires after the user drops an item while pressing the `ctrl` key.
   * If enabled, the `removeItem` event does not fire on the source TreeView
   * ([see example](slug:draganddrop_treeview#multiple-treeviews)).
   *
   * @default false
   */
  allowCopy = false;
  /**
   * Specifies the `TreeViewComponent` instances into which the user can drop dragged items from the current `TreeViewComponent`
   * ([see example](slug:draganddrop_treeview#multiple-treeviews)).
   */
  dropZoneTreeViews = [];
  /**
   * Specifies the distance in pixels from the initial item `pointerdown` event before dragging starts.
   * The `nodeDragStart` and all subsequent TreeView drag events do not fire until dragging begins.
   *
   * @default 5
   */
  startDragAfter = 5;
  /**
   * Controls the auto-scrolling behavior during drag-and-drop ([see example](slug:draganddrop_treeview#auto-scrolling)).
   * Enabled by default. To turn off auto-scrolling, set this property to `false`.
   *
   * By default, scrolling occurs by 1 pixel every 1 millisecond when the dragged item reaches the top or bottom of the scrollable container.
   * You can override the `step` and `interval` by providing a `DragAndDropScrollSettings` object.
   *
   * @default true
   */
  autoScroll = true;
  /**
   * @hidden
   */
  dragClueTemplate;
  /**
   * @hidden
   */
  dropHintTemplate;
  /**
   * @hidden
   */
  userSelectStyle = "none";
  draggable;
  draggedItem;
  /**
   * The pointer event of the last successful item pointerdown event (the draggable `press` event).
   * Used for determining whether the `startDragAfter` distance is covered and for the `nodeDragStart` event args.
   * Used also as a flag for whether a drag attempt is pending. Should be set to `null` once the dragging begins.
   */
  pendingDragStartEvent;
  get scrollSettings() {
    const userProvidedSettings = typeof this.autoScroll === "boolean" ? {
      enabled: this.autoScroll
    } : this.autoScroll;
    return Object.assign({}, DEFAULT_SCROLL_SETTINGS, userProvidedSettings);
  }
  /**
   * Describes the offset of the parent element if the latter has the `transform` CSS prop applied.
   * Transformed parents create new stacking context and the fixed children must be position based on the transformed parent.
   * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context
   */
  containerOffset = {
    top: 0,
    left: 0
  };
  constructor(element, zone, treeview, dragClueService, dropHintService) {
    this.element = element;
    this.zone = zone;
    this.treeview = treeview;
    this.dragClueService = dragClueService;
    this.dropHintService = dropHintService;
    this.treeview.touchActions = false;
  }
  ngAfterContentInit() {
    this.initalizeDraggable();
    this.dragClueService.initialize(this.treeview.assetsContainer, this.dragClueTemplate && this.dragClueTemplate.templateRef);
    this.dropHintService.initialize(this.treeview.assetsContainer, this.dropHintTemplate && this.dropHintTemplate.templateRef);
  }
  ngOnDestroy() {
    this.draggable.destroy();
  }
  /**
   * @hidden
   */
  handlePress({
    originalEvent
  }) {
    if (!isContent(originalEvent.target)) {
      return;
    }
    this.draggedItem = closestWithMatch(originalEvent.target, ".k-treeview-leaf");
    this.pendingDragStartEvent = originalEvent;
  }
  /**
   * @hidden
   */
  handleDrag({
    originalEvent,
    clientX,
    clientY
  }) {
    if (this.shouldInitiateDragStart({
      clientX,
      clientY
    })) {
      this.initiateDragStart();
    }
    if (!isPresent4(this.draggedItem) || isPresent4(this.pendingDragStartEvent)) {
      return;
    }
    const dropTarget = getDropTarget(originalEvent);
    if (hasObservers(this.treeview.nodeDrag)) {
      this.zone.run(() => this.notifyDrag(originalEvent, dropTarget));
    }
    const targetTreeView = this.getTargetTreeView(dropTarget);
    const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, targetTreeView, this.containerOffset);
    const dropHintAnchor = closestWithMatch(dropTarget, ".k-treeview-top, .k-treeview-mid, .k-treeview-bot");
    const dropAction = getDropAction(dropPosition, dropTarget);
    const sourceItem = treeItemFromEventTarget(this.treeview, this.draggedItem);
    const destinationItem = treeItemFromEventTarget(targetTreeView, dropTarget);
    this.updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem);
    this.updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem);
    if (this.scrollSettings.enabled) {
      this.dragClueService.scrollIntoView(this.scrollSettings);
    }
  }
  /**
   * @hidden
   */
  handleRelease({
    originalEvent,
    clientY
  }) {
    if (this.scrollSettings.enabled) {
      this.dragClueService.cancelScroll();
    }
    if (!isPresent4(this.draggedItem) || isPresent4(this.pendingDragStartEvent)) {
      this.pendingDragStartEvent = null;
      this.draggedItem = null;
      return;
    }
    const dropTarget = getDropTarget(originalEvent);
    const sourceTree = this.treeview;
    const destinationTree = this.getTargetTreeView(dropTarget);
    const dropPosition = getDropPosition(this.draggedItem, dropTarget, clientY, this.getTargetTreeView(dropTarget), this.containerOffset);
    const sourceItem = treeItemFromEventTarget(sourceTree, this.draggedItem);
    const destinationItem = treeItemFromEventTarget(destinationTree, dropTarget);
    if (isPresent4(destinationItem) && isPresent4(dropPosition)) {
      this.zone.run(() => this.notifyDrop({
        sourceItem,
        destinationItem,
        dropPosition,
        sourceTree,
        destinationTree
      }, originalEvent));
    } else {
      this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
    }
    if (hasObservers(this.treeview.nodeDragEnd)) {
      this.zone.run(() => this.notifyDragEnd({
        sourceItem,
        destinationItem,
        originalEvent
      }));
    }
    this.dropHintService.hide();
    this.draggedItem = null;
  }
  updateDropHintState(dropPosition, dropHintAnchor, dropAction, sourceItem, destinationItem) {
    if (!isPresent4(dropHintAnchor) || dropPosition === DropPosition.Over || !isPresent4(dropPosition)) {
      this.dropHintService.hide();
      return;
    }
    const anchorViewPortCoords = dropHintAnchor.getBoundingClientRect();
    const insertBefore = dropPosition === DropPosition.Before;
    const top = insertBefore ? anchorViewPortCoords.top : anchorViewPortCoords.top + anchorViewPortCoords.height;
    this.dropHintService.updateDropHintData(dropAction, sourceItem, destinationItem);
    this.dropHintService.move(anchorViewPortCoords.left - this.containerOffset.left, top - this.containerOffset.top);
    this.dropHintService.show();
  }
  updateDragClueState(dropAction, clientX, clientY, sourceItem, destinationItem) {
    this.dragClueService.move(clientX - this.containerOffset.left, clientY - this.containerOffset.top);
    this.dragClueService.updateDragClueData(dropAction, sourceItem, destinationItem);
    this.dragClueService.show();
  }
  initalizeDraggable() {
    this.draggable = new Draggable({
      press: this.handlePress.bind(this),
      drag: this.handleDrag.bind(this),
      release: this.handleRelease.bind(this)
    });
    this.zone.runOutsideAngular(() => this.draggable.bindTo(this.element.nativeElement));
  }
  notifyDragStart(originalEvent, dropTarget) {
    const sourceItem = treeItemFromEventTarget(this.treeview, dropTarget);
    const event = new TreeItemDragStartEvent({
      sourceItem,
      originalEvent
    });
    this.treeview.nodeDragStart.emit(event);
    return event;
  }
  notifyDrag(originalEvent, dropTarget) {
    const dragEvent = {
      sourceItem: treeItemFromEventTarget(this.treeview, this.draggedItem),
      destinationItem: treeItemFromEventTarget(this.getTargetTreeView(dropTarget), dropTarget),
      originalEvent
    };
    this.treeview.nodeDrag.emit(dragEvent);
  }
  notifyDrop(args, originalEvent) {
    const event = new TreeItemDropEvent(args, originalEvent);
    args.destinationTree.nodeDrop.emit(event);
    this.disableAnimationsForNextTick(args.destinationTree);
    if (args.sourceTree !== args.destinationTree) {
      this.disableAnimationsForNextTick(args.sourceTree);
    }
    if (!event.isDefaultPrevented() && event.isValid) {
      this.dragClueService.hide();
      args.destinationTree.addItem.emit(args);
      if (!(originalEvent.ctrlKey && this.allowCopy)) {
        args.sourceTree.removeItem.emit(args);
      }
    } else if (event.isDefaultPrevented()) {
      this.dragClueService.hide();
    } else if (!event.isValid) {
      this.dragClueService.animateDragClueToElementPosition(this.draggedItem);
    }
  }
  notifyDragEnd(dragEndEvent) {
    this.treeview.nodeDragEnd.emit(dragEndEvent);
  }
  getTargetTreeView(dropTarget) {
    const treeViewTagName = this.treeview.element.nativeElement.tagName;
    const targetTreeView = closestWithMatch(dropTarget, treeViewTagName);
    return [this.treeview, ...this.dropZoneTreeViews].find((treeView) => isPresent4(treeView) && treeView.element.nativeElement === targetTreeView);
  }
  disableAnimationsForNextTick(treeView) {
    if (treeView.animate) {
      return;
    }
    treeView.animate = false;
    this.zone.runOutsideAngular(() => setTimeout(() => treeView.animate = true));
  }
  shouldInitiateDragStart(currentPointerCoords) {
    if (!isPresent4(this.pendingDragStartEvent)) {
      return false;
    }
    const distanceFromPointerDown = Math.sqrt(Math.pow(this.pendingDragStartEvent.clientX - currentPointerCoords.clientX, 2) + Math.pow(this.pendingDragStartEvent.clientY - currentPointerCoords.clientY, 2));
    return distanceFromPointerDown >= this.startDragAfter;
  }
  initiateDragStart() {
    if (hasObservers(this.treeview.nodeDragStart)) {
      const dragStartEvent = this.zone.run(() => this.notifyDragStart(this.pendingDragStartEvent, getDropTarget(this.pendingDragStartEvent)));
      if (dragStartEvent.isDefaultPrevented()) {
        this.pendingDragStartEvent = null;
        this.draggedItem = null;
        return;
      }
    }
    this.dragClueService.cancelReturnAnimation();
    this.dragClueService.updateText(this.draggedItem.innerText);
    this.containerOffset = getContainerOffset(this.draggedItem);
    this.pendingDragStartEvent = null;
  }
  static ɵfac = function DragAndDropDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DragAndDropDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(DragClueService), ɵɵdirectiveInject(DropHintService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DragAndDropDirective,
    selectors: [["", "kendoTreeViewDragAndDrop", ""]],
    contentQueries: function DragAndDropDirective_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, DragClueTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, DropHintTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dragClueTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dropHintTemplate = _t.first);
      }
    },
    hostVars: 8,
    hostBindings: function DragAndDropDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵstyleProp("user-select", ctx.userSelectStyle)("-ms-user-select", ctx.userSelectStyle)("-moz-user-select", ctx.userSelectStyle)("-webkit-user-select", ctx.userSelectStyle);
      }
    },
    inputs: {
      allowCopy: "allowCopy",
      dropZoneTreeViews: "dropZoneTreeViews",
      startDragAfter: "startDragAfter",
      autoScroll: "autoScroll"
    },
    standalone: true,
    features: [ɵɵProvidersFeature([DragClueService, DropHintService])]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragAndDropDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewDragAndDrop]",
      providers: [DragClueService, DropHintService],
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: TreeViewComponent
    }, {
      type: DragClueService
    }, {
      type: DropHintService
    }];
  }, {
    allowCopy: [{
      type: Input
    }],
    dropZoneTreeViews: [{
      type: Input
    }],
    startDragAfter: [{
      type: Input
    }],
    autoScroll: [{
      type: Input
    }],
    dragClueTemplate: [{
      type: ContentChild,
      args: [DragClueTemplateDirective, {
        static: false
      }]
    }],
    dropHintTemplate: [{
      type: ContentChild,
      args: [DropHintTemplateDirective, {
        static: false
      }]
    }],
    userSelectStyle: [{
      type: HostBinding,
      args: ["style.user-select"]
    }, {
      type: HostBinding,
      args: ["style.-ms-user-select"]
    }, {
      type: HostBinding,
      args: ["style.-moz-user-select"]
    }, {
      type: HostBinding,
      args: ["style.-webkit-user-select"]
    }]
  });
})();
var DEFAULT_FILTER_EXPAND_SETTINGS = {
  maxAutoExpandResults: -1,
  expandMatches: false,
  expandedOnClear: "none"
};
var ExpandDirective = class _ExpandDirective {
  component;
  /**
   * @hidden
   */
  set isExpanded(value) {
    this.component.isExpanded = value;
  }
  /**
   * Defines the item key stored in the `expandedKeys` collection.
   */
  expandKey;
  /**
   * Specifies whether to auto-expand the nodes leading from the root node to each filter result.
   * To fine-tune this behavior, pass a [`FilterExpandSettings`](slug:api_treeview_filterexpandsettings) object to this input.
   * @default false
   */
  expandOnFilter = false;
  get filterExpandSettings() {
    const settings = isBoolean(this.expandOnFilter) ? {
      enabled: this.expandOnFilter
    } : __spreadProps(__spreadValues({}, this.expandOnFilter), {
      enabled: true
    });
    return Object.assign({}, DEFAULT_FILTER_EXPAND_SETTINGS, settings);
  }
  /**
   * Fires when the `expandedKeys` collection updates.
   */
  expandedKeysChange = new EventEmitter();
  /**
   * Defines the collection that stores the expanded keys.
   */
  expandedKeys;
  subscriptions = new Subscription();
  /**
   * Reflects the internal `expandedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  originalExpandedKeys = /* @__PURE__ */ new Set();
  isFiltered = false;
  /**
   * Holds the last emitted `expandedKeys` collection.
   */
  lastChange;
  constructor(component) {
    this.component = component;
    this.subscriptions.add(merge(this.component.expand.pipe(map((e) => __spreadValues({
      expand: true
    }, e))), this.component.collapse.pipe(map((e) => __spreadValues({
      expand: false
    }, e)))).subscribe(this.toggleExpand.bind(this)));
    if (this.component.filterStateChange) {
      this.subscriptions.add(this.component.filterStateChange.subscribe(this.handleAutoExpand.bind(this)));
    }
    this.component.isExpanded = (dataItem, index) => this.state.has(this.itemKey({
      dataItem,
      index
    }));
  }
  ngOnChanges(changes) {
    if (isChanged("expandedKeys", changes, false) && changes["expandedKeys"].currentValue !== this.lastChange) {
      this.state = new Set(changes["expandedKeys"].currentValue);
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  /**
   * @hidden
   */
  itemKey(e) {
    if (this.expandKey) {
      if (typeof this.expandKey === "string") {
        return e.dataItem[this.expandKey];
      }
      if (typeof this.expandKey === "function") {
        return this.expandKey(e);
      }
    }
    return e.index;
  }
  toggleExpand({
    index,
    dataItem,
    expand
  }) {
    const key = this.itemKey({
      index,
      dataItem
    });
    const isExpanded2 = this.state.has(key);
    let notify = false;
    if (isExpanded2 && !expand) {
      this.state.delete(key);
      notify = true;
    } else if (!isExpanded2 && expand) {
      this.state.add(key);
      notify = true;
    }
    if (notify) {
      this.notify();
    }
  }
  handleAutoExpand({
    nodes,
    matchCount,
    term
  }) {
    if (!this.filterExpandSettings.enabled) {
      return;
    }
    const {
      maxAutoExpandResults,
      expandMatches: autoExpandMatches,
      expandedOnClear
    } = this.filterExpandSettings;
    if (!this.isFiltered) {
      this.originalExpandedKeys = new Set(this.state);
    }
    const exitingFilteredState = this.isFiltered && !term;
    const maxExceeded = maxAutoExpandResults !== -1 && matchCount > maxAutoExpandResults;
    const exitAutoExpandedState = exitingFilteredState || maxExceeded;
    if (exitAutoExpandedState) {
      switch (expandedOnClear) {
        case "initial": {
          if (!sameValues(this.state, this.originalExpandedKeys)) {
            this.state = this.originalExpandedKeys;
            this.notify();
          }
          break;
        }
        case "all": {
          this.state = new Set(nodes.reduce((acc, rootNode) => {
            this.getEveryExpandKey(acc, rootNode);
            return acc;
          }, []));
          this.notify();
          break;
        }
        case "unchanged": {
          break;
        }
        case "none":
        default: {
          if (this.state.size !== 0) {
            this.state.clear();
            this.notify();
          }
          break;
        }
      }
      this.isFiltered = false;
      return;
    }
    const indicesToExpand = new Set(nodes.reduce((acc, rootNode) => {
      this.updateExpandedNodes(acc, rootNode, autoExpandMatches);
      return acc;
    }, []));
    if (!sameValues(this.state, indicesToExpand)) {
      this.state = indicesToExpand;
      this.notify();
    }
    this.isFiltered = true;
  }
  /**
   * Fills array with the correct expand keys according to wrapper metadata.
   */
  updateExpandedNodes = (collection, node, autoExpandMatches) => {
    if (node.containsMatches || node.isMatch && autoExpandMatches && isArrayWithAtLeastOneItem(node.children)) {
      collection.push(this.itemKey({
        dataItem: node.dataItem,
        index: node.index
      }));
    }
    if (isArrayWithAtLeastOneItem(node.children)) {
      node.children.forEach((child) => {
        this.updateExpandedNodes(collection, child, autoExpandMatches);
      });
    }
  };
  /**
   * Fills array with the expand key of every node.
   */
  getEveryExpandKey = (collection, node) => {
    if (isArrayWithAtLeastOneItem(node.children)) {
      collection.push(this.itemKey({
        dataItem: node.dataItem,
        index: node.index
      }));
    }
    if (isArrayWithAtLeastOneItem(node.children)) {
      node.children.forEach((child) => {
        this.getEveryExpandKey(collection, child);
      });
    }
  };
  notify() {
    this.lastChange = Array.from(this.state);
    this.expandedKeysChange.emit(this.lastChange);
  }
  static ɵfac = function ExpandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ExpandDirective)(ɵɵdirectiveInject(ExpandableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ExpandDirective,
    selectors: [["", "kendoTreeViewExpandable", ""]],
    inputs: {
      isExpanded: "isExpanded",
      expandKey: [0, "expandBy", "expandKey"],
      expandOnFilter: "expandOnFilter",
      expandedKeys: "expandedKeys"
    },
    outputs: {
      expandedKeysChange: "expandedKeysChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewExpandable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandableComponent
    }];
  }, {
    isExpanded: [{
      type: Input
    }],
    expandKey: [{
      type: Input,
      args: ["expandBy"]
    }],
    expandOnFilter: [{
      type: Input
    }],
    expandedKeysChange: [{
      type: Output
    }],
    expandedKeys: [{
      type: Input
    }]
  });
})();
var compose = (...args) => (data) => args.reduceRight((acc, curr) => curr(acc), data);
var copyPageSize = (treeview, source, target) => {
  if (!isPresent4(treeview.loadMoreService)) {
    return;
  }
  const sourceGroupSize = treeview.getNodePageSize(source);
  treeview.setNodePageSize(target, sourceGroupSize);
};
var incrementPageSize = (treeview, dataItem) => {
  if (!isPresent4(treeview.loadMoreService)) {
    return;
  }
  const currentPageSize = treeview.getNodePageSize(dataItem);
  treeview.setNodePageSize(dataItem, currentPageSize + 1);
};
var decrementPageSize = (treeview, dataItem) => {
  if (!isPresent4(treeview.loadMoreService)) {
    return;
  }
  const currentPageSize = treeview.getNodePageSize(dataItem);
  treeview.setNodePageSize(dataItem, currentPageSize - 1);
};
var FlatEditingService = class {
  flatBinding;
  movedItemNewIndex;
  constructor(flatBinding) {
    this.flatBinding = flatBinding;
  }
  add({
    sourceItem,
    destinationItem,
    dropPosition,
    sourceTree,
    destinationTree
  }) {
    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
    if (dropPosition === DropPosition.Over) {
      expandDropTarget(destinationItem, destinationTree);
      const destinationItemId = getter(this.flatBinding.idField)(getDataItem(destinationItem));
      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemId);
      const lastChildNodeIndex = this.getLastVisibleChildNodeIndex(destinationTree, this.flatBinding.originalData, getDataItem(destinationItem));
      const targetIndex = lastChildNodeIndex + 1;
      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
      this.rebindData();
      const focusTarget = this.fetchChildNodes(getDataItem(destinationItem), destinationTree).indexOf(clonedSourceDataItem);
      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, focusTarget);
    } else {
      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
      const targetIndex = this.flatBinding.originalData.indexOf(getDataItem(destinationItem)) + shiftIndex;
      this.flatBinding.originalData.splice(targetIndex, 0, clonedSourceDataItem);
      const destinationItemParentId = getter(this.flatBinding.parentIdField)(getDataItem(destinationItem));
      setter(this.flatBinding.parentIdField)(clonedSourceDataItem, destinationItemParentId);
      this.rebindData();
      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
      const parentContainer = destinationItem.parent ? this.fetchChildNodes(getDataItem(destinationItem.parent), destinationTree) : destinationTree.nodes;
      const focusTarget = parentContainer.indexOf(clonedSourceDataItem);
      this.movedItemNewIndex = buildTreeIndex(parentIndex, focusTarget);
    }
    if (sourceTree !== destinationTree) {
      this.addChildNodes(clonedSourceDataItem, sourceTree);
    }
    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
    incrementPageSize(destinationTree, updatedParent);
    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
      destinationTree.preloadChildNodes();
    }
    if (sourceTree !== destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      destinationTree.focus(this.movedItemNewIndex);
    }
  }
  remove({
    sourceItem,
    sourceTree,
    destinationTree
  }) {
    const sourceDataItem = getDataItem(sourceItem);
    const sourceItemIndex = this.flatBinding.originalData.indexOf(sourceDataItem);
    this.flatBinding.originalData.splice(sourceItemIndex, 1);
    if (sourceTree !== destinationTree) {
      this.removeChildNodes(sourceDataItem, sourceTree);
    }
    this.rebindData();
    const parentChildren = sourceItem.parent ? sourceItem.parent.children : [];
    collapseEmptyParent(sourceItem.parent, parentChildren, sourceTree);
    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    if (!sourceTree.loadOnDemand) {
      sourceTree.preloadChildNodes();
    }
    if (sourceTree === destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
      destinationTree.focus(index);
    }
  }
  addChildNodes(dataItem, source) {
    const itemChildren = this.fetchAllDescendantNodes(dataItem, source);
    this.flatBinding.originalData.push(...itemChildren);
  }
  removeChildNodes(dataItem, source) {
    const sourceChildren = this.fetchAllDescendantNodes(dataItem, source);
    sourceChildren.forEach((item) => {
      const index = this.flatBinding.originalData.indexOf(item);
      this.flatBinding.originalData.splice(index, 1);
    });
  }
  fetchAllDescendantNodes(node, treeview) {
    let nodes = this.fetchChildNodes(node, treeview);
    nodes.forEach((node2) => nodes = nodes.concat(this.fetchAllDescendantNodes(node2, treeview) || []));
    return nodes;
  }
  fetchChildNodes(node, treeview) {
    if (!node) {
      return [];
    }
    let nodes = [];
    treeview.children(node).pipe(take(1)).subscribe((children) => nodes = nodes.concat(children || []));
    return nodes;
  }
  getLastVisibleChildNodeIndex(treeview, data, node) {
    if (!isPresent4(treeview.loadMoreService) || !treeview.hasChildren(node)) {
      return data.length;
    }
    const visibleNodesCount = treeview.loadMoreService.getGroupSize(node);
    const visibleChildren = this.fetchChildNodes(node, treeview).slice(0, visibleNodesCount);
    const lastNode = visibleChildren[visibleChildren.length - 1];
    const lastNodeIndex = data.indexOf(lastNode);
    return lastNodeIndex;
  }
  rebindData() {
    this.flatBinding.nodes = this.flatBinding.originalData;
    this.flatBinding.updateNodes(this.flatBinding.originalData);
  }
};
var DEFAULT_FILTER_SETTINGS = {
  operator: "contains",
  ignoreCase: true,
  mode: "lenient"
};
var FilteringBase = class _FilteringBase {
  component;
  /**
   * Stores the unfiltered nodes
   */
  filterData;
  visibleNodes = /* @__PURE__ */ new Set();
  /**
   * The settings which are applied when performing a filter on the component's data.
   */
  set filterSettings(settings) {
    this._filterSettings = __spreadValues(__spreadValues({}, DEFAULT_FILTER_SETTINGS), settings);
  }
  get filterSettings() {
    return this._filterSettings;
  }
  _filterSettings = DEFAULT_FILTER_SETTINGS;
  /**
   * Applies a filter and changes the visibility of the component's nodes accordingly.
   */
  set filter(term) {
    this.handleFilterChange(term);
  }
  constructor(component) {
    this.component = component;
  }
  /**
   * @hidden
   */
  handleFilterChange(term) {
    if (!this.filterData) {
      return;
    }
    this.resetNodesVisibility(this.filterData);
    if (term) {
      filterTree(this.filterData, term, this.filterSettings, this.component.textField);
    }
    this.updateVisibleNodes(this.filterData);
    if (isPresent4(this.component.filterStateChange)) {
      this.component.filterStateChange.emit({
        nodes: this.filterData,
        matchCount: this.visibleNodes.size,
        term,
        filterSettings: this.filterSettings
      });
    }
  }
  updateVisibleNodes(items) {
    items.forEach((wrapper) => {
      if (wrapper.visible) {
        this.visibleNodes.add(wrapper.dataItem);
      }
      if (wrapper.children) {
        this.updateVisibleNodes(wrapper.children);
      }
    });
  }
  resetNodesVisibility(items) {
    this.visibleNodes.clear();
    items.forEach((wrapper) => {
      wrapper.visible = true;
      if (wrapper.children) {
        this.resetNodesVisibility(wrapper.children);
      }
    });
  }
  static ɵfac = function FilteringBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilteringBase)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilteringBase,
    inputs: {
      filterSettings: "filterSettings",
      filter: "filter"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilteringBase, [{
    type: Directive
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    filterSettings: [{
      type: Input
    }],
    filter: [{
      type: Input
    }]
  });
})();
var findChildren = (prop, nodes, value) => nodes.filter((x) => prop(x) === value);
var indexBuilder$1 = new IndexBuilderService();
var mapToTree = (currentLevelNodes, allNodes, parentIdField, idField, parent = null, parentIndex = "") => {
  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
    return [];
  }
  return currentLevelNodes.map((node, idx) => {
    const index = indexBuilder$1.nodeIndex(idx.toString(), parentIndex);
    const wrapper = {
      dataItem: node,
      index,
      parent,
      visible: true
    };
    wrapper.children = mapToTree(findChildren(getter(parentIdField), allNodes || [], getter(idField)(node)), allNodes, parentIdField, idField, wrapper, index);
    return wrapper;
  });
};
var FlatDataBindingDirective = class _FlatDataBindingDirective extends FilteringBase {
  component;
  /**
   * Specifies the flat data collection that renders as nodes in the TreeView.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  _nodes;
  /**
   * Specifies the field name that contains the parent node identifier.
   */
  parentIdField;
  /**
   * Specifies the field name that contains the unique node identifier.
   */
  idField;
  /**
   * @hidden
   */
  loadOnDemand = true;
  /**
   * @hidden
   * A callback which determines whether a TreeView node should be rendered as hidden.
   */
  set isVisible(fn) {
    this.component.isVisible = fn;
  }
  /**
   * @hidden
   */
  originalData = [];
  constructor(component) {
    super(component);
    this.component = component;
    this.component.isVisible = (node) => this.visibleNodes.has(node);
  }
  /**
   * @hidden
   */
  ngOnInit() {
    if (isPresent4(this.parentIdField) && isPresent4(this.idField)) {
      const fetchChildren2 = (node) => findChildren(getter(this.parentIdField), this.originalData || [], getter(this.idField)(node));
      this.component.hasChildren = (node) => fetchChildren2(node).length > 0;
      this.component.children = (node) => of(fetchChildren2(node));
      this.component.editService = new FlatEditingService(this);
      this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
      if (this.component.filter) {
        this.handleFilterChange(this.component.filter);
      }
      if (!this.loadOnDemand && isPresent4(this.component.preloadChildNodes)) {
        this.component.preloadChildNodes();
      }
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (isChanged("parentIdField", changes, false)) {
      this.nodes = this.originalData;
      this.updateNodes(this.originalData);
    }
    if (isChanged("nodes", changes, false)) {
      this.updateNodes(changes["nodes"].currentValue);
    }
    if (anyChanged(["nodes", "loadOnDemand"], changes) && !this.loadOnDemand && isPresent4(this.component.preloadChildNodes)) {
      this.component.preloadChildNodes();
    }
  }
  /**
   * @hidden
   */
  updateNodes(values) {
    this.originalData = values || [];
    if (!isNullOrEmptyString(this.parentIdField)) {
      const prop = getter(this.parentIdField);
      this.component.nodes = this.originalData.filter(compose(isBlank, prop));
      this.filterData = mapToTree(this.component.nodes, this.originalData, this.parentIdField, this.idField);
      this.updateVisibleNodes(this.filterData);
    } else {
      this.component.nodes = this.originalData.slice(0);
    }
  }
  static ɵfac = function FlatDataBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FlatDataBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FlatDataBindingDirective,
    selectors: [["", "kendoTreeViewFlatDataBinding", ""]],
    inputs: {
      nodes: "nodes",
      parentIdField: "parentIdField",
      idField: "idField",
      loadOnDemand: "loadOnDemand",
      isVisible: "isVisible"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FlatDataBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewFlatDataBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input
    }],
    parentIdField: [{
      type: Input
    }],
    idField: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }]
  });
})();
var HierarchyEditingService = class {
  hierarchyBinding;
  movedItemNewIndex;
  constructor(hierarchyBinding) {
    this.hierarchyBinding = hierarchyBinding;
  }
  add({
    sourceItem,
    destinationItem,
    dropPosition,
    sourceTree,
    destinationTree
  }) {
    const clonedSourceDataItem = Object.assign({}, getDataItem(sourceItem));
    if (dropPosition === DropPosition.Over) {
      expandDropTarget(destinationItem, destinationTree);
      const destinationChildren = this.childrenFor(getDataItem(destinationItem));
      const targetIndex = isPresent4(destinationTree.loadMoreService) ? Math.min(destinationTree.loadMoreService.getGroupSize(getDataItem(destinationItem)), destinationChildren.length) : (
        // the page size might be greater than the actual children array length
        destinationChildren.length
      );
      destinationChildren.splice(targetIndex, 0, clonedSourceDataItem);
      setter(this.hierarchyBinding.childrenField)(getDataItem(destinationItem), destinationChildren);
      this.movedItemNewIndex = buildTreeIndex(destinationItem.item.index, targetIndex);
    } else {
      const destinationParentNodes = this.getParentNodes(destinationItem, destinationTree);
      const shiftIndex = dropPosition === DropPosition.After ? 1 : 0;
      const targetIndex = destinationParentNodes.indexOf(getDataItem(destinationItem)) + shiftIndex;
      destinationParentNodes.splice(targetIndex, 0, clonedSourceDataItem);
      const parentIndex = destinationItem.parent ? destinationItem.parent.item.index : null;
      this.movedItemNewIndex = buildTreeIndex(parentIndex, targetIndex);
    }
    const updatedParent = dropPosition === DropPosition.Over ? getDataItem(destinationItem) : getDataItem(destinationItem.parent);
    incrementPageSize(destinationTree, updatedParent);
    copyPageSize(destinationTree, getDataItem(sourceItem), clonedSourceDataItem);
    if (sourceTree !== destinationTree && !destinationTree.loadOnDemand) {
      destinationTree.preloadChildNodes();
    }
    if (sourceTree !== destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      destinationTree.focus(this.movedItemNewIndex);
    }
  }
  remove({
    sourceItem,
    sourceTree,
    destinationTree
  }) {
    const sourceParentNodes = this.getParentNodes(sourceItem, sourceTree);
    const sourceItemIndex = sourceParentNodes.indexOf(getDataItem(sourceItem));
    sourceParentNodes.splice(sourceItemIndex, 1);
    collapseEmptyParent(sourceItem.parent, sourceParentNodes, sourceTree);
    decrementPageSize(sourceTree, getDataItem(sourceItem.parent));
    if (!sourceTree.loadOnDemand) {
      sourceTree.preloadChildNodes();
    }
    if (sourceTree === destinationTree) {
      destinationTree.changeDetectorRef.detectChanges();
      const index = updateMovedItemIndex(this.movedItemNewIndex, sourceItem.item.index);
      destinationTree.focus(index);
    }
  }
  getParentNodes(node, treeView) {
    return isPresent4(node.parent) ? this.childrenFor(getDataItem(node.parent)) : treeView.nodes;
  }
  childrenFor(dataItem) {
    return getter(this.hierarchyBinding.childrenField)(dataItem) || [];
  }
};
var indexBuilder = new IndexBuilderService();
var mapToWrappers = (currentLevelNodes, childrenField, parent = null, parentIndex = "") => {
  if (!isArrayWithAtLeastOneItem(currentLevelNodes)) {
    return [];
  }
  return currentLevelNodes.map((node, idx) => {
    const index = indexBuilder.nodeIndex(idx.toString(), parentIndex);
    const wrapper = {
      dataItem: node,
      index,
      parent,
      visible: true
    };
    wrapper.children = mapToWrappers(getter(childrenField)(node), childrenField, wrapper, index);
    return wrapper;
  });
};
var HierarchyBindingDirective = class _HierarchyBindingDirective extends FilteringBase {
  component;
  dragAndDropDirective;
  /**
   * Specifies the field name of the parent node that holds the child data items.
   */
  set childrenField(value) {
    if (!value) {
      throw new Error("'childrenField' cannot be empty");
    }
    this._childrenField = value;
  }
  /**
   * Specifies the field name of the parent node that holds the child data items.
   */
  get childrenField() {
    return this._childrenField;
  }
  /**
   * Specifies the hierarchical data displayed by the TreeView.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  _nodes;
  /**
   * @hidden
   * A callback which determines whether a TreeView node should be rendered as hidden.
   */
  set isVisible(fn) {
    this.component.isVisible = fn;
  }
  /**
   * @hidden
   */
  loadOnDemand = true;
  _childrenField;
  originalData = [];
  constructor(component, dragAndDropDirective) {
    super(component);
    this.component = component;
    this.dragAndDropDirective = dragAndDropDirective;
    const shouldFilter = !isPresent4(this.dragAndDropDirective);
    this.component.isVisible = shouldFilter ? (node) => this.visibleNodes.has(node) : isVisible;
  }
  ngOnInit() {
    if (isPresent4(this.childrenField)) {
      this.component.children = (item) => of(getter(this.childrenField)(item));
      this.component.hasChildren = (item) => {
        const children = getter(this.childrenField)(item);
        return Boolean(children && children.length);
      };
      this.component.editService = new HierarchyEditingService(this);
      this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
      if (this.component.filter) {
        this.handleFilterChange(this.component.filter);
      }
      if (!this.loadOnDemand && isPresent4(this.component.preloadChildNodes)) {
        this.component.preloadChildNodes();
      }
    }
  }
  ngOnChanges(changes) {
    if (isChanged("childrenField", changes, false)) {
      this.nodes = this.originalData;
      this.updateNodes(this.originalData);
    }
    if (isChanged("nodes", changes, false)) {
      this.updateNodes(changes["nodes"].currentValue);
    }
    if (anyChanged(["nodes", "loadOnDemand"], changes) && !this.loadOnDemand && isPresent4(this.component.preloadChildNodes)) {
      this.component.preloadChildNodes();
    }
  }
  /**
   * @hidden
   */
  updateNodes(values) {
    this.originalData = values || [];
    this.filterData = mapToWrappers(values, this.childrenField) || [];
    this.updateVisibleNodes(this.filterData);
  }
  static ɵfac = function HierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent), ɵɵdirectiveInject(DragAndDropDirective, 9));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HierarchyBindingDirective,
    selectors: [["", "kendoTreeViewHierarchyBinding", ""]],
    inputs: {
      childrenField: "childrenField",
      nodes: "nodes",
      isVisible: "isVisible",
      loadOnDemand: "loadOnDemand"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }, {
      type: DragAndDropDirective,
      decorators: [{
        type: Optional
      }, {
        type: Host
      }]
    }];
  }, {
    childrenField: [{
      type: Input
    }],
    nodes: [{
      type: Input
    }],
    isVisible: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }]
  });
})();
var LOAD_MORE_DOC_LINK = "https://www.telerik.com/kendo-angular-ui/components/treeview/load-more-button/";
var LoadMoreDirective = class _LoadMoreDirective {
  treeview;
  /**
   * Sets the callback function that runs when the load more button is clicked.
   * Provide a function when you fetch additional nodes on demand
   * ([see example](slug:loadmorebutton_treeview#remote-data)).
   *
   */
  set loadMoreNodes(loadMoreNodes) {
    if (typeof loadMoreNodes === "string") {
      return;
    }
    this.treeview.loadMoreService.loadMoreNodes = loadMoreNodes;
  }
  /**
   * Sets the initial number of nodes to render on each level.
   * Each time the load more button is clicked, the page size increases by this number.
   */
  pageSize;
  /**
   * Sets the total number of root nodes.
   * Use this property when you fetch additional nodes on demand
   * ([see example](slug:loadmorebutton_treeview#remote-data)).
   */
  totalRootNodes;
  /**
   * Sets the field that contains the total number of child nodes for the data item.
   * Use this property when you fetch additional nodes on demand
   * ([see example](slug:loadmorebutton_treeview#remote-data)).
   */
  totalField;
  /**
   * Keeps track of the current page size of each node over expand/collapse cycles.
   */
  pageSizes = /* @__PURE__ */ new Map();
  /**
   * Used as an identifier for the root page size as the root collection of nodes is not associated with a data item.
   */
  rootLevelId = guid();
  constructor(treeview) {
    this.treeview = treeview;
    this.treeview.loadMoreService = {
      getInitialPageSize: this.getInitalPageSize.bind(this),
      getGroupSize: this.getGroupSize.bind(this),
      setGroupSize: this.setGroupSize.bind(this),
      getTotalNodesCount: this.getTotalNodesCount.bind(this)
    };
  }
  ngOnChanges() {
    this.verifySettings();
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isPresent4(this.pageSize)) {
      throw new Error(`To use the TreeView \`kendoTreeViewLoadMore\` directive, you need to assign a \`pageSize\` value. See ${LOAD_MORE_DOC_LINK}.`);
    }
    const loadMoreNodes = this.treeview.loadMoreService.loadMoreNodes;
    if (isPresent4(loadMoreNodes) && typeof loadMoreNodes !== "function") {
      throw new Error(`The passed value to the \`kendoTreeViewLoadMore\` directive must be a function that retrieves additional nodes. See ${LOAD_MORE_DOC_LINK}.`);
    }
    if (isPresent4(loadMoreNodes) && !isPresent4(this.totalField)) {
      throw new Error(`When a function to fetch additional nodes is provided to the \`kendoTreeViewLoadMore\` directive, the \`totalField\` and \`totalRootNodes\` values must also be provided. See ${LOAD_MORE_DOC_LINK}.`);
    }
  }
  getGroupSize(dataItem) {
    const itemKey = dataItem || this.rootLevelId;
    return this.pageSizes.has(itemKey) ? this.pageSizes.get(itemKey) : this.pageSize;
  }
  setGroupSize(dataItem, pageSize) {
    const itemKey = dataItem || this.rootLevelId;
    const normalizedSizeValue = pageSize > 0 ? pageSize : 0;
    this.pageSizes.set(itemKey, normalizedSizeValue);
  }
  getTotalNodesCount(dataItem, loadedNodesCount) {
    if (isPresent4(dataItem) && isPresent4(this.totalField)) {
      return dataItem[this.totalField];
    } else if (!isPresent4(dataItem) && isPresent4(this.totalRootNodes)) {
      return this.totalRootNodes;
    } else {
      return loadedNodesCount;
    }
  }
  getInitalPageSize() {
    return this.pageSize;
  }
  static ɵfac = function LoadMoreDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LoadMoreDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LoadMoreDirective,
    selectors: [["", "kendoTreeViewLoadMore", ""]],
    inputs: {
      loadMoreNodes: [0, "kendoTreeViewLoadMore", "loadMoreNodes"],
      pageSize: "pageSize",
      totalRootNodes: "totalRootNodes",
      totalField: "totalField"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LoadMoreDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewLoadMore]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    loadMoreNodes: [{
      type: Input,
      args: ["kendoTreeViewLoadMore"]
    }],
    pageSize: [{
      type: Input
    }],
    totalRootNodes: [{
      type: Input
    }],
    totalField: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent = class _CustomMessagesComponent extends TreeViewMessages {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-treeview-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: TreeViewMessages,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent, [{
    type: Component,
    args: [{
      providers: [{
        provide: TreeViewMessages,
        useExisting: forwardRef(() => CustomMessagesComponent)
      }],
      selector: "kendo-treeview-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SelectDirective = class _SelectDirective {
  treeView;
  navigationService;
  /**
   * @hidden
   */
  set isSelected(value) {
    this.treeView.isSelected = value;
  }
  /**
   * Sets the item key stored in the `selectedKeys` collection.
   */
  selectKey;
  /**
   * Sets the current selection mode
   * ([see example](slug:selection_treeview#modes)).
   */
  selection;
  /**
   * Defines the collection that stores the selected keys
   * ([see example](slug:selection_treeview#toc-modes)).
   */
  selectedKeys;
  /**
   * Emits when the `selectedKeys` collection updates.
   */
  selectedKeysChange = new EventEmitter();
  get getAriaMultiselectable() {
    return this.options.mode === "multiple";
  }
  subscriptions = new Subscription();
  get options() {
    const defaultOptions = {
      enabled: true,
      mode: "single"
    };
    if (!isPresent4(this.selection) || typeof this.selection === "string") {
      return defaultOptions;
    }
    const selectionSettings = isBoolean(this.selection) ? {
      enabled: this.selection
    } : this.selection;
    return Object.assign(defaultOptions, selectionSettings);
  }
  selectActions = {
    "multiple": (e) => this.selectMultiple(e),
    "single": (e) => this.selectSingle(e)
  };
  /**
   * Reflects the internal `selectedKeys` state.
   */
  state = /* @__PURE__ */ new Set();
  /**
   * Holds the last emitted `selectedKeys` collection.
   */
  lastChange;
  constructor(treeView, navigationService) {
    this.treeView = treeView;
    this.navigationService = navigationService;
    this.subscriptions.add(this.treeView.selectionChange.subscribe(this.select.bind(this)));
    this.treeView.isSelected = (dataItem, index) => this.state.has(this.itemKey({
      dataItem,
      index
    }));
    this.navigationService.deselectAllButCurrentItem.subscribe((node) => {
      this.selectSingle(node);
    });
  }
  ngOnChanges(changes) {
    if (isChanged("selectedKeys", changes, false) && changes["selectedKeys"].currentValue !== this.lastChange) {
      this.state = new Set(changes["selectedKeys"].currentValue);
    }
    const isSelectionBooleanTrue = typeof this.selection === "boolean" && this.selection;
    this.navigationService.selection = isSelectionBooleanTrue ? "single" : this.selection?.mode;
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  itemKey(e) {
    if (!this.selectKey) {
      return e.index;
    }
    if (typeof this.selectKey === "string") {
      return e.dataItem[this.selectKey];
    }
    if (typeof this.selectKey === "function") {
      return this.selectKey(e);
    }
  }
  select(e) {
    const {
      enabled,
      mode
    } = this.options;
    const performSelection = this.selectActions[mode] || noop5;
    if (!enabled) {
      return;
    }
    performSelection(e);
  }
  selectSingle(node) {
    const key = this.itemKey(node);
    if (!this.state.has(key)) {
      this.state.clear();
      this.state.add(key);
      this.notify();
    }
  }
  selectMultiple(node) {
    const key = this.itemKey(node);
    const isSelected2 = this.state.has(key);
    if (!isPresent4(key)) {
      return;
    }
    if (isSelected2) {
      this.state.delete(key);
    } else {
      this.state.add(key);
    }
    this.notify();
  }
  notify() {
    this.lastChange = Array.from(this.state);
    this.selectedKeysChange.emit(this.lastChange);
  }
  static ɵfac = function SelectDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectDirective)(ɵɵdirectiveInject(TreeViewComponent), ɵɵdirectiveInject(NavigationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectDirective,
    selectors: [["", "kendoTreeViewSelectable", ""]],
    hostVars: 1,
    hostBindings: function SelectDirective_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-multiselectable", ctx.getAriaMultiselectable);
      }
    },
    inputs: {
      isSelected: "isSelected",
      selectKey: [0, "selectBy", "selectKey"],
      selection: [0, "kendoTreeViewSelectable", "selection"],
      selectedKeys: "selectedKeys"
    },
    outputs: {
      selectedKeysChange: "selectedKeysChange"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoTreeViewSelectable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }, {
      type: NavigationService
    }];
  }, {
    isSelected: [{
      type: Input
    }],
    selectKey: [{
      type: Input,
      args: ["selectBy"]
    }],
    selection: [{
      type: Input,
      args: ["kendoTreeViewSelectable"]
    }],
    selectedKeys: [{
      type: Input
    }],
    selectedKeysChange: [{
      type: Output
    }],
    getAriaMultiselectable: [{
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }]
  });
})();
var KENDO_TREEVIEW = [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent];
var TreeViewModule = class _TreeViewModule {
  static ɵfac = function TreeViewModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TreeViewModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _TreeViewModule,
    imports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent],
    exports: [TreeViewComponent, NodeTemplateDirective, CheckDirective, DisableDirective, ExpandDirective, SelectDirective, HierarchyBindingDirective, FlatDataBindingDirective, DragAndDropDirective, DragClueTemplateDirective, DropHintTemplateDirective, DragAndDropEditingDirective, LoadMoreDirective, LoadMoreButtonTemplateDirective, CustomMessagesComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService],
    imports: [TreeViewComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeViewModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_TREEVIEW],
      exports: [...KENDO_TREEVIEW],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService]
    }]
  }], null, null);
})();

// node_modules/@progress/kendo-angular-dropdowns/fesm2022/progress-kendo-angular-dropdowns.mjs
var _c04 = ["kendoSearchbar", ""];
var _c111 = ["content"];
var _c211 = ["list"];
var _c311 = ["virtualContainer"];
var _c411 = (a0) => ({
  "k-disabled": a0
});
var _c511 = (a0, a1) => ({
  templateRef: a0,
  $implicit: a1
});
var _c611 = (a0, a1, a2) => ({
  "height.px": a0,
  "minHeight.px": a1,
  "boxSizing": a2
});
var _c72 = (a0, a1) => ({
  "k-disabled": a0,
  "k-table-alt-row": a1
});
function ListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c411, ctx_r1.isDisabledDefaultItem))("index", -1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.getDefaultItemText(), " ");
  }
}
function ListComponent_div_1_ng_template_1_Template(rf, ctx) {
}
function ListComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, ListComponent_div_1_ng_template_1_Template, 0, 0, "ng-template", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c411, ctx_r1.isDisabledDefaultItem))("index", -1);
    ɵɵadvance();
    ɵɵproperty("templateContext", ɵɵpureFunction2(5, _c511, ctx_r1.template.templateRef, ctx_r1.defaultItem));
  }
}
function ListComponent_div_2_1_ng_template_0_Template(rf, ctx) {
}
function ListComponent_div_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_div_2_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.customItemTemplate.templateRef, ctx_r1.text));
  }
}
function ListComponent_div_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(' Use "', ctx_r1.text, '" ');
  }
}
function ListComponent_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, ListComponent_div_2_1_Template, 1, 4, null, 16)(2, ListComponent_div_2_ng_template_2_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const default_custom_item_template_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("multipleSelection", true)("index", -1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.customItemTemplate)("ngIfElse", default_custom_item_template_r3);
  }
}
function ListComponent_div_3_1_ng_template_0_Template(rf, ctx) {
}
function ListComponent_div_3_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_div_3_1_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.fixedGroupTemplate.templateRef, ctx_r1.currentGroup));
  }
}
function ListComponent_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listGroupStickyHeaderTextClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.currentGroup);
  }
}
function ListComponent_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtemplate(1, ListComponent_div_3_1_Template, 1, 4, null, 10)(2, ListComponent_div_3_ng_template_2_Template, 2, 3, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.listGroupStickyHeaderClass);
    ɵɵproperty("ngStyle", ɵɵpureFunction3(5, _c611, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual ? "border-box" : "inherit"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.fixedGroupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.fixedGroupTemplate);
  }
}
function ListComponent_8_ng_template_0_input_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 22);
    ɵɵlistener("change", function ListComponent_8_ng_template_0_input_1_Template_input_change_0_listener($event) {
      ɵɵrestoreView(_r4);
      const itemIndex_r5 = ɵɵnextContext().index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onCheckedChange($event, itemIndex_r5 + ctx_r1.startFrom));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const itemIndex_r5 = ɵɵnextContext().index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ctx_r1.checkboxClasses)("checked", ctx_r1.isChecked(itemIndex_r5));
  }
}
function ListComponent_8_ng_template_0_2_ng_template_0_Template(rf, ctx) {
}
function ListComponent_8_ng_template_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_8_ng_template_0_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.template.templateRef, dataItem_r6));
  }
}
function ListComponent_8_ng_template_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 23);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dataItem_r6 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getText(dataItem_r6));
  }
}
function ListComponent_8_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 20);
    ɵɵtemplate(1, ListComponent_8_ng_template_0_input_1_Template, 1, 2, "input", 21)(2, ListComponent_8_ng_template_0_2_Template, 1, 4, null, 10)(3, ListComponent_8_ng_template_0_ng_template_3_Template, 2, 1, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_7_0;
    const itemIndex_r5 = ctx.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listItemClass);
    ɵɵstyleProp("width", (tmp_7_0 = ctx_r1.rowWidth) !== null && tmp_7_0 !== void 0 ? tmp_7_0 : null, "px");
    ɵɵproperty("checkboxes", ctx_r1.checkboxes)("height", ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight)("index", itemIndex_r5 + ctx_r1.startFrom)("multipleSelection", ctx_r1.multipleSelection)("ngClass", ɵɵpureFunction2(15, _c72, ctx_r1.isDisabled(itemIndex_r5), ctx_r1.isAltRow(itemIndex_r5)));
    ɵɵattribute("id", ctx_r1.optionPrefix + "-" + itemIndex_r5)("tabIndex", -1)("aria-selected", ctx_r1.isItemSelected(itemIndex_r5));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.checkboxes.enabled);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.template);
  }
}
function ListComponent_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_8_ng_template_0_Template, 4, 18, "ng-template", 19);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function ListComponent_9_ng_template_0_li_0_3_ng_template_0_Template(rf, ctx) {
}
function ListComponent_9_ng_template_0_li_0_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_9_ng_template_0_li_0_3_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const dataItem_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.groupTemplate.templateRef, dataItem_r7.value));
  }
}
function ListComponent_9_ng_template_0_li_0_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const dataItem_r7 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(dataItem_r7.value);
  }
}
function ListComponent_9_ng_template_0_li_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 26, 3)(2, "span");
    ɵɵtemplate(3, ListComponent_9_ng_template_0_li_0_3_Template, 1, 4, null, 10)(4, ListComponent_9_ng_template_0_li_0_ng_template_4_Template, 1, 1, "ng-template", 18);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r7 = ɵɵnextContext();
    const dataItem_r7 = ctx_r7.$implicit;
    const itemIndex_r9 = ctx_r7.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listGroupItemClass);
    ɵɵstyleProp("width", (tmp_9_0 = ctx_r1.rowWidth) !== null && tmp_9_0 !== void 0 ? tmp_9_0 : null, "px");
    ɵɵclassProp("k-table-alt-row", ctx_r1.isAltRow(itemIndex_r9 - 1));
    ɵɵproperty("ngStyle", ɵɵpureFunction3(14, _c611, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight, ctx_r1.virtual ? "border-box" : "inherit"));
    ɵɵattribute("group-index", dataItem_r7.index)("id", ctx_r1.optionPrefix + "-" + dataItem_r7.groupIndex + "-" + dataItem_r7.value.toString().split(" ").join(""))("tabIndex", -1);
    ɵɵadvance(2);
    ɵɵclassMap(ctx_r1.listGroupItemTextClass);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.groupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.groupTemplate);
  }
}
function ListComponent_9_ng_template_0_li_1_2_ng_template_0_Template(rf, ctx) {
}
function ListComponent_9_ng_template_0_li_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_9_ng_template_0_li_1_2_ng_template_0_Template, 0, 0, "ng-template", 14);
  }
  if (rf & 2) {
    const dataItem_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.template.templateRef, dataItem_r7.value));
  }
}
function ListComponent_9_ng_template_0_li_1_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 23);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dataItem_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.getText(dataItem_r7.value));
  }
}
function ListComponent_9_ng_template_0_li_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "li", 27, 3);
    ɵɵtemplate(2, ListComponent_9_ng_template_0_li_1_2_Template, 1, 4, null, 10)(3, ListComponent_9_ng_template_0_li_1_ng_template_3_Template, 2, 1, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    let tmp_9_0;
    const ctx_r7 = ɵɵnextContext();
    const dataItem_r7 = ctx_r7.$implicit;
    const itemIndex_r9 = ctx_r7.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1.listItemClass);
    ɵɵstyleProp("width", (tmp_9_0 = ctx_r1.rowWidth) !== null && tmp_9_0 !== void 0 ? tmp_9_0 : null, "px");
    ɵɵproperty("height", ctx_r1.virtual == null ? null : ctx_r1.virtual.itemHeight)("index", dataItem_r7.offsetIndex)("multipleSelection", ctx_r1.multipleSelection)("ngClass", ɵɵpureFunction2(14, _c72, ctx_r1.isDisabled(dataItem_r7.offsetIndex), ctx_r1.isAltRow(itemIndex_r9 - 1)));
    ɵɵattribute("absolute-index", dataItem_r7.index)("id", ctx_r1.optionPrefix + "-" + (itemIndex_r9 - 1 - dataItem_r7.groupIndex))("tabIndex", -1)("aria-selected", ctx_r1.isItemSelected(dataItem_r7.offsetIndex));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.template);
  }
}
function ListComponent_9_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_9_ng_template_0_li_0_Template, 5, 18, "li", 24)(1, ListComponent_9_ng_template_0_li_1_Template, 4, 17, "li", 25);
  }
  if (rf & 2) {
    const dataItem_r7 = ctx.$implicit;
    ɵɵproperty("ngIf", dataItem_r7.header);
    ɵɵadvance();
    ɵɵproperty("ngIf", !dataItem_r7.header);
  }
}
function ListComponent_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ListComponent_9_ng_template_0_Template, 2, 2, "ng-template", 19);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r1.data);
  }
}
function ListComponent_kendo_resize_sensor_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 28);
    ɵɵlistener("resize", function ListComponent_kendo_resize_sensor_10_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.listResize.emit());
    });
    ɵɵelementEnd();
  }
}
function ListComponent_div_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 29, 4)(2, "div")(3, "kendo-resize-sensor", 28);
    ɵɵlistener("resize", function ListComponent_div_11_Template_kendo_resize_sensor_resize_3_listener() {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.listResize.emit());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵstyleProp("height", ctx_r1.scrollHeight, "px");
  }
}
var _c82 = ["actionSheetSearchBar"];
var _c92 = (a0) => ({
  duration: a0
});
var _c102 = (a0, a1) => ({
  "k-adaptive-actionsheet": true,
  "k-actionsheet-fullscreen": a0,
  "k-actionsheet-bottom": a1
});
var _c112 = (a0) => ({
  height: a0
});
function AdaptiveRendererComponent_ng_template_2_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.title);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 16);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.subtitle);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_7_3_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-icon", 21);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_7_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AdaptiveRendererComponent_ng_template_2_div_7_3_ng_template_0_Template, 1, 0, "ng-template", 20);
  }
}
function AdaptiveRendererComponent_ng_template_2_div_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17)(1, "kendo-textbox", 18, 1);
    ɵɵlistener("valueChange", function AdaptiveRendererComponent_ng_template_2_div_7_Template_kendo_textbox_valueChange_1_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.onValueChange($event));
    });
    ɵɵtemplate(3, AdaptiveRendererComponent_ng_template_2_div_7_3_Template, 1, 0, null, 19);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("value", ctx_r2.searchBarValue || "")("placeholder", ctx_r2.filterable ? ctx_r2.messageFor("filterInputPlaceholder") : ctx_r2.placeholder);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.filterable);
  }
}
function AdaptiveRendererComponent_ng_template_2_ng_container_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AdaptiveRendererComponent_ng_template_2_Template2(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4)(1, "div", 5)(2, "div", 6);
    ɵɵtemplate(3, AdaptiveRendererComponent_ng_template_2_div_3_Template, 2, 1, "div", 7)(4, AdaptiveRendererComponent_ng_template_2_div_4_Template, 2, 1, "div", 8);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 9)(6, "button", 10);
    ɵɵlistener("click", function AdaptiveRendererComponent_ng_template_2_Template_button_click_6_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.handleClose());
    });
    ɵɵelementEnd()()();
    ɵɵtemplate(7, AdaptiveRendererComponent_ng_template_2_div_7_Template, 4, 3, "div", 11);
    ɵɵelementEnd();
    ɵɵelementStart(8, "div", 12)(9, "div", 13);
    ɵɵtemplate(10, AdaptiveRendererComponent_ng_template_2_ng_container_10_Template, 1, 0, "ng-container", 14);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r2.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.subtitle);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r2.checkIcon)("tabIndex", -1);
    ɵɵattribute("title", ctx_r2.messageFor("adaptiveCloseButtonTitle"));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showTextInput);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.sharedPopupActionSheetTemplate);
  }
}
var _c122 = ["container"];
var _c132 = ["popupTemplate"];
var _c142 = ["optionsList"];
var _c152 = (a0) => ({
  templateRef: a0
});
function AutoCompleteComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, AutoCompleteComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function AutoCompleteComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function AutoCompleteComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 16);
    ɵɵlistener("click", function AutoCompleteComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    })("mousedown", function AutoCompleteComponent_span_5_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵelement(1, "kendo-icon-wrapper", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function AutoCompleteComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 18);
  }
}
function AutoCompleteComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function AutoCompleteComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 19);
    ɵɵtemplate(1, AutoCompleteComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function AutoCompleteComponent_ng_template_9_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function AutoCompleteComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_9_ng_container_0_Template, 1, 0, "ng-container", 20);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(16);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function AutoCompleteComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 21);
    ɵɵlistener("resize", function AutoCompleteComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function AutoCompleteComponent_ng_template_15_0_ng_template_0_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_0_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate.templateRef));
  }
}
function AutoCompleteComponent_ng_template_15_div_3_ng_template_1_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function AutoCompleteComponent_ng_template_15_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, AutoCompleteComponent_ng_template_15_div_3_ng_template_1_Template, 0, 0, "ng-template", 26)(2, AutoCompleteComponent_ng_template_15_div_3_ng_template_2_Template, 2, 1, "ng-template", 27);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function AutoCompleteComponent_ng_template_15_4_ng_template_0_Template(rf, ctx) {
}
function AutoCompleteComponent_ng_template_15_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_4_ng_template_0_Template, 0, 0, "ng-template", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate.templateRef));
  }
}
function AutoCompleteComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, AutoCompleteComponent_ng_template_15_0_Template, 1, 3, null, 7);
    ɵɵelementStart(1, "kendo-list", 22, 3);
    ɵɵlistener("pageChange", function AutoCompleteComponent_ng_template_15_Template_kendo_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, AutoCompleteComponent_ng_template_15_div_3_Template, 3, 5, "div", 23)(4, AutoCompleteComponent_ng_template_15_4_Template, 1, 3, null, 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.valueField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c162 = ["select"];
var _c172 = (a0) => ({
  mousedown: a0
});
function ComboBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 17);
    ɵɵtemplate(1, ComboBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function ComboBoxComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function ComboBoxComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 19);
    ɵɵlistener("click", function ComboBoxComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(5, _c172, ctx_r1.preventEventDefault));
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function ComboBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 21);
  }
}
function ComboBoxComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function ComboBoxComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtemplate(1, ComboBoxComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function ComboBoxComponent_ng_template_12_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ComboBoxComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_12_ng_container_0_Template, 1, 0, "ng-container", 23);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function ComboBoxComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 24);
    ɵɵlistener("resize", function ComboBoxComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function ComboBoxComponent_ng_template_18_0_ng_template_0_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_0_ng_template_0_Template, 0, 0, "ng-template", 27);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate.templateRef));
  }
}
function ComboBoxComponent_ng_template_18_div_3_ng_template_1_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function ComboBoxComponent_ng_template_18_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 28);
    ɵɵtemplate(1, ComboBoxComponent_ng_template_18_div_3_ng_template_1_Template, 0, 0, "ng-template", 29)(2, ComboBoxComponent_ng_template_18_div_3_ng_template_2_Template, 2, 1, "ng-template", 30);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function ComboBoxComponent_ng_template_18_4_ng_template_0_Template(rf, ctx) {
}
function ComboBoxComponent_ng_template_18_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_4_ng_template_0_Template, 0, 0, "ng-template", 27);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate.templateRef));
  }
}
function ComboBoxComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, ComboBoxComponent_ng_template_18_0_Template, 1, 3, null, 8);
    ɵɵelementStart(1, "kendo-list", 25, 4);
    ɵɵlistener("pageChange", function ComboBoxComponent_ng_template_18_Template_kendo_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, ComboBoxComponent_ng_template_18_div_3_Template, 3, 5, "div", 26)(4, ComboBoxComponent_ng_template_18_4_Template, 1, 3, null, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c182 = ["searchInput"];
function DropDownListComponent_3_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.valueTemplate.templateRef, ctx_r1.dataItem));
  }
}
function DropDownListComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r1.getText());
  }
}
function DropDownListComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 16);
  }
}
function DropDownListComponent_ng_template_8_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DropDownListComponent_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_8_ng_container_0_Template, 1, 0, "ng-container", 17);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r3 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r3);
  }
}
function DropDownListComponent_kendo_resize_sensor_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 18);
    ɵɵlistener("resize", function DropDownListComponent_kendo_resize_sensor_10_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function DropDownListComponent_ng_template_14_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 21);
    ɵɵlistener("click", function DropDownListComponent_ng_template_14_ng_template_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopImmediatePropagation());
    });
    ɵɵelementStart(1, "span", 22);
    ɵɵelement(2, "kendo-icon-wrapper", 23);
    ɵɵelementStart(3, "input", 24, 4);
    ɵɵtwoWayListener("ngModelChange", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_ngModelChange_3_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.filterText, $event) || (ctx_r1.filterText = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("keydown", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_keydown_3_listener($event) {
      ɵɵrestoreView(_r6);
      const searchInput_r7 = ɵɵreference(4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.keydown($event, searchInput_r7));
    })("input", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_input_3_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilter($event));
    })("focus", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_focus_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onFilterFocus());
    })("blur", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_blur_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.blurFilterInput());
    })("click", function DropDownListComponent_ng_template_14_ng_template_0_Template_input_click_3_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleClick());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.isFocused && !ctx_r1.touchEnabled)("dir", ctx_r1.direction);
    ɵɵtwoWayProperty("ngModel", ctx_r1.filterText);
    ɵɵattribute("aria-controls", ctx_r1.listBoxId)("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function DropDownListComponent_ng_template_14_1_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_1_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate.templateRef));
  }
}
function DropDownListComponent_ng_template_14_div_4_ng_template_1_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_div_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function DropDownListComponent_ng_template_14_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 25);
    ɵɵtemplate(1, DropDownListComponent_ng_template_14_div_4_ng_template_1_Template, 0, 0, "ng-template", 26)(2, DropDownListComponent_ng_template_14_div_4_ng_template_2_Template, 2, 1, "ng-template", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function DropDownListComponent_ng_template_14_5_ng_template_0_Template(rf, ctx) {
}
function DropDownListComponent_ng_template_14_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_5_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate.templateRef));
  }
}
function DropDownListComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵtemplate(0, DropDownListComponent_ng_template_14_ng_template_0_Template, 5, 7, "ng-template", 9)(1, DropDownListComponent_ng_template_14_1_Template, 1, 3, null, 8);
    ɵɵelementStart(2, "kendo-list", 19, 3);
    ɵɵlistener("pageChange", function DropDownListComponent_ng_template_14_Template_kendo_list_pageChange_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(4, DropDownListComponent_ng_template_14_div_4_Template, 3, 5, "div", 20)(5, DropDownListComponent_ng_template_14_5_Template, 1, 3, null, 8);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.listBoxId)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("rounded", ctx_r1.rounded)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.itemTemplate)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("virtual", ctx_r1.virtual)("ariaLive", ctx_r1.ariaLive)("showStickyHeader", ctx_r1.showStickyHeader)("defaultItem", ctx_r1.defaultItem);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c192 = ["*"];
var _c202 = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) => ({
  "k-focus": a0,
  "k-disabled": a1,
  "k-chip-sm": a2,
  "k-chip-md": a3,
  "k-chip-lg": a4,
  "k-rounded-sm": a5,
  "k-rounded-md": a6,
  "k-rounded-lg": a7,
  "k-rounded-full": a8,
  "k-chip-solid k-chip-solid-base": a9,
  "k-chip-flat k-chip-flat-base": a10,
  "k-chip-outline k-chip-outline-base": a11
});
function TagListComponent_div_0_2_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_2_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function TagListComponent_div_0_ng_template_3_1_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_ng_template_3_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_ng_template_3_1_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r2.groupTemplate.templateRef, tag_r2));
  }
}
function TagListComponent_div_0_ng_template_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate2("", tag_r2.length, " ", tag_r2.length === 1 ? "item" : "items", " selected");
  }
}
function TagListComponent_div_0_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TagListComponent_div_0_ng_template_3_1_Template, 1, 4, null, 10)(2, TagListComponent_div_0_ng_template_3_ng_template_2_Template, 1, 2, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.groupTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.groupTemplate);
  }
}
function TagListComponent_div_0_ng_template_5_1_ng_template_0_Template(rf, ctx) {
}
function TagListComponent_div_0_ng_template_5_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, TagListComponent_div_0_ng_template_5_1_ng_template_0_Template, 0, 0, "ng-template", 12);
  }
  if (rf & 2) {
    const tag_r2 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r2.template.templateRef, tag_r2));
  }
}
function TagListComponent_div_0_ng_template_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext(2);
    const tag_r2 = ctx_r3.$implicit;
    const index_r5 = ctx_r3.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r2.tagProp(tag_r2, ctx_r2.textField, index_r5));
  }
}
function TagListComponent_div_0_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 9);
    ɵɵtemplate(1, TagListComponent_div_0_ng_template_5_1_Template, 1, 4, null, 10)(2, TagListComponent_div_0_ng_template_5_ng_template_2_Template, 1, 1, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.template);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.template);
  }
}
function TagListComponent_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "span", 4);
    ɵɵtemplate(2, TagListComponent_div_0_2_Template, 1, 0, null, 5)(3, TagListComponent_div_0_ng_template_3_Template, 3, 2, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, TagListComponent_div_0_ng_template_5_Template, 3, 2, "ng-template", null, 1, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
    ɵɵelementStart(7, "span", 6)(8, "span", 7)(9, "kendo-icon-wrapper", 8);
    ɵɵlistener("mousedown", function TagListComponent_div_0_Template_kendo_icon_wrapper_mousedown_9_listener($event) {
      const ctx_r5 = ɵɵrestoreView(_r1);
      const tag_r2 = ctx_r5.$implicit;
      const index_r5 = ctx_r5.index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.deleteTag($event, tag_r2, index_r5));
    });
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const tag_r2 = ctx.$implicit;
    const index_r5 = ctx.index;
    const groupTag_r7 = ɵɵreference(4);
    const singleTag_r8 = ɵɵreference(6);
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunctionV(9, _c202, [index_r5 === ctx_r2.focused, ctx_r2.isTagDisabled(tag_r2, index_r5), ctx_r2.size === "small", ctx_r2.size === "medium", ctx_r2.size === "large", ctx_r2.rounded === "small", ctx_r2.rounded === "medium", ctx_r2.rounded === "large", ctx_r2.rounded === "full", ctx_r2.fillMode === "solid", ctx_r2.fillMode === "flat", ctx_r2.fillMode === "outline"]));
    ɵɵattribute("id", ctx_r2.itemId(tag_r2, index_r5))("aria-selected", true)("role", "option");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r2.isGroupTag(tag_r2))("ngIfThen", groupTag_r7)("ngIfElse", singleTag_r8);
    ɵɵadvance(6);
    ɵɵattribute("aria-hidden", index_r5 !== ctx_r2.focused);
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r2.xCircleIcon);
  }
}
function MultiSelectComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 16);
    ɵɵtemplate(1, MultiSelectComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MultiSelectComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiSelectComponent_span_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 18);
    ɵɵlistener("mousedown", function MultiSelectComponent_span_7_Template_span_mousedown_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearAll($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiSelectComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 20);
  }
}
function MultiSelectComponent_kendo_separator_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiSelectComponent_span_10_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_span_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 21);
    ɵɵtemplate(1, MultiSelectComponent_span_10_ng_template_1_Template, 0, 0, "ng-template", 17);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function MultiSelectComponent_ng_template_11_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiSelectComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_11_ng_container_0_Template, 1, 0, "ng-container", 22);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(18);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiSelectComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 23);
    ɵɵlistener("resize", function MultiSelectComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function MultiSelectComponent_ng_template_17_0_ng_template_0_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_0_ng_template_0_Template, 0, 0, "ng-template", 26);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate.templateRef));
  }
}
function MultiSelectComponent_ng_template_17_div_3_ng_template_1_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_div_3_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiSelectComponent_ng_template_17_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, MultiSelectComponent_ng_template_17_div_3_ng_template_1_Template, 0, 0, "ng-template", 28)(2, MultiSelectComponent_ng_template_17_div_3_ng_template_2_Template, 2, 1, "ng-template", 29);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate ? ctx_r1.noDataTemplate.templateRef : void 0));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiSelectComponent_ng_template_17_4_ng_template_0_Template(rf, ctx) {
}
function MultiSelectComponent_ng_template_17_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_4_ng_template_0_Template, 0, 0, "ng-template", 26);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate.templateRef));
  }
}
function MultiSelectComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiSelectComponent_ng_template_17_0_Template, 1, 3, null, 7);
    ɵɵelementStart(1, "kendo-list", 24, 3);
    ɵɵlistener("pageChange", function MultiSelectComponent_ng_template_17_Template_kendo_list_pageChange_1_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, MultiSelectComponent_ng_template_17_div_3_Template, 3, 5, "div", 25)(4, MultiSelectComponent_ng_template_17_4_Template, 1, 3, null, 7);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("rounded", ctx_r1.rounded)("id", ctx_r1.listBoxId)("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ctx_r1.template)("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("multipleSelection", true)("virtual", ctx_r1.virtual)("checkboxes", ctx_r1.checkboxes)("isMultiselect", true)("isActionSheetExpanded", ctx_r1.isActionSheetExpanded)("showStickyHeader", ctx_r1.showStickyHeader)("customItemTemplate", ctx_r1.customItemTemplate)("text", ctx_r1.text)("allowCustom", ctx_r1.allowCustom);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c212 = ["header"];
var _c222 = ["headerTable"];
var _c232 = ["columnHeader"];
var _c242 = (a0, a1, a2) => ({
  templateRef: a0,
  $implicit: a1,
  column: a2
});
var _c252 = (a0, a1, a2, a3) => ({
  templateRef: a0,
  $implicit: a1,
  dataItem: a2,
  column: a3
});
function MultiColumnComboBoxComponent_span_2_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 22);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_span_2_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.prefixTemplate == null ? null : ctx_r1.prefixTemplate.templateRef);
  }
}
function MultiColumnComboBoxComponent_kendo_separator_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiColumnComboBoxComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 24);
    ɵɵlistener("click", function MultiColumnComboBoxComponent_span_5_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 25);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵproperty("kendoEventsOutsideAngular", ɵɵpureFunction1(5, _c172, ctx_r1.preventEventDefault));
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiColumnComboBoxComponent_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 26);
  }
}
function MultiColumnComboBoxComponent_kendo_separator_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "kendo-separator");
  }
}
function MultiColumnComboBoxComponent_span_8_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 27);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_span_8_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.suffixTemplate == null ? null : ctx_r1.suffixTemplate.templateRef);
  }
}
function MultiColumnComboBoxComponent_ng_template_12_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiColumnComboBoxComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_12_ng_container_0_Template, 1, 0, "ng-container", 28);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 29);
    ɵɵlistener("resize", function MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
function MultiColumnComboBoxComponent_ng_template_18_0_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_0_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_9_col_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "col");
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵstyleProp("width", column_r7.width, "px");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_container_9_col_1_Template, 1, 2, "col", 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r7 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r7.hidden && column_r7.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", column_r8.title || column_r8.field, " ");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("templateContext", ɵɵpureFunction3(1, _c242, column_r8.headerTemplate == null ? null : column_r8.headerTemplate.templateRef, column_r8, column_r8));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 42, 9);
    ɵɵtemplate(2, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_ng_container_2_Template, 2, 1, "ng-container", 13)(3, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_3_Template, 1, 5, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", column_r8.headerStyle)("ngClass", column_r8.headerClass);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !column_r8.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r8.headerTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_th_1_Template, 4, 4, "th", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r8 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r8.hidden && column_r8.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ɵɵnextContext(2).$implicit;
    const dataItem_r10 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.textFrom(dataItem_r10, column_r9.field), " ");
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_ng_template_0_Template, 0, 0, "ng-template", 39);
  }
  if (rf & 2) {
    const column_r9 = ɵɵnextContext(2).$implicit;
    const dataItem_r10 = ɵɵnextContext().$implicit;
    ɵɵproperty("templateContext", ɵɵpureFunction4(1, _c252, column_r9.cellTemplate == null ? null : column_r9.cellTemplate.templateRef, dataItem_r10, dataItem_r10, column_r9));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 44);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_ng_container_1_Template, 2, 1, "ng-container", 13)(2, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_2_Template, 1, 6, null, 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r10 = ɵɵnextContext();
    const column_r9 = ctx_r10.$implicit;
    const i_r12 = ctx_r10.index;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵstyleProp("width", ctx_r1.getColumnWidth(i_r12), "px")("max-width", ctx_r1.getColumnWidth(i_r12), "px");
    ɵɵproperty("ngClass", column_r9.class)("ngStyle", column_r9.style);
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r9.cellTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r9.cellTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_span_1_Template, 3, 8, "span", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r9 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !column_r9.hidden && column_r9.matchesMedia);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_ng_container_0_Template, 2, 1, "ng-container", 34);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngForOf", ctx_r1.columns);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_1_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_div_17_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 45);
    ɵɵtemplate(1, MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_1_Template, 0, 0, "ng-template", 46)(2, MultiColumnComboBoxComponent_ng_template_18_div_17_ng_template_2_Template, 2, 1, "ng-template", 47);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_18_ng_template_6_Template(rf, ctx) {
}
function MultiColumnComboBoxComponent_ng_template_18_ng_container_18_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 48)(2, "table", 49)(3, "tfoot", 50)(4, "tr", 36)(5, "td", 51);
    ɵɵtemplate(6, MultiColumnComboBoxComponent_ng_template_18_ng_container_18_ng_template_6_Template, 0, 0, "ng-template", 39);
    ɵɵelementEnd()()()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(6);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate.templateRef));
  }
}
function MultiColumnComboBoxComponent_ng_template_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiColumnComboBoxComponent_ng_template_18_0_Template, 1, 3, null, 13);
    ɵɵelementStart(1, "div", 30)(2, "div", 31, 4)(4, "div", 32, 5)(6, "table", 33, 6)(8, "colgroup");
    ɵɵtemplate(9, MultiColumnComboBoxComponent_ng_template_18_ng_container_9_Template, 2, 1, "ng-container", 34);
    ɵɵelementEnd();
    ɵɵelementStart(10, "thead", 35)(11, "tr", 36);
    ɵɵtemplate(12, MultiColumnComboBoxComponent_ng_template_18_ng_container_12_Template, 2, 1, "ng-container", 34);
    ɵɵelementEnd()()()()();
    ɵɵtemplate(13, MultiColumnComboBoxComponent_ng_template_18_ng_template_13_Template, 1, 1, "ng-template", null, 7, ɵɵtemplateRefExtractor);
    ɵɵelementStart(15, "kendo-list", 37, 8);
    ɵɵlistener("pageChange", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_pageChange_15_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.pageChange($event));
    })("listResize", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_listResize_15_listener() {
      ɵɵrestoreView(_r6);
      const header_r13 = ɵɵreference(3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.updateHeaderPadding(header_r13));
    })("popupListScroll", function MultiColumnComboBoxComponent_ng_template_18_Template_kendo_list_popupListScroll_15_listener($event) {
      ɵɵrestoreView(_r6);
      const headerWrap_r14 = ɵɵreference(5);
      return ɵɵresetView(headerWrap_r14.scrollLeft = $event.target.scrollLeft);
    });
    ɵɵelementEnd();
    ɵɵtemplate(17, MultiColumnComboBoxComponent_ng_template_18_div_17_Template, 3, 5, "div", 38)(18, MultiColumnComboBoxComponent_ng_template_18_ng_container_18_Template, 7, 3, "ng-container", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const rowTemplate_r15 = ɵɵreference(14);
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.tableSizeClass);
    ɵɵadvance(8);
    ɵɵproperty("ngForOf", ctx_r1.columns);
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", ctx_r1.columns);
    ɵɵadvance(3);
    ɵɵproperty("optionPrefix", ctx_r1.optionPrefix)("data", ctx_r1.data)("size", ctx_r1.isAdaptive ? "large" : ctx_r1.size)("textField", ctx_r1.textField)("valueField", ctx_r1.valueField)("template", ɵɵpureFunction1(21, _c152, rowTemplate_r15))("groupTemplate", ctx_r1.groupTemplate)("fixedGroupTemplate", ctx_r1.fixedGroupTemplate)("height", ctx_r1.listHeight)("show", ctx_r1.isOpen)("id", ctx_r1.listBoxId)("virtual", ctx_r1.virtual)("type", "dropdowngrid")("rowWidth", ctx_r1.rowWidth)("showStickyHeader", ctx_r1.showStickyHeader);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.data.length === 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
  }
}
var _c262 = ["treeview"];
var _c272 = ["filterInput"];
var _c282 = (a0) => ({
  blur: a0
});
function DropDownTreeComponent_span_2_1_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_span_2_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_span_2_1_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction2(1, _c511, ctx_r1.valueTemplate.templateRef, ctx_r1.dataItem));
  }
}
function DropDownTreeComponent_span_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵtextInterpolate1(" ", ctx_r1.text || ctx_r1.placeholder, " ");
  }
}
function DropDownTreeComponent_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtemplate(1, DropDownTreeComponent_span_2_1_Template, 1, 4, null, 15)(2, DropDownTreeComponent_span_2_ng_template_2_Template, 1, 1, "ng-template", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.valueTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.valueTemplate);
  }
}
function DropDownTreeComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 18);
    ɵɵlistener("click", function DropDownTreeComponent_span_3_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearValue($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("visibility", ctx_r1.clearButtonVisiblity);
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function DropDownTreeComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 20);
  }
}
function DropDownTreeComponent_ng_template_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function DropDownTreeComponent_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_7_ng_container_0_Template, 1, 0, "ng-container", 21);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(13);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function DropDownTreeComponent_ng_template_12_span_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 25)(1, "span", 26)(2, "span", 27);
    ɵɵelement(3, "kendo-icon-wrapper", 28);
    ɵɵelementEnd();
    ɵɵelementStart(4, "input", 29, 3);
    ɵɵlistener("input", function DropDownTreeComponent_ng_template_12_span_0_Template_input_input_4_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilterInputChange($event.target));
    })("keydown.arrowdown", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_arrowdown_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    })("keydown.alt.arrowup", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_alt_arrowup_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    })("keydown.escape", function DropDownTreeComponent_ng_template_12_span_0_Template_input_keydown_escape_4_listener($event) {
      ɵɵrestoreView(_r5);
      const filterInput_r6 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r6));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.filterable && !ctx_r1.touchEnabled)("value", ctx_r1.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(7, _c282, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function DropDownTreeComponent_ng_template_12_1_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_1_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-treeview", 30, 4);
    ɵɵtwoWayListener("selectedKeysChange", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectedKeysChange_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.selectedKeys, $event) || (ctx_r1.selectedKeys = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("focusout", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_focusout_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleBlur($event));
    })("keydown", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_keydown_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    })("selectionChange", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_selectionChange_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onSelectionChange($event));
    })("expand", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_expand_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.nodeExpand.emit($event));
    })("collapse", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_collapse_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.nodeCollapse.emit($event));
    })("childrenLoaded", function DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template_kendo_treeview_childrenLoaded_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onChildrenLoaded());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵstyleProp("max-height", ctx_r1.listHeight, "px");
    ɵɵproperty("size", ctx_r1.windowSize !== "large" ? "large" : ctx_r1.size)("nodes", ctx_r1.data)("animate", false);
    ɵɵtwoWayProperty("selectedKeys", ctx_r1.selectedKeys);
    ɵɵproperty("selectBy", ctx_r1.selectBy)("textField", ctx_r1.textField)("children", ctx_r1.children)("hasChildren", ctx_r1.hasChildren)("loadOnDemand", ctx_r1.loadOnDemand)("isExpanded", ctx_r1.isNodeExpanded)("isDisabled", ctx_r1.itemDisabled)("nodeTemplate", ctx_r1.nodeTemplate)("filter", ctx_r1.filter)("isVisible", ctx_r1.isNodeVisible);
    ɵɵattribute("id", ctx_r1.treeViewId);
  }
}
function DropDownTreeComponent_ng_template_12_3_ng_template_0_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_3_ng_template_0_Template, 0, 0, "ng-template", 17);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef));
  }
}
function DropDownTreeComponent_ng_template_12_div_4_ng_template_1_Template(rf, ctx) {
}
function DropDownTreeComponent_ng_template_12_div_4_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function DropDownTreeComponent_ng_template_12_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 31);
    ɵɵtemplate(1, DropDownTreeComponent_ng_template_12_div_4_ng_template_1_Template, 0, 0, "ng-template", 32)(2, DropDownTreeComponent_ng_template_12_div_4_ng_template_2_Template, 2, 1, "ng-template", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function DropDownTreeComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DropDownTreeComponent_ng_template_12_span_0_Template, 6, 9, "span", 22)(1, DropDownTreeComponent_ng_template_12_1_Template, 1, 3, null, 15)(2, DropDownTreeComponent_ng_template_12_kendo_treeview_2_Template, 2, 17, "kendo-treeview", 23)(3, DropDownTreeComponent_ng_template_12_3_Template, 1, 3, null, 15)(4, DropDownTreeComponent_ng_template_12_div_4_Template, 3, 5, "div", 24);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.data.length !== 0 && !ctx_r1.allNodesHidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.data.length === 0 || ctx_r1.allNodesHidden);
  }
}
function DropDownTreeComponent_kendo_resize_sensor_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 33);
    ɵɵlistener("resize", function DropDownTreeComponent_kendo_resize_sensor_14_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var _c292 = ["checkAllInput"];
var _c302 = (a0) => ({
  focusout: a0
});
function MultiSelectTreeComponent_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.placeholder, " ");
  }
}
function MultiSelectTreeComponent_span_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 15);
    ɵɵlistener("click", function MultiSelectTreeComponent_span_4_Template_span_click_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearAll($event));
    });
    ɵɵelement(1, "kendo-icon-wrapper", 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("title", ctx_r1.messageFor("clearTitle"));
    ɵɵadvance();
    ɵɵproperty("svgIcon", ctx_r1.xIcon);
  }
}
function MultiSelectTreeComponent_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 17);
  }
}
function MultiSelectTreeComponent_ng_template_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MultiSelectTreeComponent_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_6_ng_container_0_Template, 1, 0, "ng-container", 18);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const sharedPopupActionSheetTemplate_r4 = ɵɵreference(12);
    ɵɵproperty("ngTemplateOutlet", sharedPopupActionSheetTemplate_r4);
  }
}
function MultiSelectTreeComponent_ng_template_11_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24)(1, "span", 25)(2, "span", 26);
    ɵɵelement(3, "kendo-icon-wrapper", 27);
    ɵɵelementEnd();
    ɵɵelementStart(4, "input", 28, 4);
    ɵɵlistener("input", function MultiSelectTreeComponent_ng_template_11_div_0_Template_input_input_4_listener($event) {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleFilterInputChange($event.target));
    })("keydown", function MultiSelectTreeComponent_ng_template_11_div_0_Template_input_keydown_4_listener($event) {
      ɵɵrestoreView(_r6);
      const filterInput_r7 = ɵɵreference(5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event, filterInput_r7));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.filterInputClasses);
    ɵɵadvance(2);
    ɵɵproperty("svgIcon", ctx_r1.searchIcon);
    ɵɵadvance();
    ɵɵproperty("filterInput", ctx_r1.filterable && !ctx_r1.touchEnabled)("value", ctx_r1.filter)("kendoEventsOutsideAngular", ɵɵpureFunction1(7, _c282, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("aria-label", ctx_r1.messageFor("filterInputLabel"));
  }
}
function MultiSelectTreeComponent_ng_template_11_1_ng_template_0_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_1_ng_template_0_Template, 0, 0, "ng-template", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.headerTemplate == null ? null : ctx_r1.headerTemplate.templateRef));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 30)(1, "span", 31)(2, "input", 32, 5);
    ɵɵlistener("checkedItemsChange", function MultiSelectTreeComponent_ng_template_11_div_2_Template_input_checkedItemsChange_2_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleCheckedItemsChange($event));
    })("keydown", function MultiSelectTreeComponent_ng_template_11_div_2_Template_input_keydown_2_listener($event) {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    });
    ɵɵelementEnd()();
    ɵɵelementStart(4, "span", 33);
    ɵɵlistener("click", function MultiSelectTreeComponent_ng_template_11_div_2_Template_span_click_4_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggleCheckAll());
    })("mousedown", function MultiSelectTreeComponent_ng_template_11_div_2_Template_span_mousedown_4_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.preventDefault());
    });
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const treeview_r9 = ɵɵreference(4);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("checkAll", !ctx_r1.filterable && !ctx_r1.touchEnabled)("ngClass", ctx_r1.checkAllCheckboxClasses)("treeview", treeview_r9)("checkedItems", ctx_r1.checkedItems)("valueField", ctx_r1.valueField)("lastAction", ctx_r1.lastAction)("kendoEventsOutsideAngular", ɵɵpureFunction1(9, _c282, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", ctx_r1.messageFor("checkAllText"), " ");
  }
}
function MultiSelectTreeComponent_ng_template_11_5_ng_template_0_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_5_ng_template_0_Template, 0, 0, "ng-template", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("templateContext", ɵɵpureFunction1(1, _c152, ctx_r1.footerTemplate == null ? null : ctx_r1.footerTemplate.templateRef));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_6_ng_template_1_Template(rf, ctx) {
}
function MultiSelectTreeComponent_ng_template_11_div_6_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.messageFor("noDataText"));
  }
}
function MultiSelectTreeComponent_ng_template_11_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34);
    ɵɵtemplate(1, MultiSelectTreeComponent_ng_template_11_div_6_ng_template_1_Template, 0, 0, "ng-template", 35)(2, MultiSelectTreeComponent_ng_template_11_div_6_ng_template_2_Template, 2, 1, "ng-template", 36);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.noDataTemplate)("templateContext", ɵɵpureFunction1(3, _c152, ctx_r1.noDataTemplate == null ? null : ctx_r1.noDataTemplate.templateRef));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.noDataTemplate);
  }
}
function MultiSelectTreeComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵtemplate(0, MultiSelectTreeComponent_ng_template_11_div_0_Template, 6, 9, "div", 19)(1, MultiSelectTreeComponent_ng_template_11_1_Template, 1, 3, null, 20)(2, MultiSelectTreeComponent_ng_template_11_div_2_Template, 6, 11, "div", 21);
    ɵɵelementStart(3, "kendo-treeview", 22, 3);
    ɵɵlistener("keydown", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_keydown_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleKeydown($event));
    })("nodeClick", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_nodeClick_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleNodeClick($event));
    })("expand", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_expand_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeExpand.emit($event));
    })("collapse", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_collapse_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nodeCollapse.emit($event));
    })("checkedItemsChange", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_checkedItemsChange_3_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleCheckedItemsChange($event));
    })("childrenLoaded", function MultiSelectTreeComponent_ng_template_11_Template_kendo_treeview_childrenLoaded_3_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onChildrenLoaded());
    });
    ɵɵelementEnd();
    ɵɵtemplate(5, MultiSelectTreeComponent_ng_template_11_5_Template, 1, 3, null, 20)(6, MultiSelectTreeComponent_ng_template_11_div_6_Template, 3, 5, "div", 23);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.filterable && !ctx_r1.isActionSheetExpanded);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.checkAll);
    ɵɵadvance();
    ɵɵstyleProp("max-height", ctx_r1.listHeight, "px");
    ɵɵproperty("size", ctx_r1.windowSize !== "large" ? "large" : ctx_r1.size)("nodes", ctx_r1.data)("animate", false)("isHeterogeneous", ctx_r1.isHeterogeneous)("checkable", ctx_r1.checkableSettings)("checkedItems", ctx_r1.checkedItems)("valueField", ctx_r1.valueField)("textField", ctx_r1.textField)("children", ctx_r1.children)("hasChildren", ctx_r1.hasChildren)("isExpanded", ctx_r1.isNodeExpanded)("isDisabled", ctx_r1.itemDisabled)("nodeTemplate", ctx_r1.nodeTemplate)("loadOnDemand", ctx_r1.loadOnDemand)("filter", ctx_r1.filter)("isVisible", ctx_r1.isNodeVisible)("kendoEventsOutsideAngular", ɵɵpureFunction1(26, _c302, ctx_r1.handleBlur))("scope", ctx_r1);
    ɵɵattribute("id", ctx_r1.treeViewId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.footerTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.data || (ctx_r1.data == null ? null : ctx_r1.data.length) === 0 || ctx_r1.allNodesHidden);
  }
}
function MultiSelectTreeComponent_kendo_resize_sensor_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "kendo-resize-sensor", 37);
    ɵɵlistener("resize", function MultiSelectTreeComponent_kendo_resize_sensor_13_Template_kendo_resize_sensor_resize_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onResize());
    });
    ɵɵelementEnd();
  }
}
var packageMetadata4 = {
  name: "@progress/kendo-angular-dropdowns",
  productName: "Kendo UI for Angular",
  productCode: "KENDOUIANGULAR",
  productCodes: ["KENDOUIANGULAR"],
  publishDate: 1751463102,
  version: "19.2.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-angular-ui/my-license/"
};
var isPresent5 = (value) => value !== null && value !== void 0;
var isNumber2 = (value) => !isNaN(value);
var combineStr = (begin, end) => {
  return begin.concat(end.substr(end.toLowerCase().indexOf(begin.toLowerCase()) + begin.length));
};
var isArray2 = (value) => Array.isArray(value);
var isObject = (value) => isPresent5(value) && typeof value === "object";
var isEmptyString = (value) => typeof value === "string" && value.length === 0;
var resolveValuesInArray = (values, data = [], valueField) => values.map((value) => {
  return data.find((item) => getter2(item, valueField) === value);
}).filter((value) => value !== void 0);
var validateComplexValues = (values, valueField) => isArray2(values) && values.filter((item) => {
  return isObject(item) && getter2(item, valueField) !== void 0;
});
var resolveAllValues = (value, data, valueField) => {
  const customValues = validateComplexValues(value, valueField) || [];
  const resolvedValues = resolveValuesInArray(value, data, valueField) || [];
  return resolvedValues.concat(customValues);
};
var isObjectArray = (values) => {
  return isArray2(values) && values.every((item) => isObject(item));
};
var selectedIndices = (values, data, valueField) => {
  const extractedValues = data.map((item) => {
    return isPresent5(item) && isPresent5(getter2(item, valueField)) ? getter2(item, valueField) : item;
  });
  return values.reduce((arr, item) => {
    const value = isPresent5(item) && isPresent5(getter2(item, valueField)) ? getter2(item, valueField) : item;
    const index = extractedValues.indexOf(value);
    if (index !== -1) {
      arr.push(index);
    }
    return arr;
  }, []);
};
var getter2 = (dataItem, field) => {
  if (!isPresent5(dataItem)) {
    return null;
  }
  if (!isPresent5(field) || !isObject(dataItem)) {
    return dataItem;
  }
  const valueFrom2 = getter(field);
  return valueFrom2(dataItem);
};
var sameCharsOnly = (word, character) => {
  for (let idx = 0; idx < word.length; idx++) {
    if (word.charAt(idx) !== character) {
      return false;
    }
  }
  return true;
};
var shuffleData = (data, splitIndex, defaultItem) => {
  let result = data;
  if (defaultItem) {
    result = [defaultItem].concat(result);
  }
  return result.slice(splitIndex).concat(result.slice(0, splitIndex));
};
var matchText = (text, word, ignoreCase) => {
  if (!isPresent5(text)) {
    return false;
  }
  let temp = String(text);
  if (ignoreCase) {
    temp = temp.toLowerCase();
  }
  return temp.startsWith(word);
};
var hasProps = (obj, props) => {
  if (!isPresent5(obj)) {
    return false;
  }
  return props.every((prop) => obj.hasOwnProperty(prop));
};
var isUntouched2 = (element) => element.className.includes("ng-untouched");
var noop6 = (_) => {
};
var matches = (element, selector) => {
  const matcher = element.matches || element.msMatchesSelector || element.webkitMatchesSelector;
  if (!matcher) {
    return false;
  }
  return matcher.call(element, selector);
};
var closest4 = (element, selector) => {
  let parent = element;
  while (parent !== null && parent.nodeType === 1) {
    if (matches(parent, selector)) {
      return parent;
    }
    parent = parent.parentElement || parent.parentNode;
  }
  return null;
};
var parseNumber = (num, defaultValue = 0) => {
  const normalizedValue = Number(num);
  return isNaN(normalizedValue) ? defaultValue : normalizedValue;
};
var inDropDown = (host, target, popupRef) => {
  return host.nativeElement.contains(target) || popupRef && popupRef.popupElement.contains(target);
};
var getHierarchicalItemLevel = (index) => {
  return (index || "").split("_").length - 1;
};
var fetchDescendentNodes = (lookup, filterExpression) => {
  if (!isPresent5(lookup) || lookup.children.length === 0) {
    return [];
  }
  let descendants = lookup.children;
  if (isPresent5(filterExpression)) {
    descendants = descendants.filter((descendent) => filterExpression(descendent.item));
  }
  descendants.forEach((child) => descendants = descendants.concat(fetchDescendentNodes(child, filterExpression)));
  return descendants;
};
var valueFrom = ({
  dataItem,
  index,
  level
}, valueField) => {
  const fields = Array.isArray(valueField) ? valueField : [valueField];
  const valueLevel = isPresent5(level) ? level : getHierarchicalItemLevel(index);
  const normalizedLevel = Math.min(valueLevel, fields.length - 1);
  const field = fields[normalizedLevel];
  return getter(field)(dataItem);
};
var getSizeClass2 = (component, size) => {
  const SIZE_CLASSES = {
    "small": `k-${component}-sm`,
    "medium": `k-${component}-md`,
    "large": `k-${component}-lg`
  };
  return SIZE_CLASSES[size];
};
var getRoundedClass = (rounded) => {
  const ROUNDED_CLASSES = {
    "small": "k-rounded-sm",
    "medium": "k-rounded-md",
    "large": "k-rounded-lg",
    "full": "k-rounded-full"
  };
  return ROUNDED_CLASSES[rounded];
};
var getFillModeClass = (component, fillMode) => {
  const FILLMODE_CLASSES = {
    "solid": `k-${component}-solid`,
    "flat": `k-${component}-flat`,
    "outline": `k-${component}-outline`
  };
  return FILLMODE_CLASSES[fillMode];
};
var filterAndMap = (arr, predicate, mapper) => arr.reduce((acc, curr) => predicate(curr) ? [...acc, mapper(curr)] : acc, []);
var isJapanese2 = (input) => {
  const japaneseRegex = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
  return japaneseRegex.test(input);
};
var isLetter = (text) => {
  const isLetter2 = /[a-zA-Z]/;
  return isLetter2.test(text) && text?.length === 1;
};
var getSearchableItems = (treeViewId, element) => {
  const nodeSeletor = `kendo-treeview[id='${treeViewId}'] li.k-treeview-item`;
  const liElements = Array.from(element.querySelectorAll(nodeSeletor));
  return liElements.map((liElement) => {
    return {
      text: liElement.innerText,
      index: liElement.getAttribute("data-treeindex")
    };
  });
};
var isTruthy = (value) => !!value;
var setListBoxAriaLabelledBy = (optionsList, element, renderer) => {
  const listBox = optionsList.wrapper.nativeElement.querySelector("kendo-list ul");
  const ariaLabel = element.nativeElement.getAttribute("aria-labelledby") || element.nativeElement.getAttribute("data-kendo-label-id");
  if (ariaLabel) {
    renderer.setAttribute(listBox, "aria-labelledby", ariaLabel);
  }
};
var setActionSheetTitle = (element, actionSheetTitle) => {
  const ariaLabel = element.nativeElement.getAttribute("aria-labelledby") || element.nativeElement.getAttribute("data-kendo-label-id");
  if (!actionSheetTitle && ariaLabel) {
    return document.getElementById(ariaLabel).innerText;
  }
  return actionSheetTitle;
};
var animationDuration2 = 300;
var SearchBarComponent = class _SearchBarComponent {
  localization;
  injector;
  input;
  ngZone;
  direction;
  tagListId;
  set readonly(readonly) {
    this._readonly = readonly;
    if (this._readonly) {
      this.renderer.setAttribute(this.input.nativeElement, "readonly", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "readonly");
    }
  }
  get readonly() {
    return this._readonly;
  }
  set disabled(disabled) {
    this._disabled = disabled;
    if (this._disabled) {
      this.renderer.setAttribute(this.input.nativeElement, "disabled", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "disabled");
    }
  }
  get disabled() {
    return this._disabled;
  }
  set isRequired(isRequired) {
    this._isRequired = isRequired;
    if (this._isRequired) {
      this.renderer.setAttribute(this.input.nativeElement, "required", "");
    } else {
      this.renderer.removeAttribute(this.input.nativeElement, "required");
    }
  }
  get isRequired() {
    return this._isRequired;
  }
  set isSuggestable(isSuggestable) {
    this._isSuggestable = isSuggestable;
    this.setAriaAutocomplete();
  }
  get isSuggestable() {
    return this._isSuggestable;
  }
  set isFilterable(isFilterable) {
    this._isFilterable = isFilterable;
    this.setAriaAutocomplete();
  }
  get isFilterable() {
    return this._isFilterable;
  }
  get userInput() {
    return this._userInput;
  }
  set userInput(userInput) {
    this._userInput = userInput || "";
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  suggestedText;
  /**
   * @hidden
   */
  set inputAttributes(attributes) {
    if (isObjectPresent(this.parsedAttributes)) {
      removeHTMLAttributes(this.parsedAttributes, this.renderer, this.input.nativeElement);
    }
    this._inputAttributes = attributes;
    this.parsedAttributes = this.inputAttributes ? parseAttributes(this.inputAttributes, this.defaultAttributes) : this.inputAttributes;
    this.setInputAttributes();
  }
  get inputAttributes() {
    return this._inputAttributes;
  }
  id;
  activeDescendant;
  tabIndex;
  isLoading;
  ariaControls;
  ariaExpanded = null;
  get attrAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  set placeholder(text) {
    this._placeholder = text || "";
    this.setInputSize();
  }
  get placeholder() {
    return this._placeholder;
  }
  role = "combobox";
  get dir() {
    return this.direction;
  }
  valueChange = new EventEmitter();
  onBlur = new EventEmitter();
  onFocus = new EventEmitter();
  onClick = new EventEmitter();
  onNavigate = new EventEmitter();
  get value() {
    return this.input.nativeElement.value;
  }
  _isRequired;
  _readonly;
  _disabled;
  _userInput = "";
  _previousValue = "";
  _placeholder = "";
  _isSuggestable = false;
  _isFilterable = false;
  renderer;
  subs = new Subscription();
  _inputAttributes;
  parsedAttributes = {};
  get defaultAttributes() {
    return {
      id: this.id,
      disabled: this.disabled ? "" : null,
      readonly: this.readonly ? "" : null,
      placeholder: this.placeholder,
      tabIndex: this.tabIndex,
      tabindex: this.tabIndex,
      dir: this.direction,
      required: this.isRequired ? "" : null,
      "aria-haspopup": "listbox",
      "aria-expanded": this.ariaExpanded,
      "aria-controls": this.ariaControls,
      "aria-activedescendant": this.activeDescendant,
      "aria-busy": this.isLoading,
      "aria-invalid": this.formControl?.invalid
    };
  }
  get mutableAttributes() {
    return {
      autocomplete: "off",
      role: this.role,
      "aria-describedby": this.tagListId
    };
  }
  constructor(localization, renderer, injector, input, ngZone) {
    this.localization = localization;
    this.injector = injector;
    this.input = input;
    this.ngZone = ngZone;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.renderer = renderer;
    this.renderer.addClass(this.input.nativeElement, "k-input-inner");
    this.renderer.setAttribute(this.input.nativeElement, "aria-haspopup", "listbox");
    this.renderer.setAttribute(this.input.nativeElement, "autocomplete", "off");
  }
  ngOnInit() {
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => this.direction = rtl ? "rtl" : "ltr"));
  }
  ngOnChanges(changes) {
    if (!isDocumentAvailable()) {
      return;
    }
    let previousUserInput;
    if (this.input && (changes.userInput || changes.suggestedText)) {
      if (changes.userInput && changes.userInput.previousValue) {
        if (this._previousValue === changes.userInput.previousValue) {
          previousUserInput = this._previousValue;
        } else {
          previousUserInput = changes.userInput.currentValue || "";
        }
      } else {
        previousUserInput = this._previousValue;
      }
      const caretStart = this.input.nativeElement.selectionStart;
      const caretAtEnd = previousUserInput.length === caretStart;
      this.writeInputValue(this.suggestedText ? combineStr(this.userInput, this.suggestedText) : this.userInput);
      if (this.suggestedText) {
        this.setInputSelection(this.userInput.length, this.suggestedText.length);
      } else if (isSafari(navigator.userAgent) && !caretAtEnd) {
        this.setInputSelection(caretStart, this.userInput.length);
      } else if (caretAtEnd) {
        this.setInputSelection(this.userInput.length, this.userInput.length);
      } else {
        this.setInputSelection(caretStart, caretStart);
      }
      this._previousValue = this.userInput;
    }
  }
  ngAfterViewInit() {
    this.subs.add(this.input.nativeElement.addEventListener("input", (event) => this.handleInput(event)));
    this.subs.add(this.input.nativeElement.addEventListener("focus", (event) => this.handleFocus(event)));
    this.subs.add(this.input.nativeElement.addEventListener("blur", (event) => this.handleBlur(event)));
    this.subs.add(this.input.nativeElement.addEventListener("keydown", (event) => this.handleKeydown(event)));
  }
  ngOnDestroy() {
    this.subs.unsubscribe();
  }
  writeInputValue(text) {
    if (isDocumentAvailable()) {
      this.renderer.setProperty(this.input.nativeElement, "value", text);
    }
  }
  setInputSelection(start, end) {
    if (isDocumentAvailable() && this.input.nativeElement === document.activeElement) {
      try {
        this.input.nativeElement.setSelectionRange(start, end);
      } catch (e) {
      }
    }
  }
  setAriaAutocomplete() {
    if (this.isFilterable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "list");
    }
    if (this.isSuggestable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "inline");
    }
    if (this.isFilterable && this.isSuggestable) {
      this.renderer.setAttribute(this.input.nativeElement, "aria-autocomplete", "both");
    }
    if (!this.isFilterable && !this.isSuggestable) {
      this.renderer.removeAttribute(this.input.nativeElement, "aria-autocomplete");
    }
  }
  handleInput(event) {
    const target = event.target;
    const isBrowserSafari = isSafari(navigator.userAgent);
    const value = isBrowserSafari && isJapanese2(target.value) ? event.data : target.value;
    if (value !== this.userInput) {
      this._previousValue = value;
      this.valueChange.emit(value);
    }
  }
  handleFocus(event) {
    this.onFocus.emit(event);
  }
  handleBlur(event) {
    this.onBlur.emit(event);
  }
  handleKeydown(event) {
    const keyCode = event.keyCode;
    const keys = [Keys.ArrowUp, Keys.ArrowDown, Keys.ArrowLeft, Keys.ArrowRight, Keys.Enter, Keys.Escape, Keys.Delete, Keys.Backspace, Keys.Home, Keys.End, Keys.PageDown, Keys.PageUp];
    if (keys.indexOf(keyCode) > -1) {
      this.onNavigate.emit(event);
    }
  }
  focus() {
    if (isDocumentAvailable()) {
      this.input.nativeElement.focus();
    }
  }
  blur() {
    if (isDocumentAvailable()) {
      this.input.nativeElement.blur();
    }
  }
  setInputSize() {
    const lengthOf = (x) => x ? x.length : 0;
    const input = this.input.nativeElement;
    const placeholderLength = lengthOf(this.placeholder);
    const textLength = lengthOf(this.value);
    const size = Math.max(placeholderLength, textLength, 1);
    this.renderer.setAttribute(input, "size", size.toString());
  }
  setInputAttributes() {
    const attributesToRender = Object.assign({}, this.mutableAttributes, this.parsedAttributes);
    setHTMLAttributes(attributesToRender, this.renderer, this.input.nativeElement, this.ngZone);
  }
  static ɵfac = function SearchBarComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SearchBarComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _SearchBarComponent,
    selectors: [["input", "kendoSearchbar", ""]],
    hostVars: 10,
    hostBindings: function SearchBarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.id)("aria-activedescendant", ctx.activeDescendant)("tabindex", ctx.tabIndex)("aria-busy", ctx.isLoading)("aria-controls", ctx.ariaControls)("aria-expanded", ctx.ariaExpanded)("aria-invalid", ctx.attrAriaInvalid)("placeholder", ctx.placeholder)("role", ctx.role)("dir", ctx.dir);
      }
    },
    inputs: {
      tagListId: "tagListId",
      readonly: "readonly",
      disabled: "disabled",
      isRequired: "isRequired",
      isSuggestable: "isSuggestable",
      isFilterable: "isFilterable",
      userInput: "userInput",
      suggestedText: "suggestedText",
      inputAttributes: "inputAttributes",
      id: "id",
      activeDescendant: "activeDescendant",
      tabIndex: "tabIndex",
      isLoading: "isLoading",
      ariaControls: "ariaControls",
      ariaExpanded: "ariaExpanded",
      placeholder: "placeholder"
    },
    outputs: {
      valueChange: "valueChange",
      onBlur: "onBlur",
      onFocus: "onFocus",
      onClick: "onClick",
      onNavigate: "onNavigate"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    attrs: _c04,
    decls: 0,
    vars: 0,
    template: function SearchBarComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchBarComponent, [{
    type: Component,
    args: [{
      selector: "input[kendoSearchbar]",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    tagListId: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    isRequired: [{
      type: Input
    }],
    isSuggestable: [{
      type: Input
    }],
    isFilterable: [{
      type: Input
    }],
    userInput: [{
      type: Input
    }],
    suggestedText: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }, {
      type: Input
    }],
    activeDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }, {
      type: Input
    }],
    tabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }, {
      type: Input
    }],
    isLoading: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }, {
      type: Input
    }],
    ariaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }, {
      type: Input
    }],
    ariaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }, {
      type: Input
    }],
    attrAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    placeholder: [{
      type: HostBinding,
      args: ["attr.placeholder"]
    }, {
      type: Input
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    valueChange: [{
      type: Output
    }],
    onBlur: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    onClick: [{
      type: Output
    }],
    onNavigate: [{
      type: Output
    }]
  });
})();
var ItemTemplateDirective = class _ItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ItemTemplateDirective,
    selectors: [["", "kendoDropDownListItemTemplate", ""], ["", "kendoComboBoxItemTemplate", ""], ["", "kendoAutoCompleteItemTemplate", ""], ["", "kendoMultiSelectItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListItemTemplate],[kendoComboBoxItemTemplate],[kendoAutoCompleteItemTemplate],[kendoMultiSelectItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var HeaderTemplateDirective = class _HeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function HeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _HeaderTemplateDirective,
    selectors: [["", "kendoDropDownListHeaderTemplate", ""], ["", "kendoComboBoxHeaderTemplate", ""], ["", "kendoDropDownTreeHeaderTemplate", ""], ["", "kendoMultiColumnComboBoxHeaderTemplate", ""], ["", "kendoAutoCompleteHeaderTemplate", ""], ["", "kendoMultiSelectHeaderTemplate", ""], ["", "kendoMultiSelectTreeHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListHeaderTemplate],[kendoComboBoxHeaderTemplate],[kendoDropDownTreeHeaderTemplate],[kendoMultiColumnComboBoxHeaderTemplate],[kendoAutoCompleteHeaderTemplate],[kendoMultiSelectHeaderTemplate],[kendoMultiSelectTreeHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FooterTemplateDirective = class _FooterTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FooterTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FooterTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FooterTemplateDirective,
    selectors: [["", "kendoDropDownListFooterTemplate", ""], ["", "kendoComboBoxFooterTemplate", ""], ["", "kendoDropDownTreeFooterTemplate", ""], ["", "kendoMultiColumnComboBoxFooterTemplate", ""], ["", "kendoAutoCompleteFooterTemplate", ""], ["", "kendoMultiSelectFooterTemplate", ""], ["", "kendoMultiSelectTreeFooterTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListFooterTemplate],[kendoComboBoxFooterTemplate],[kendoDropDownTreeFooterTemplate],[kendoMultiColumnComboBoxFooterTemplate],[kendoAutoCompleteFooterTemplate],[kendoMultiSelectFooterTemplate],[kendoMultiSelectTreeFooterTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var GroupTemplateDirective = class _GroupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupTemplateDirective,
    selectors: [["", "kendoDropDownListGroupTemplate", ""], ["", "kendoComboBoxGroupTemplate", ""], ["", "kendoMultiColumnComboBoxGroupTemplate", ""], ["", "kendoAutoCompleteGroupTemplate", ""], ["", "kendoMultiSelectGroupTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListGroupTemplate],[kendoComboBoxGroupTemplate],[kendoMultiColumnComboBoxGroupTemplate],[kendoAutoCompleteGroupTemplate],[kendoMultiSelectGroupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FixedGroupTemplateDirective = class _FixedGroupTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function FixedGroupTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FixedGroupTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FixedGroupTemplateDirective,
    selectors: [["", "kendoDropDownListFixedGroupTemplate", ""], ["", "kendoComboBoxFixedGroupTemplate", ""], ["", "kendoMultiColumnComboBoxFixedGroupTemplate", ""], ["", "kendoAutoCompleteFixedGroupTemplate", ""], ["", "kendoMultiSelectFixedGroupTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FixedGroupTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListFixedGroupTemplate],[kendoComboBoxFixedGroupTemplate],[kendoMultiColumnComboBoxFixedGroupTemplate],[kendoAutoCompleteFixedGroupTemplate],[kendoMultiSelectFixedGroupTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DataService = class _DataService {
  grouped = false;
  groupIndices = [];
  view;
  _data;
  _flatData;
  set data(data) {
    this._data = data;
    this.grouped = this.isGrouped(data);
    if (this.grouped) {
      this.groupIndices = this.getGroupIndices(data);
      this._flatData = this.flatten(data);
    }
  }
  get data() {
    if (this.grouped) {
      return this._flatData;
    }
    return this._data;
  }
  /**
   * @hidden
   * Used to get the actual items count, i.e. excluding the header items in case of grouping.
   */
  get itemsCount() {
    if (!isPresent5(this.data) || this.data.length === 0) {
      return 0;
    }
    const items = this.grouped ? this._flatData.filter((item) => !item.header) : this.data;
    return items.length;
  }
  /**
   * @hidden
   * Used to determine if the component received grouped data.
   */
  isGrouped(data) {
    return isPresent5(data) && data.length !== 0 && isPresent5(data[0]) && hasProps(data[0], ["aggregates", "field", "items", "value"]);
  }
  /**
   * @hidden
   * Used to calculate the last item index of each group.
   */
  getGroupIndices(data) {
    const groupIndices = [];
    for (let i = 0; i <= data.length - 1; i++) {
      groupIndices[i] = (groupIndices[i - 1] || 0) + data[i].items.length;
    }
    return groupIndices;
  }
  /**
   * @hidden
   * Used to get a flat array containing all items matching certain criteria.
   */
  filter(predicate) {
    let result = [];
    if (this.isGrouped(this.data)) {
      for (let i = 0; i <= this.groupIndices.length - 1; i++) {
        const matches2 = this.data[i].items.filter(predicate);
        if (matches2) {
          result = result.concat(matches2);
        }
      }
    } else {
      result = this.data.filter(predicate);
    }
    return result;
  }
  /**
   * @hidden
   * Used to get the index of a given data item.
   */
  indexOf(item, startFrom = 0) {
    let predicate = (element) => {
      return element === item;
    };
    if (this.grouped) {
      predicate = (element) => {
        return element.value === item;
      };
    }
    return this.findIndex(predicate, startFrom);
  }
  /**
   * @hidden
   * Used to get the index of a data item based on an expression.
   */
  findIndex(predicate, startFrom = 0) {
    let index = -1;
    if (this.grouped) {
      const data = this._flatData.filter((item) => !item.header && item.offsetIndex >= startFrom);
      index = data.findIndex(predicate);
      index = data[index] ? data[index].offsetIndex : -1;
    } else {
      const data = this.data.slice(startFrom);
      const itemIndex = data.findIndex(predicate);
      index = itemIndex !== -1 ? itemIndex + startFrom : -1;
    }
    return index;
  }
  /**
   * @hidden
   * Used to get the closest group header prior to an item index.
   */
  closestGroup(index) {
    for (let i = index; i >= 0; i--) {
      if (this._flatData[i].header) {
        return this._flatData[i];
      }
    }
  }
  /**
   * @hidden
   * Used to get the first item matching the criteria.
   */
  find(predicate) {
    const index = this.findIndex(predicate);
    return this.itemAt(index);
  }
  /**
   * @hidden
   * Used to get the true index in a flattened data array.
   */
  flatIndex(index) {
    if (this.itemsCount === 0) {
      return -1;
    }
    if (this.grouped) {
      const match2 = this._flatData.find((item) => !item.header && item.offsetIndex === index);
      if (match2) {
        return match2.index;
      }
    } else {
      return index;
    }
    return -1;
  }
  /**
   * @hidden
   * Used to get the item at the provided index.
   */
  itemAt(index) {
    let dataItem;
    if (this.itemsCount === 0) {
      return dataItem;
    }
    if (this.grouped) {
      const match2 = this._flatData.find((item) => !item.header && item.offsetIndex === index);
      if (match2) {
        dataItem = match2.value;
      }
    } else {
      dataItem = this.data[index];
    }
    return dataItem;
  }
  /**
   * @hidden
   * Used to get the group at the provided index.
   */
  groupAt(index) {
    if (this.itemsCount === 0 || !this.isGrouped) {
      return;
    }
    return this._flatData.find((item) => item.header && item.index === index);
  }
  /**
   * @hidden
   * Used to get all group items indices.
   */
  groupItemsIndices() {
    if (this.isGrouped) {
      return filterAndMap(this.data, (item) => item.header, (mappedItem) => mappedItem.index);
    }
    return [];
  }
  /**
   * @hidden
   * Used to get the field by which the data is grouped.
   */
  groupField() {
    if (this.itemsCount === 0 || !this.isGrouped) {
      return null;
    }
    return this._data[0].field;
  }
  /**
   * @hidden
   * Used to get the group to which a dataItem belongs.
   */
  itemGroup(item) {
    if (!item || this.itemsCount === 0 || !this.isGrouped) {
      return;
    }
    const fieldName = this.groupField();
    if (fieldName) {
      return getter2(item, fieldName);
    }
  }
  flatten(data, group = void 0, offset = 0, groupIndex = 0) {
    let flat = [];
    if (isPresent5(group)) {
      flat.push({
        header: true,
        groupIndex,
        index: groupIndex + offset,
        offsetIndex: groupIndex,
        value: group
      });
    }
    for (let i = 0; i < data.length; i++) {
      let result = [];
      if (data[i].items) {
        result = this.flatten(data[i].items, data[i].value, offset, i);
        offset = offset + data[i].items.length;
      } else {
        result.push({
          header: false,
          groupIndex,
          index: groupIndex + offset + i + 1,
          offsetIndex: offset + i,
          value: data[i]
        });
      }
      flat = flat.concat(result);
    }
    return flat;
  }
  static ɵfac = function DataService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DataService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DataService,
    factory: _DataService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DataService, [{
    type: Injectable
  }], null, null);
})();
var DisabledItemsService = class _DisabledItemsService {
  dataService;
  defaultItem;
  itemDisabled = null;
  constructor(dataService) {
    this.dataService = dataService;
  }
  isIndexDisabled(index) {
    if (this.itemDisabled) {
      const item = this.dataService.itemAt(index);
      if (isPresent5(item)) {
        return this.itemDisabled({
          dataItem: item,
          index
        });
      } else if (isPresent5(this.defaultItem)) {
        return this.itemDisabled({
          dataItem: this.defaultItem,
          index: -1
        });
      }
    }
  }
  isItemDisabled(item) {
    if (this.itemDisabled) {
      const index = this.dataService.indexOf(item);
      if (index !== -1) {
        return this.itemDisabled({
          dataItem: item,
          index
        });
      } else if (isPresent5(this.defaultItem)) {
        return this.itemDisabled({
          dataItem: this.defaultItem,
          index: -1
        });
      }
    }
  }
  static ɵfac = function DisabledItemsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DisabledItemsService)(ɵɵinject(DataService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _DisabledItemsService,
    factory: _DisabledItemsService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisabledItemsService, [{
    type: Injectable
  }], function() {
    return [{
      type: DataService
    }];
  }, null);
})();
var SelectionService2 = class _SelectionService {
  disabledItemsService;
  onSelect = new EventEmitter();
  onChange = new EventEmitter();
  onFocus = new EventEmitter();
  total = 0;
  lastClickedIndex;
  selectedIndices = [];
  focusedIndex;
  constructor(disabledItemsService) {
    this.disabledItemsService = disabledItemsService;
  }
  getTotal() {
    return this.total;
  }
  isSelected(index) {
    return isPresent5(this.selectedIndices.find((current) => current === index));
  }
  isFocused(index) {
    return index === this.focused;
  }
  focus(index) {
    if (this.isFocused(index)) {
      return;
    }
    this.focused = index;
    this.onFocus.emit(index);
  }
  select(index) {
    if (this.isSelected(index)) {
      return;
    }
    this.selectedIndices = [index];
    this.focused = index;
    this.onSelect.emit({
      indices: [index],
      newSelection: isPresent5(index)
    });
  }
  add(index, preventClosingPopup) {
    if (this.isSelected(index)) {
      return;
    }
    this.selectedIndices.push(index);
    this.focused = index;
    this.onChange.emit({
      added: index,
      indices: this.selectedIndices.slice(),
      preventClosingPopup
    });
  }
  indicesToBeRemoved = [];
  indicesToBeAdded = [];
  emitMultipleAddedRemoved() {
    this.onChange.emit({
      added: this.indicesToBeAdded,
      removed: this.indicesToBeRemoved,
      indices: this.selectedIndices.slice(),
      preventClosingPopup: true,
      isMultipleSelection: true
    });
    this.indicesToBeAdded = [];
    this.indicesToBeRemoved = [];
  }
  addMultiple(indices) {
    this.indicesToBeAdded = indices.slice();
    this.selectedIndices.push(...indices);
  }
  deselect(index, preventClosingPopup) {
    if (!this.isSelected(index)) {
      return;
    }
    const position = this.selectedIndices.indexOf(index);
    this.selectedIndices.splice(position, 1);
    this.focused = index;
    if (this.selected.length === 0) {
      this.lastClickedIndex = null;
    }
    this.onChange.emit({
      indices: this.selectedIndices.slice(),
      removed: index,
      preventClosingPopup
    });
  }
  unselectMultiple(indices) {
    indices.forEach((index) => {
      const position = this.selectedIndices.indexOf(index);
      this.selectedIndices.splice(position, 1);
    });
    this.indicesToBeRemoved = indices.slice();
  }
  change(index) {
    const newSelection = isPresent5(index) && !this.isSelected(index);
    this.selectedIndices = [index];
    this.focused = index;
    this.onChange.emit({
      indices: [index],
      newSelection
    });
  }
  resetSelection(index) {
    this.selectedIndices = index instanceof Array ? index : [index];
    this.focused = this.selectedIndices[this.selectedIndices.length - 1];
  }
  get selected() {
    return this.selectedIndices.slice();
  }
  get focused() {
    return this.focusedIndex;
  }
  set focused(index) {
    if (this.focusedIndex !== index) {
      this.focusedIndex = index;
      this.onFocus.emit(index);
    }
  }
  selectFromTo(from, to) {
    const addedIndices = [];
    for (let i = from; i <= to; i++) {
      if (!this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {
        addedIndices.push(i);
      }
    }
    this.addMultiple(addedIndices);
  }
  unselectFromTo(from, to) {
    const indicesToBeUnselected = [];
    for (let i = from; i >= to; i--) {
      if (this.isSelected(i) && !this.disabledItemsService.isIndexDisabled(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    this.unselectMultiple(indicesToBeUnselected);
  }
  unselectNotNeededIndices(startOfSelection, endOfSelection, totalItems) {
    const indicesToBeUnselected = [];
    for (let i = 0; i < startOfSelection; i++) {
      if (this.isSelected(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    for (let i = endOfSelection + 1; i < totalItems; i++) {
      if (this.isSelected(i)) {
        indicesToBeUnselected.push(i);
      }
    }
    this.unselectMultiple(indicesToBeUnselected);
  }
  static ɵfac = function SelectionService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectionService)(ɵɵinject(DisabledItemsService));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _SelectionService,
    factory: _SelectionService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectionService2, [{
    type: Injectable
  }], function() {
    return [{
      type: DisabledItemsService
    }];
  }, null);
})();
var NavigationAction;
(function(NavigationAction2) {
  NavigationAction2[NavigationAction2["Undefined"] = 0] = "Undefined";
  NavigationAction2[NavigationAction2["Open"] = 1] = "Open";
  NavigationAction2[NavigationAction2["Close"] = 2] = "Close";
  NavigationAction2[NavigationAction2["Enter"] = 3] = "Enter";
  NavigationAction2[NavigationAction2["Tab"] = 4] = "Tab";
  NavigationAction2[NavigationAction2["Esc"] = 5] = "Esc";
  NavigationAction2[NavigationAction2["Delete"] = 6] = "Delete";
  NavigationAction2[NavigationAction2["Backspace"] = 7] = "Backspace";
  NavigationAction2[NavigationAction2["Home"] = 8] = "Home";
  NavigationAction2[NavigationAction2["End"] = 9] = "End";
  NavigationAction2[NavigationAction2["Up"] = 10] = "Up";
  NavigationAction2[NavigationAction2["Down"] = 11] = "Down";
  NavigationAction2[NavigationAction2["Left"] = 12] = "Left";
  NavigationAction2[NavigationAction2["Right"] = 13] = "Right";
  NavigationAction2[NavigationAction2["PageDown"] = 14] = "PageDown";
  NavigationAction2[NavigationAction2["PageUp"] = 15] = "PageUp";
  NavigationAction2[NavigationAction2["SelectPrevious"] = 16] = "SelectPrevious";
  NavigationAction2[NavigationAction2["SelectNext"] = 17] = "SelectNext";
  NavigationAction2[NavigationAction2["SelectAll"] = 18] = "SelectAll";
  NavigationAction2[NavigationAction2["SelectAllToBeginning"] = 19] = "SelectAllToBeginning";
  NavigationAction2[NavigationAction2["SelectAllToEnd"] = 20] = "SelectAllToEnd";
})(NavigationAction || (NavigationAction = {}));
var MIN_INDEX = 0;
var NavigationEvent = class {
  index;
  originalEvent;
  /**
   * The index of the item to which the user navigated.
   */
  constructor(index, originalEvent) {
    this.index = index;
    this.originalEvent = originalEvent;
  }
};
var NavigationService2 = class _NavigationService {
  disabledItemsService;
  selectionService;
  open = new EventEmitter();
  close = new EventEmitter();
  enter = new EventEmitter();
  tab = new EventEmitter();
  esc = new EventEmitter();
  up = new EventEmitter();
  right = new EventEmitter();
  down = new EventEmitter();
  left = new EventEmitter();
  delete = new EventEmitter();
  backspace = new EventEmitter();
  home = new EventEmitter();
  end = new EventEmitter();
  pagedown = new EventEmitter();
  pageup = new EventEmitter();
  selectnext = new EventEmitter();
  selectprevious = new EventEmitter();
  selectall = new EventEmitter();
  selectalltobeginning = new EventEmitter();
  selectalltoend = new EventEmitter();
  constructor(disabledItemsService, selectionService) {
    this.disabledItemsService = disabledItemsService;
    this.selectionService = selectionService;
  }
  process(args) {
    const keyCode = args.originalEvent.keyCode;
    const altKey = args.originalEvent.altKey;
    const shiftKey = args.originalEvent.shiftKey;
    const ctrlKey = args.originalEvent.ctrlKey || args.originalEvent.metaKey;
    const openOnSpace = args.openOnSpace;
    const closeOnSpace = args.closeOnSpace;
    let index;
    let action = NavigationAction.Undefined;
    if (altKey && keyCode === Keys.ArrowDown) {
      action = NavigationAction.Open;
    } else if (openOnSpace && keyCode === Keys.Space) {
      action = NavigationAction.Open;
    } else if (altKey && keyCode === Keys.ArrowUp) {
      action = NavigationAction.Close;
    } else if (closeOnSpace && keyCode === Keys.Space) {
      action = NavigationAction.Close;
    } else if (shiftKey && keyCode === Keys.ArrowUp) {
      action = NavigationAction.SelectPrevious;
    } else if (shiftKey && keyCode === Keys.ArrowDown) {
      action = NavigationAction.SelectNext;
    } else if (ctrlKey && keyCode === Keys.KeyA) {
      action = NavigationAction.SelectAll;
    } else if (ctrlKey && shiftKey && keyCode === Keys.Home) {
      action = NavigationAction.SelectAllToBeginning;
    } else if (ctrlKey && shiftKey && keyCode === Keys.End) {
      action = NavigationAction.SelectAllToEnd;
    } else if (keyCode === Keys.Enter) {
      action = NavigationAction.Enter;
    } else if (keyCode === Keys.Escape) {
      action = NavigationAction.Esc;
    } else if (keyCode === Keys.Tab) {
      action = NavigationAction.Tab;
    } else if (keyCode === Keys.ArrowUp) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: -1
      });
      action = NavigationAction.Up;
    } else if (keyCode === Keys.ArrowLeft) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: -1
      });
      action = NavigationAction.Left;
    } else if (keyCode === Keys.ArrowDown) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: 1
      });
      action = NavigationAction.Down;
    } else if (keyCode === Keys.ArrowRight) {
      index = this.next({
        current: args.current,
        start: args.min,
        end: args.max,
        step: 1
      });
      action = NavigationAction.Right;
    } else if (keyCode === Keys.Home) {
      index = this.isDisabled(MIN_INDEX) ? args.current : MIN_INDEX;
      action = NavigationAction.Home;
    } else if (keyCode === Keys.End) {
      index = this.isDisabled(args.max) ? args.current : args.max;
      action = NavigationAction.End;
    } else if (keyCode === Keys.Delete) {
      action = NavigationAction.Delete;
    } else if (keyCode === Keys.Backspace) {
      action = NavigationAction.Backspace;
    } else if (keyCode === Keys.PageDown) {
      action = NavigationAction.PageDown;
    } else if (keyCode === Keys.PageUp) {
      action = NavigationAction.PageUp;
    }
    const eventData = new NavigationEvent(index, args.originalEvent);
    if (action !== NavigationAction.Undefined) {
      this[NavigationAction[action].toLowerCase()].emit(eventData);
    }
    return action;
  }
  next(args) {
    const {
      current,
      start,
      end,
      step
    } = args;
    const nextIndex = !isPresent5(current) ? start : this.clampIndex(current + step, start, end);
    const firstFocusableIndex = this.firstFocusableIndex(nextIndex, start, end, step);
    if (isPresent5(firstFocusableIndex)) {
      return firstFocusableIndex;
    }
    if (this.selectionService.isSelected(current) && current >= start) {
      return current;
    }
    const inversedStep = -1 * step;
    return this.firstFocusableIndex(nextIndex, start, end, inversedStep);
  }
  clampIndex(index, min, max) {
    if (!isPresent5(index) || index < min) {
      return min;
    }
    if (index > max) {
      return max;
    }
    return index;
  }
  firstFocusableIndex(startIndex, min, max, step) {
    while (min <= startIndex && startIndex <= max) {
      if (!this.isDisabled(startIndex)) {
        return startIndex;
      }
      startIndex += step;
    }
    return void 0;
  }
  isDisabled(index) {
    if (this.disabledItemsService) {
      return this.disabledItemsService.isIndexDisabled(index);
    }
  }
  static ɵfac = function NavigationService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationService)(ɵɵinject(DisabledItemsService), ɵɵinject(SelectionService2));
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _NavigationService,
    factory: _NavigationService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService2, [{
    type: Injectable
  }], function() {
    return [{
      type: DisabledItemsService
    }, {
      type: SelectionService2
    }];
  }, null);
})();
var NoDataTemplateDirective = class _NoDataTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NoDataTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoDataTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NoDataTemplateDirective,
    selectors: [["", "kendoDropDownListNoDataTemplate", ""], ["", "kendoDropDownTreeNoDataTemplate", ""], ["", "kendoComboBoxNoDataTemplate", ""], ["", "kendoMultiColumnComboBoxNoDataTemplate", ""], ["", "kendoAutoCompleteNoDataTemplate", ""], ["", "kendoMultiSelectNoDataTemplate", ""], ["", "kendoMultiSelectTreeNoDataTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoDataTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListNoDataTemplate],[kendoDropDownTreeNoDataTemplate],[kendoComboBoxNoDataTemplate],[kendoMultiColumnComboBoxNoDataTemplate],[kendoAutoCompleteNoDataTemplate],[kendoMultiSelectNoDataTemplate],[kendoMultiSelectTreeNoDataTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var PreventableEvent3 = class {
  prevented = false;
  /**
   * Prevents the default action for a specified event.
   * In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * If the event is prevented by any of its subscribers, returns `true`.
   *
   * @returns `true` if the default action was prevented. Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};
var FilterableComponent = class {
  /**
   * Sets the data of the component.
   */
  data;
  /**
   * Explicitly enables the emitting of the `filterChange` event.
   */
  filterable;
  /**
   * Hooks to the `filter` event.
   */
  filterChange;
  /**
   * Reads the data from the components with complex data.
   */
  textField;
  /**
   * Reads the data from the components with complex data which use `valueField` instead of
   * `textField`&mdash;for example, the AutoComplete.
   */
  valueField;
};
var ListItemDirective = class _ListItemDirective {
  element;
  constructor(element) {
    this.element = element;
  }
  static ɵfac = function ListItemDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListItemDirective)(ɵɵdirectiveInject(ElementRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ListItemDirective,
    selectors: [["li", "role", "option"], ["li", "role", "group"]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListItemDirective, [{
    type: Directive,
    args: [{
      selector: '"li[role=option], li[role=group]"',
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var SelectableDirective = class _SelectableDirective {
  index;
  checkboxes = {
    enabled: false
  };
  height;
  isMultiselect;
  multipleSelection = false;
  selectionService;
  constructor(selectionService) {
    this.selectionService = selectionService;
  }
  get focusedClassName() {
    return this.selectionService.isFocused(this.index);
  }
  get selectedClassName() {
    return !this.checkboxes.enabled && this.selectionService.isSelected(this.index);
  }
  onClick(event) {
    event.stopPropagation();
    this.selectionService.lastClickedIndex = this.index;
    if (this.checkboxes.enabled && !this.checkboxes.checkOnClick) {
      return;
    }
    if (this.multipleSelection) {
      if (this.selectionService.isSelected(this.index)) {
        this.selectionService.deselect(this.index);
      } else {
        this.selectionService.add(this.index);
      }
    } else {
      this.selectionService.change(this.index);
    }
  }
  static ɵfac = function SelectableDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SelectableDirective)(ɵɵdirectiveInject(SelectionService2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SelectableDirective,
    selectors: [["", "kendoDropDownsSelectable", ""]],
    hostVars: 9,
    hostBindings: function SelectableDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("click", function SelectableDirective_click_HostBindingHandler($event) {
          return ctx.onClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("index", ctx.index);
        ɵɵstyleProp("height", ctx.height, "px")("min-height", ctx.height, "px");
        ɵɵclassProp("k-focus", ctx.focusedClassName)("k-selected", ctx.selectedClassName);
      }
    },
    inputs: {
      index: "index",
      checkboxes: "checkboxes",
      height: "height",
      isMultiselect: "isMultiselect",
      multipleSelection: "multipleSelection"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectableDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownsSelectable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: SelectionService2
    }];
  }, {
    index: [{
      type: HostBinding,
      args: ["attr.index"]
    }, {
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    height: [{
      type: HostBinding,
      args: ["style.height.px"]
    }, {
      type: HostBinding,
      args: ["style.minHeight.px"]
    }, {
      type: Input
    }],
    isMultiselect: [{
      type: Input
    }],
    multipleSelection: [{
      type: Input
    }],
    focusedClassName: [{
      type: HostBinding,
      args: ["class.k-focus"]
    }],
    selectedClassName: [{
      type: HostBinding,
      args: ["class.k-selected"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var CustomItemTemplateDirective = class _CustomItemTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function CustomItemTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomItemTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CustomItemTemplateDirective,
    selectors: [["", "kendoMultiSelectCustomItemTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomItemTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectCustomItemTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ListComponent = class _ListComponent {
  dataService;
  wrapper;
  selectionService;
  disabledItemsService;
  cdr;
  zone;
  renderer;
  selected = [];
  focused = -1;
  textField;
  valueField;
  height;
  template;
  groupTemplate;
  fixedGroupTemplate;
  show = true;
  id;
  optionPrefix;
  multipleSelection = false;
  virtual;
  type = "list";
  checkboxes = {
    enabled: false
  };
  ariaLive;
  isMultiselect;
  isActionSheetExpanded;
  showStickyHeader;
  rowWidth;
  customItemTemplate;
  text;
  allowCustom;
  defaultItem;
  set data(data) {
    this._data = data[0] && data[0].header ? data.slice(0) : data;
  }
  get data() {
    return this._data;
  }
  set size(size) {
    if (this.type === "list") {
      this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("list", this.size));
      if (size) {
        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("list", size));
      }
      this._size = size;
    }
  }
  get size() {
    return this._size;
  }
  rounded = "medium";
  onClick = new EventEmitter();
  pageChange = new EventEmitter();
  listResize = new EventEmitter();
  popupListScroll = new EventEmitter();
  items;
  content;
  list;
  virtualContainer;
  currentGroup;
  startFrom = 0;
  lastLoaded = 0;
  lastScrollTop = 0;
  listContentClass;
  listClass;
  listItemClass;
  listVirtualClass;
  listGroupStickyHeaderClass;
  listGroupStickyHeaderTextClass;
  listGroupItemClass;
  listGroupItemTextClass;
  scrollToFocused = false;
  _data;
  scrollSubscription;
  selectSubscription;
  _size = "medium";
  get pageSize() {
    if (this.virtual.pageSize) {
      return this.virtual.pageSize;
    }
    const size = Math.round(this.height / this.virtual.itemHeight);
    return size;
  }
  get scrollHeight() {
    return this.virtual.total * this.virtual.itemHeight;
  }
  get overflowY() {
    if (isPresent5(this.virtual)) {
      const overflow = this.hasVirtualScrollbar() ? "scroll" : "hidden";
      return overflow;
    }
  }
  /**
   * @hidden
   */
  get checkboxClasses() {
    return `${this.size ? getSizeClass2("checkbox", this.size) : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /* tslint:disable:member-ordering */
  constructor(dataService, wrapper, selectionService, disabledItemsService, cdr, zone, renderer) {
    this.dataService = dataService;
    this.wrapper = wrapper;
    this.selectionService = selectionService;
    this.disabledItemsService = disabledItemsService;
    this.cdr = cdr;
    this.zone = zone;
    this.renderer = renderer;
    this.selectSubscription = merge(this.selectionService.onSelect.pipe(map((args) => args.indices[0])), this.selectionService.onFocus).pipe(
      // handle only the very last onSelect/onFocus emission
      switchMap((event) => this.zone.onStable.pipe(take(1), map(() => event)))
    ).subscribe(this.scrollToItem.bind(this));
    this.prepareClasses();
  }
  ngOnChanges(changes) {
    if (isChanged("data", changes, false)) {
      if (this.lastLoaded <= 0) {
        this.lastLoaded = this.data.length - 1;
        this.scrollToFocused = !changes["data"].isFirstChange();
      }
      this.setOverflow();
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        this.setGroupAttributes();
      });
    }
    if (isChanged("virtual", changes, false)) {
      this.setOverflow();
    }
    if (isChanged("type", changes, false)) {
      this.prepareClasses();
    }
  }
  ngAfterViewInit() {
    this.setComponentClasses();
    this.zone.runOutsideAngular(() => {
      this.scrollSubscription = fromEvent(this.content.nativeElement, "scroll").pipe(auditTime(100), tap(this.prefetchData.bind(this)), tap(this.findCurrentGroup.bind(this))).subscribe(() => {
        this.lastScrollTop = this.content.nativeElement.scrollTop;
      });
    });
    this.setGroupAttributes();
    this.setOverflow();
  }
  setGroupAttributes() {
    const liItems = document.querySelectorAll("li");
    let isGroup;
    let childrenliItemsIds = [];
    let firstGroupReached = false;
    let previousGroup;
    liItems.forEach((li, idx) => {
      isGroup = li.getAttribute("role") === "group";
      if (!isGroup && firstGroupReached) {
        this.renderer.setAttribute(li, "aria-describedby", previousGroup.getAttribute("id"));
        childrenliItemsIds.push(li.getAttribute("id"));
        if (idx + 1 >= liItems.length || liItems[idx + 1]?.getAttribute("role") === "group") {
          this.renderer.setAttribute(previousGroup, "aria-owns", childrenliItemsIds.join(" "));
          childrenliItemsIds = [];
        }
      }
      if (isGroup) {
        firstGroupReached = true;
        previousGroup = li;
      }
    });
  }
  ngAfterViewChecked() {
    if (this.virtual) {
      this.positionItems();
    }
    if (this.items && this.scrollToFocused) {
      this.scrollToFocused = false;
      const scrollTarget = this.items.length && this.selectionService.focused === -1 ? 0 : this.selectionService.focused;
      this.scrollToItem(scrollTarget);
    }
    if (this.dataService.grouped) {
      this.findCurrentGroup();
    }
  }
  ngOnDestroy() {
    this.selectSubscription.unsubscribe();
    if (this.scrollSubscription) {
      this.scrollSubscription.unsubscribe();
    }
  }
  onCheckedChange(e, index) {
    const isChecked2 = e.target["checked"];
    if (isChecked2 && !this.selectionService.isSelected(index)) {
      this.selectionService.add(index);
    }
    if (!isChecked2 && this.selectionService.isSelected(index)) {
      this.selectionService.deselect(index);
    }
  }
  prepareClasses() {
    if (this.type === "list") {
      this.listContentClass = "k-list-content";
      this.listClass = "k-list-ul";
      this.listItemClass = "k-list-item";
      this.listVirtualClass = "k-virtual-list";
      this.listGroupStickyHeaderClass = "k-list-group-sticky-header";
      this.listGroupStickyHeaderTextClass = "k-list-header-text";
      this.listGroupItemClass = "k-list-group-item";
      this.listGroupItemTextClass = "k-list-item-text";
    } else {
      this.listContentClass = "k-table-body k-table-scroller";
      this.listClass = "k-table k-table-list";
      this.listItemClass = "k-table-row";
      this.listVirtualClass = "k-virtual-table";
      this.listGroupStickyHeaderClass = "k-table-group-sticky-header";
      this.listGroupStickyHeaderTextClass = "k-table-th";
      this.listGroupItemClass = "k-table-group-row";
      this.listGroupItemTextClass = "k-table-th";
    }
  }
  isChecked(index) {
    const normalizedIndex = this.virtual ? index + this.virtual.skip : index;
    return this.selectionService.isSelected(normalizedIndex);
  }
  firstVisibleItem() {
    const content = this.content.nativeElement;
    const rect = content.getBoundingClientRect();
    const disabled = Array.prototype.slice.call(content.querySelectorAll(".k-disabled"));
    disabled.forEach((el) => this.renderer.setStyle(el, "pointer-events", "auto"));
    const item = document.elementFromPoint(rect.left + 1, rect.top + 1);
    disabled.forEach((el) => this.renderer.setStyle(el, "pointer-events", "none"));
    return closest4(item, "li");
  }
  findCurrentGroup() {
    if (!this.dataService.grouped) {
      this.currentGroup = void 0;
      return;
    }
    const item = this.firstVisibleItem();
    if (item) {
      let index;
      if (item.getAttribute("role") === "group") {
        index = parseInt(item.getAttribute("group-index"), 10);
        this.currentGroup = this.dataService.groupAt(index)?.value;
      } else {
        index = parseInt(item.getAttribute("index"), 10);
        this.currentGroup = this.dataService.itemGroup(this.dataService.itemAt(index));
      }
    } else {
      this.currentGroup = void 0;
    }
    this.cdr.detectChanges();
  }
  prefetchData() {
    if (!this.virtual) {
      return;
    }
    const visibleItems = Math.trunc(this.content.nativeElement.clientHeight / this.virtual.itemHeight);
    const offsetY = this.content.nativeElement.scrollTop;
    const start = Math.trunc(offsetY / this.virtual.itemHeight);
    const down = offsetY > this.lastScrollTop;
    const nextPage = start + visibleItems >= this.lastLoaded && this.lastLoaded < this.virtual.total - 1;
    const leftOver = this.pageSize - (this.lastLoaded - this.startFrom);
    const prevPage = this.lastLoaded - this.pageSize + visibleItems >= start - leftOver;
    if (down && nextPage) {
      this.changePage(start);
    }
    if (!down && prevPage) {
      this.changePage(start - this.pageSize + visibleItems + 1);
    }
  }
  changePage(start) {
    this.zone.run(() => {
      let end = this.pageSize + start;
      if (end > this.virtual.total) {
        start--;
        end = this.virtual.total;
      }
      if (start < 0) {
        start = 0;
      }
      this.startFrom = start;
      this.lastLoaded = end;
      this.pageChange.emit({
        skip: start,
        take: this.pageSize
      });
    });
    this.setGroupAttributes();
  }
  index(groupIndex, itemIndex) {
    return groupIndex > 0 ? this.dataService.groupIndices[groupIndex - 1] + itemIndex : itemIndex;
  }
  getText(dataItem) {
    return getter2(dataItem, this.textField);
  }
  getValue(dataItem) {
    return getter2(dataItem, this.valueField);
  }
  isDisabled(index) {
    if (isPresent5(this.virtual) && !this.dataService.grouped) {
      index += this.virtual.skip;
    }
    return this.disabledItemsService.isIndexDisabled(index);
  }
  isAltRow(index) {
    return this.type === "dropdowngrid" && index % 2 !== 0;
  }
  scrollToItem(index) {
    let flatIndex = index;
    if (this.dataService.grouped) {
      flatIndex = this.dataService.flatIndex(index);
    }
    if (this.virtual && flatIndex > -1) {
      this.scrollToIndex(flatIndex);
      return;
    }
    const items = this.items.toArray();
    if (isPresent5(items[flatIndex]) && flatIndex !== -1) {
      this.scroll(items[flatIndex].element);
    }
  }
  scrollWithOnePage(action) {
    const content = this.content.nativeElement;
    const contentOffsetHeight = content.clientHeight;
    if (action === NavigationAction.PageDown) {
      content.scrollTop += contentOffsetHeight;
    } else if (action === NavigationAction.PageUp) {
      content.scrollTop -= contentOffsetHeight;
    }
  }
  scrollToIndex(index) {
    const content = this.content.nativeElement;
    let contentScrollTop = content.scrollTop;
    const itemOffsetTop = index * this.virtual.itemHeight;
    const itemOffsetHeight = this.virtual.itemHeight;
    const contentOffsetHeight = content.clientHeight;
    const bottomDistance = itemOffsetTop + itemOffsetHeight;
    if (contentScrollTop > itemOffsetTop) {
      contentScrollTop = itemOffsetTop;
    } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {
      contentScrollTop = bottomDistance - contentOffsetHeight;
    }
    content.scrollTop = contentScrollTop;
  }
  scroll(item) {
    if (!item) {
      return;
    }
    const nativeElement = item.nativeElement;
    const content = this.content.nativeElement;
    const itemOffsetTop = nativeElement.offsetTop;
    const itemOffsetHeight = nativeElement.offsetHeight;
    let contentScrollTop = content.scrollTop;
    const contentOffsetHeight = content.clientHeight;
    const bottomDistance = itemOffsetTop + itemOffsetHeight;
    if (contentScrollTop > itemOffsetTop) {
      contentScrollTop = itemOffsetTop;
    } else if (bottomDistance > contentScrollTop + contentOffsetHeight) {
      contentScrollTop = bottomDistance - contentOffsetHeight;
    }
    content.scrollTop = contentScrollTop;
  }
  /**
   * Indicates whether a scrollbar is currently rendered in the list.
   */
  hasScrollbar() {
    if (!(isPresent5(this.items) && this.items.length && isPresent5(this.list) && isPresent5(this.content))) {
      return false;
    }
    const hasVirtualScroll = isPresent5(this.virtual) && this.hasVirtualScrollbar();
    return hasVirtualScroll || this.list.nativeElement.scrollHeight > this.content.nativeElement.offsetHeight;
  }
  isItemSelected(index) {
    return this.selectionService.isSelected(index) || null;
  }
  get isDisabledDefaultItem() {
    return this.disabledItemsService.isItemDisabled(this.defaultItem);
  }
  getDefaultItemText() {
    return getter2(this.defaultItem, this.textField);
  }
  /**
   * Sets the list's content overflow (hides/shows scrollbar)
   */
  setOverflow() {
    if (this.virtual) {
      const overflow = this.hasVirtualScrollbar() ? "scroll" : "hidden";
      this.renderer.setStyle(this.content.nativeElement, "overflow-y", overflow);
    }
  }
  /**
   * Indicates whether the scrollbar should be visible in virtual mode.
   */
  hasVirtualScrollbar() {
    const contentOffsetHeight = this.content.nativeElement.offsetHeight;
    const virtualOffsetHeight = this.virtualContainer && this.virtualContainer.nativeElement.offsetHeight;
    return this.virtualContainer && virtualOffsetHeight > contentOffsetHeight;
  }
  positionItems() {
    this.items.forEach((item, index) => {
      const offsetY = (index + this.startFrom) * this.virtual.itemHeight;
      this.renderer.setStyle(item.element.nativeElement, "transform", `translateY(${offsetY}px`);
    });
  }
  /**
   * Indicates whether the first group header from the data set is in the targeted virtual page.
   */
  firstGroupHeaderInTargetedPage(itemIndex) {
    if (!isPresent5(this.virtual)) {
      return true;
    }
    return this.virtual.skip === 0 && this.virtual.pageSize > itemIndex;
  }
  setComponentClasses() {
    if (this.type === "list") {
      this.renderer.addClass(this.wrapper.nativeElement, "k-list");
      if (this.size) {
        this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("list", this.size));
      }
    }
    if (this.type === "dropdowngrid") {
      this.renderer.setStyle(this.wrapper.nativeElement, "overflow-y", "scroll");
    }
    if (isPresent5(this.virtual)) {
      this.renderer.addClass(this.wrapper.nativeElement, this.listVirtualClass);
    }
  }
  static ɵfac = function ListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ListComponent)(ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ListComponent,
    selectors: [["kendo-list"]],
    viewQuery: function ListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c111, 7);
        ɵɵviewQuery(_c211, 7);
        ɵɵviewQuery(_c311, 5);
        ɵɵviewQuery(ListItemDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.list = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.virtualContainer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
      }
    },
    inputs: {
      selected: "selected",
      focused: "focused",
      textField: "textField",
      valueField: "valueField",
      height: "height",
      template: "template",
      groupTemplate: "groupTemplate",
      fixedGroupTemplate: "fixedGroupTemplate",
      show: "show",
      id: "id",
      optionPrefix: "optionPrefix",
      multipleSelection: "multipleSelection",
      virtual: "virtual",
      type: "type",
      checkboxes: "checkboxes",
      ariaLive: "ariaLive",
      isMultiselect: "isMultiselect",
      isActionSheetExpanded: "isActionSheetExpanded",
      showStickyHeader: "showStickyHeader",
      rowWidth: "rowWidth",
      customItemTemplate: "customItemTemplate",
      text: "text",
      allowCustom: "allowCustom",
      defaultItem: "defaultItem",
      data: "data",
      size: "size",
      rounded: "rounded"
    },
    outputs: {
      onClick: "onClick",
      pageChange: "pageChange",
      listResize: "listResize",
      popupListScroll: "popupListScroll"
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 12,
    vars: 18,
    consts: [["content", ""], ["list", ""], ["default_custom_item_template", ""], ["li", ""], ["virtualContainer", ""], ["class", "k-list-optionlabel", "kendoDropDownsSelectable", "", 3, "ngClass", "index", 4, "ngIf"], ["kendoDropDownsSelectable", "", "class", "k-list-custom-value", 3, "multipleSelection", "index", 4, "ngIf"], [3, "class", "ngStyle", 4, "ngIf"], ["unselectable", "on", 3, "scroll"], ["role", "listbox"], [4, "ngIf"], [3, "resize", 4, "ngIf"], ["class", "k-height-container", "role", "presentation", 4, "ngIf"], ["kendoDropDownsSelectable", "", 1, "k-list-optionlabel", 3, "ngClass", "index"], [3, "templateContext"], ["kendoDropDownsSelectable", "", 1, "k-list-custom-value", 3, "multipleSelection", "index"], [4, "ngIf", "ngIfElse"], [3, "ngStyle"], [3, "ngIf"], ["ngFor", "", 3, "ngForOf"], ["role", "option", "kendoDropDownsSelectable", "", 3, "checkboxes", "height", "index", "multipleSelection", "ngClass"], ["type", "checkbox", "class", "k-checkbox", "role", "presentation", "tabindex", "-1", "aria-hidden", "true", 3, "ngClass", "checked", "change", 4, "ngIf"], ["type", "checkbox", "role", "presentation", "tabindex", "-1", "aria-hidden", "true", 1, "k-checkbox", 3, "change", "ngClass", "checked"], [1, "k-list-item-text"], ["role", "group", 3, "class", "k-table-alt-row", "ngStyle", "width", 4, "ngIf"], ["role", "option", "kendoDropDownsSelectable", "", 3, "height", "index", "multipleSelection", "class", "ngClass", "width", 4, "ngIf"], ["role", "group", 3, "ngStyle"], ["role", "option", "kendoDropDownsSelectable", "", 3, "height", "index", "multipleSelection", "ngClass"], [3, "resize"], ["role", "presentation", 1, "k-height-container"]],
    template: function ListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, ListComponent_div_0_Template, 2, 5, "div", 5)(1, ListComponent_div_1_Template, 2, 8, "div", 5)(2, ListComponent_div_2_Template, 4, 4, "div", 6)(3, ListComponent_div_3_Template, 3, 9, "div", 7);
        ɵɵelementStart(4, "div", 8, 0);
        ɵɵlistener("scroll", function ListComponent_Template_div_scroll_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.popupListScroll.emit($event));
        });
        ɵɵelementStart(6, "ul", 9, 1);
        ɵɵtemplate(8, ListComponent_8_Template, 1, 1, null, 10)(9, ListComponent_9_Template, 1, 1, null, 10)(10, ListComponent_kendo_resize_sensor_10_Template, 1, 0, "kendo-resize-sensor", 11);
        ɵɵelementEnd();
        ɵɵtemplate(11, ListComponent_div_11_Template, 4, 2, "div", 12);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx.defaultItem && !ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.defaultItem && ctx.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.allowCustom && ctx.text);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.dataService.grouped && ctx.showStickyHeader);
        ɵɵadvance();
        ɵɵclassMap(ctx.listContentClass);
        ɵɵstyleProp("max-height", ctx.height, "px");
        ɵɵadvance(2);
        ɵɵclassMap(ctx.listClass);
        ɵɵattribute("id", ctx.id)("aria-live", ctx.ariaLive)("aria-multiselectable", ctx.isMultiselect)("aria-hidden", !ctx.show);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.dataService.grouped && ctx.show);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.dataService.grouped);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.virtual);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.virtual);
      }
    },
    dependencies: [NgIf, NgStyle, TemplateContextDirective, NgForOf, ListItemDirective, SelectableDirective, NgClass, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-list",
      template: `
    <div *ngIf="defaultItem && !template"
        class="k-list-optionlabel"
        [ngClass]="{ 'k-disabled': isDisabledDefaultItem }"
        kendoDropDownsSelectable
        [index]="-1">
        {{ getDefaultItemText() }}
    </div>
    <div *ngIf="defaultItem && template"
        class="k-list-optionlabel"
        [ngClass]="{ 'k-disabled': isDisabledDefaultItem }"
        kendoDropDownsSelectable
        [index]="-1">
        <ng-template
            [templateContext]="{
                templateRef: template.templateRef,
                $implicit: defaultItem
            }">
        </ng-template>
    </div>
    <div *ngIf="allowCustom && text"
        kendoDropDownsSelectable
        [multipleSelection]="true"
        [index]="-1"
        class="k-list-custom-value">
        <ng-template *ngIf="customItemTemplate; else default_custom_item_template"
            [templateContext]="{
                templateRef: customItemTemplate.templateRef,
                $implicit: text
            }">
        </ng-template>
        <ng-template #default_custom_item_template>
            Use "{{text}}"
        </ng-template>
    </div>
    <div *ngIf="dataService.grouped && showStickyHeader"
        [class]="listGroupStickyHeaderClass"
        [ngStyle]="{
            'height.px': virtual?.itemHeight,
            'minHeight.px' : virtual?.itemHeight,
            'boxSizing' : virtual ? 'border-box' : 'inherit'}"
        >
        <ng-template *ngIf="fixedGroupTemplate"
            [templateContext]="{
                templateRef: fixedGroupTemplate.templateRef,
                $implicit: currentGroup
            }">
        </ng-template>
        <ng-template [ngIf]="!fixedGroupTemplate"><span [class]="listGroupStickyHeaderTextClass">{{ currentGroup }}</span></ng-template>
    </div>
    <div #content
        [class]="listContentClass"
        [style.maxHeight.px]="height"
        unselectable="on"
        (scroll)="popupListScroll.emit($event)">
        <ul #list
            role="listbox"
            [class]="listClass"
            [attr.id]="id"
            [attr.aria-live]="ariaLive"
            [attr.aria-multiselectable]="isMultiselect"
            [attr.aria-hidden]="!show">
            <ng-template *ngIf="!dataService.grouped && show" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
                <li
                    role="option"
                    kendoDropDownsSelectable
                    [checkboxes]="checkboxes"
                    [height]="virtual?.itemHeight"
                    [index]="itemIndex + startFrom"
                    [multipleSelection]="multipleSelection"
                    [attr.id]="optionPrefix + '-' + itemIndex"
                    [attr.tabIndex]="-1"
                    [attr.aria-selected]="isItemSelected(itemIndex)"
                    [class]="listItemClass"
                    [ngClass]="{
                        'k-disabled': isDisabled(itemIndex),
                        'k-table-alt-row': isAltRow(itemIndex)
                    }"
                    [style.width.px]="rowWidth ?? null"
                >
                    <input
                        *ngIf="checkboxes.enabled"
                        type="checkbox"
                        class="k-checkbox"
                        role="presentation"
                        tabindex="-1"
                        aria-hidden="true"
                        [ngClass]="checkboxClasses"
                        (change)="onCheckedChange($event, itemIndex + startFrom)"
                        [checked]="isChecked(itemIndex)"
                    />
                    <ng-template *ngIf="template"
                        [templateContext]="{
                            templateRef: template.templateRef,
                            $implicit: dataItem
                        }">
                    </ng-template>
                    <ng-template [ngIf]="!template"><span class="k-list-item-text">{{ getText(dataItem) }}</span></ng-template>
                </li>
            </ng-template>
            <ng-template *ngIf="dataService.grouped" ngFor let-dataItem let-itemIndex="index" [ngForOf]="data">
                <li
                    #li
                    *ngIf="dataItem.header"
                    role="group"
                    [class]="listGroupItemClass"
                    [class.k-table-alt-row]="isAltRow(itemIndex - 1)"
                    [ngStyle]="{
                        'height.px': virtual?.itemHeight,
                        'minHeight.px' : virtual?.itemHeight,
                        'boxSizing' : virtual ? 'border-box' : 'inherit'}"
                    [attr.group-index]="dataItem.index"
                    [attr.id]="optionPrefix + '-' + dataItem.groupIndex + '-' + dataItem.value.toString().split(' ').join('')"
                    [attr.tabIndex]="-1"
                    [style.width.px]="rowWidth ?? null">
                        <span [class]="listGroupItemTextClass">
                            <ng-template *ngIf="groupTemplate"
                                [templateContext]="{
                                    templateRef: groupTemplate.templateRef,
                                    $implicit: dataItem.value
                            }">
                            </ng-template>
                            <ng-template [ngIf]="!groupTemplate">{{ dataItem.value }}</ng-template>
                        </span>
                </li>
                <li
                    #li
                    *ngIf="!dataItem.header"
                    role="option"
                    kendoDropDownsSelectable
                    [height]="virtual?.itemHeight"
                    [index]="dataItem.offsetIndex"
                    [multipleSelection]="multipleSelection"
                    [attr.absolute-index]="dataItem.index"
                    [attr.id]="optionPrefix + '-' + (itemIndex - 1 - dataItem.groupIndex)"
                    [attr.tabIndex]="-1"
                    [attr.aria-selected]="isItemSelected(dataItem.offsetIndex)"
                    [class]="listItemClass"
                    [ngClass]="{
                        'k-disabled': isDisabled(dataItem.offsetIndex),
                        'k-table-alt-row': isAltRow(itemIndex - 1)
                    }"
                    [style.width.px]="rowWidth ?? null"
                >
                    <ng-template *ngIf="template"
                        [templateContext]="{
                            templateRef: template.templateRef,
                            $implicit: dataItem.value
                        }">
                    </ng-template>
                    <ng-template [ngIf]="!template"><span class="k-list-item-text">{{ getText(dataItem.value) }}</span></ng-template>
                </li>
            </ng-template>
            <kendo-resize-sensor
                *ngIf="!virtual"
                (resize)="listResize.emit()"
            >
            </kendo-resize-sensor>
        </ul>
        <div *ngIf="virtual" #virtualContainer class="k-height-container" role="presentation">
            <div [style.height.px]="scrollHeight">
                <kendo-resize-sensor (resize)="listResize.emit()"></kendo-resize-sensor>
            </div>
        </div>
    </div>
  `,
      standalone: true,
      imports: [NgIf, NgStyle, TemplateContextDirective, NgForOf, ListItemDirective, SelectableDirective, NgClass, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: DataService
    }, {
      type: ElementRef
    }, {
      type: SelectionService2
    }, {
      type: DisabledItemsService
    }, {
      type: ChangeDetectorRef
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }];
  }, {
    selected: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    groupTemplate: [{
      type: Input
    }],
    fixedGroupTemplate: [{
      type: Input
    }],
    show: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    optionPrefix: [{
      type: Input
    }],
    multipleSelection: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    ariaLive: [{
      type: Input
    }],
    isMultiselect: [{
      type: Input
    }],
    isActionSheetExpanded: [{
      type: Input
    }],
    showStickyHeader: [{
      type: Input
    }],
    rowWidth: [{
      type: Input
    }],
    customItemTemplate: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    allowCustom: [{
      type: Input
    }],
    defaultItem: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    onClick: [{
      type: Output
    }],
    pageChange: [{
      type: Output
    }],
    listResize: [{
      type: Output
    }],
    popupListScroll: [{
      type: Output
    }],
    items: [{
      type: ViewChildren,
      args: [ListItemDirective]
    }],
    content: [{
      type: ViewChild,
      args: ["content", {
        static: true
      }]
    }],
    list: [{
      type: ViewChild,
      args: ["list", {
        static: true
      }]
    }],
    virtualContainer: [{
      type: ViewChild,
      args: ["virtualContainer", {
        static: false
      }]
    }]
  });
})();
var DEFAULTS = {
  pageSize: 50,
  itemHeight: 28
};
var normalizeVirtualizationSettings = (settings, defaultOverrides) => {
  const defaults = Object.assign({}, DEFAULTS, defaultOverrides);
  if (settings === true) {
    return defaults;
  }
  if (!settings) {
    return null;
  }
  return __spreadValues({
    pageSize: DEFAULTS.pageSize
  }, settings);
};
var AdaptiveRendererComponent2 = class _AdaptiveRendererComponent {
  localization;
  adaptiveService;
  title;
  subtitle;
  showTextInput;
  sharedPopupActionSheetTemplate;
  text;
  placeholder;
  searchBarValue;
  filterable;
  closePopup = new EventEmitter();
  textInputChange = new EventEmitter();
  navigate = new EventEmitter();
  onExpand = new EventEmitter();
  actionSheet;
  actionSheetSearchBar;
  constructor(localization, adaptiveService) {
    this.localization = localization;
    this.adaptiveService = adaptiveService;
  }
  animationDuration = animationDuration2;
  checkIcon = checkIcon;
  expanded = false;
  messageFor(key) {
    return this.localization.get(key);
  }
  onValueChange(value) {
    this.searchBarValue = value;
    this.textInputChange.emit(value);
  }
  onOverlayClick() {
    if (this.expanded) {
      this.handleClose();
    }
  }
  handleExpand() {
    this.onExpand.emit();
    this.expanded = true;
  }
  handleClose() {
    this.closePopup.emit();
    this.expanded = false;
  }
  get windowSize() {
    return this.adaptiveService.size;
  }
  static ɵfac = function AdaptiveRendererComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AdaptiveRendererComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AdaptiveRendererComponent,
    selectors: [["kendo-adaptive-renderer"]],
    viewQuery: function AdaptiveRendererComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(ActionSheetComponent, 5);
        ɵɵviewQuery(_c82, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheet = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionSheetSearchBar = _t.first);
      }
    },
    inputs: {
      title: "title",
      subtitle: "subtitle",
      showTextInput: "showTextInput",
      sharedPopupActionSheetTemplate: "sharedPopupActionSheetTemplate",
      text: "text",
      placeholder: "placeholder",
      searchBarValue: "searchBarValue",
      filterable: "filterable"
    },
    outputs: {
      closePopup: "closePopup",
      textInputChange: "textInputChange",
      navigate: "navigate",
      onExpand: "onExpand"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 3,
    vars: 11,
    consts: [["actionSheet", ""], ["actionSheetSearchBar", ""], [3, "overlayClick", "keydown", "expand", "collapse", "animation", "initialFocus", "cssClass", "cssStyle"], ["kendoActionSheetTemplate", ""], [1, "k-text-center", "k-actionsheet-titlebar"], [1, "k-actionsheet-titlebar-group"], [1, "k-actionsheet-title"], ["class", "k-text-center", 4, "ngIf"], ["class", "k-actionsheet-subtitle k-text-center", 4, "ngIf"], [1, "k-actionsheet-actions"], ["kendoButton", "", "icon", "check", "type", "button", "fillMode", "flat", "themeColor", "primary", "size", "large", "aria-hidden", "true", "innerCssClass", "k-button-icon", 3, "click", "svgIcon", "tabIndex"], ["class", "k-actionsheet-titlebar-group k-actionsheet-filter", 4, "ngIf"], [1, "k-actionsheet-content"], [1, "k-list-container"], [4, "ngTemplateOutlet"], [1, "k-text-center"], [1, "k-actionsheet-subtitle", "k-text-center"], [1, "k-actionsheet-titlebar-group", "k-actionsheet-filter"], ["size", "large", "autocomplete", "off", 1, "k-searchbox", 3, "valueChange", "value", "placeholder"], [4, "ngIf"], ["kendoTextBoxPrefixTemplate", ""], ["name", "search"]],
    template: function AdaptiveRendererComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "kendo-actionsheet", 2, 0);
        ɵɵlistener("overlayClick", function AdaptiveRendererComponent_Template_kendo_actionsheet_overlayClick_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onOverlayClick());
        })("keydown", function AdaptiveRendererComponent_Template_kendo_actionsheet_keydown_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.navigate.emit($event));
        })("expand", function AdaptiveRendererComponent_Template_kendo_actionsheet_expand_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleExpand());
        })("collapse", function AdaptiveRendererComponent_Template_kendo_actionsheet_collapse_0_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.closePopup.emit());
        });
        ɵɵtemplate(2, AdaptiveRendererComponent_ng_template_2_Template2, 11, 7, "ng-template", 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("animation", ɵɵpureFunction1(4, _c92, ctx.animationDuration))("initialFocus", false)("cssClass", ɵɵpureFunction2(6, _c102, ctx.windowSize === "small", ctx.windowSize === "medium"))("cssStyle", ɵɵpureFunction1(9, _c112, ctx.windowSize === "small" ? "100vh" : "60vh"));
      }
    },
    dependencies: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconComponent, NgTemplateOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AdaptiveRendererComponent2, [{
    type: Component,
    args: [{
      selector: "kendo-adaptive-renderer",
      template: `
        <kendo-actionsheet
            #actionSheet
            [animation]="{ duration: animationDuration }"
            [initialFocus]="false"
            [cssClass]="{
                'k-adaptive-actionsheet': true,
                'k-actionsheet-fullscreen': windowSize === 'small',
                'k-actionsheet-bottom': windowSize === 'medium'
            }"
            [cssStyle]="{
                height: windowSize === 'small' ? '100vh' : '60vh'
            }"
            (overlayClick)="onOverlayClick()"
            (keydown)="navigate.emit($event)"
            (expand)="handleExpand()"
            (collapse)="closePopup.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <div class="k-text-center k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center" *ngIf="title">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center" *ngIf="subtitle">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                icon="check"
                                type="button"
                                [attr.title]="messageFor('adaptiveCloseButtonTitle')"
                                [svgIcon]="checkIcon"
                                fillMode="flat"
                                themeColor="primary"
                                size="large"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                innerCssClass="k-button-icon"
                                (click)="handleClose()"
                            ></button>
                        </div>
                    </div>
                    <div class="k-actionsheet-titlebar-group k-actionsheet-filter" *ngIf="showTextInput">
                        <kendo-textbox
                            #actionSheetSearchBar
                            [value]="searchBarValue || ''"
                            size="large"
                            [placeholder]="filterable ? messageFor('filterInputPlaceholder') : placeholder"
                            class="k-searchbox"
                            autocomplete="off"
                            (valueChange)="onValueChange($event)"
                        >
                            <ng-template kendoTextBoxPrefixTemplate *ngIf="filterable">
                                <kendo-icon name="search"></kendo-icon>
                            </ng-template>
                        </kendo-textbox>
                    </div>
                </div>
                <div class="k-actionsheet-content">
                    <div class="k-list-container">
                        <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
                    </div>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `,
      standalone: true,
      imports: [ActionSheetComponent, ActionSheetTemplateDirective, ButtonComponent, NgIf, TextBoxComponent, TextBoxPrefixTemplateDirective, IconComponent, NgTemplateOutlet]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: AdaptiveService
    }];
  }, {
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }],
    showTextInput: [{
      type: Input
    }],
    sharedPopupActionSheetTemplate: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    searchBarValue: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    closePopup: [{
      type: Output
    }],
    textInputChange: [{
      type: Output
    }],
    navigate: [{
      type: Output
    }],
    onExpand: [{
      type: Output
    }],
    actionSheet: [{
      type: ViewChild,
      args: [ActionSheetComponent]
    }],
    actionSheetSearchBar: [{
      type: ViewChild,
      args: ["actionSheetSearchBar"]
    }]
  });
})();
var SharedDropDownEventsDirective = class _SharedDropDownEventsDirective {
  ngZone;
  renderer;
  cdr;
  hostElement;
  clearButtonClicked;
  isFocused;
  isFocusedChange = new EventEmitter();
  onFocus = new EventEmitter();
  handleBlur = new EventEmitter();
  subscriptions = new Subscription();
  constructor(ngZone, renderer, cdr) {
    this.ngZone = ngZone;
    this.renderer = renderer;
    this.cdr = cdr;
  }
  ngAfterViewInit() {
    const hostElement = this.hostElement.nativeElement;
    let cursorInsideWrapper = false;
    let tabbing = false;
    this.ngZone.runOutsideAngular(() => {
      this.subscriptions.add(this.renderer.listen(hostElement, "focusin", () => {
        this.cdr.detectChanges();
        if (!this.isFocused) {
          this.ngZone.run(() => {
            this.onFocus.emit();
            this.isFocused = true;
            this.isFocusedChange.emit(this.isFocused);
          });
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "focusout", (args) => {
        if (!this.isFocused) {
          return;
        }
        if (tabbing) {
          const closestTextbox = closest(args.relatedTarget, (element) => element === hostElement);
          if (!closestTextbox) {
            this.handleBlur.emit();
          }
          tabbing = false;
        } else if (!cursorInsideWrapper) {
          this.handleBlur.emit();
        }
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseenter", () => {
        cursorInsideWrapper = true;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "mouseleave", () => {
        cursorInsideWrapper = false;
      }));
      this.subscriptions.add(this.renderer.listen(hostElement, "keydown", (args) => {
        if (args.keyCode === Keys.Tab) {
          tabbing = true;
        } else {
          tabbing = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
  }
  static ɵfac = function SharedDropDownEventsDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedDropDownEventsDirective)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SharedDropDownEventsDirective,
    selectors: [["", "kendoDropDownSharedEvents", ""]],
    inputs: {
      hostElement: "hostElement",
      clearButtonClicked: "clearButtonClicked",
      isFocused: "isFocused"
    },
    outputs: {
      isFocusedChange: "isFocusedChange",
      onFocus: "onFocus",
      handleBlur: "handleBlur"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedDropDownEventsDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownSharedEvents]",
      standalone: true
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    hostElement: [{
      type: Input
    }],
    clearButtonClicked: [{
      type: Input
    }],
    isFocused: [{
      type: Input
    }],
    isFocusedChange: [{
      type: Output
    }],
    onFocus: [{
      type: Output
    }],
    handleBlur: [{
      type: Output
    }]
  });
})();
var Messages2 = class _Messages extends ComponentMessages {
  /**
   * The text displayed in the popup when there are no items.
   */
  noDataText;
  /**
   * The title of the clear button.
   */
  clearTitle;
  /**
   * The text displayed for the check-all checkbox.
   */
  checkAllText;
  /**
   * The text set as aria-label on the select button.
   */
  selectButtonText;
  /**
   * The text set as aria-label on the list filter input.
   */
  filterInputLabel;
  /**
   * The text set as aria-label on the popup containing the list of options when its role is `region`.
   */
  popupLabel;
  /**
   * The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.
   */
  adaptiveCloseButtonTitle;
  /**
   * The text for the input's placeholder when filtering is enabled.
   */
  filterInputPlaceholder;
  static ɵfac = /* @__PURE__ */ (() => {
    let ɵMessages_BaseFactory;
    return function Messages_Factory(__ngFactoryType__) {
      return (ɵMessages_BaseFactory || (ɵMessages_BaseFactory = ɵɵgetInheritedFactory(_Messages)))(__ngFactoryType__ || _Messages);
    };
  })();
  static ɵdir = ɵɵdefineDirective({
    type: _Messages,
    inputs: {
      noDataText: "noDataText",
      clearTitle: "clearTitle",
      checkAllText: "checkAllText",
      selectButtonText: "selectButtonText",
      filterInputLabel: "filterInputLabel",
      popupLabel: "popupLabel",
      adaptiveCloseButtonTitle: "adaptiveCloseButtonTitle",
      filterInputPlaceholder: "filterInputPlaceholder"
    },
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Messages2, [{
    type: Directive
  }], null, {
    noDataText: [{
      type: Input
    }],
    clearTitle: [{
      type: Input
    }],
    checkAllText: [{
      type: Input
    }],
    selectButtonText: [{
      type: Input
    }],
    filterInputLabel: [{
      type: Input
    }],
    popupLabel: [{
      type: Input
    }],
    adaptiveCloseButtonTitle: [{
      type: Input
    }],
    filterInputPlaceholder: [{
      type: Input
    }]
  });
})();
var LocalizedMessagesDirective2 = class _LocalizedMessagesDirective extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  static ɵfac = function LocalizedMessagesDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LocalizedMessagesDirective)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _LocalizedMessagesDirective,
    selectors: [["", "kendoDropDownListLocalizedMessages", ""], ["", "kendoDropDownTreeLocalizedMessages", ""], ["", "kendoComboBoxLocalizedMessages", ""], ["", "kendoMultiColumnComboBoxLocalizedMessages", ""], ["", "kendoAutoCompleteLocalizedMessages", ""], ["", "kendoMultiSelectLocalizedMessages", ""], ["", "kendoMultiSelectTreeLocalizedMessages", ""]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _LocalizedMessagesDirective)
    }]), ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalizedMessagesDirective2, [{
    type: Directive,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => LocalizedMessagesDirective2)
      }],
      selector: `
    [kendoDropDownListLocalizedMessages],
    [kendoDropDownTreeLocalizedMessages],
    [kendoComboBoxLocalizedMessages],
    [kendoMultiColumnComboBoxLocalizedMessages],
    [kendoAutoCompleteLocalizedMessages],
    [kendoMultiSelectLocalizedMessages],
    [kendoMultiSelectTreeLocalizedMessages]
  `,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var NO_VALUE = "";
var DEFAULT_SIZE$52 = "medium";
var DEFAULT_ROUNDED$52 = "medium";
var DEFAULT_FILL_MODE$52 = "solid";
var AUTOCOMPLETE_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => AutoCompleteComponent)
};
var AutoCompleteComponent = class _AutoCompleteComponent {
  localization;
  dataService;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  _zone;
  cdr;
  renderer;
  hostElement;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  adaptiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRendererComponent?.actionSheetSearchBar;
  }
  get width() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-autocomplete-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  get suggestion() {
    if (!this.text || !this.suggestedText) {
      this.suggestedText = void 0;
      return;
    }
    const hasMatch = this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase());
    const shouldSuggest = this.suggest && !this.backspacePressed;
    if (shouldSuggest && hasMatch) {
      return this.suggestedText;
    }
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  /**
   * @hidden
   */
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  dataItem;
  /**
   * Toggles the visibility of the popup or actionSheet.
   * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !this._open;
      this._toggle(shouldOpen);
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(this._open || this.isActionSheetExpanded);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented = this.triggerPopupEvents(open);
    if (!isDefaultPrevented) {
      this._toggle(open);
    }
  }
  get activeDescendant() {
    if (!this.isOpen || !isPresent5(this.selectionService.focused) || this.selectionService.focused === -1) {
      return null;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  /**
   * Defines whether the first match from the suggestions list will be automatically focused.
   * By default, `highlightFirst` is set to `true`.
   *
   * @default true
   */
  highlightFirst = true;
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default, the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   *
   * @default true
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Sets the data of the AutoComplete.
   *
   * > The data has to be provided in an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    if (this.filterable) {
      this.selectionService.focused = this.isOpen && this.data.length && this.highlightFirst ? this.firstFocusableIndex(0) : -1;
    }
    if (this.suggest && this.dataService.itemsCount > 0) {
      this.suggestedText = getter2(this.dataService.itemAt(0), this.valueField);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the AutoComplete.
   */
  set value(newValue) {
    this.verifySettings(newValue);
    this._value = newValue || NO_VALUE;
    this.text = this.value;
    this.cdr.markForCheck();
  }
  get value() {
    return this._value || NO_VALUE;
  }
  /**
   * Specifies the `string` property of the data item that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  valueField;
  /**
   * Sets the placeholder of the AutoComplete.
   *
   * @default ""
   */
  placeholder = "";
  /**
   * Enables or disables the adaptive mode. By default, the adaptive rendering is disabled.
   *
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that renders instead of the Popup when using small screen devices.
   * By default, the ActionSheet title uses the text provided for the label of the AutoComplete.
   *
   * @default ''
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle of the ActionSheet that renders instead of the Popup when using small screen devices.
   * By default, the ActionSheet does not render a subtitle.
   */
  adaptiveSubtitle;
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Configures the popup of the AutoComplete.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
  * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
  *
  * > The `listHeight` property affects only the list of options and not the whole popup container.
  * > To set the height of the popup container, use `popupSettings.height`.
  *
  * When using `adaptiveMode` and the screen size is `small` or `medium`, the `listHeight` property is set to null.
  * @default 200
  */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets and gets the loading state of the AutoComplete.
   *
   * @default false
   */
  loading;
  /**
   * @hidden
   *
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Enables the auto-completion of the text based on the first data item.
   *
   * @default false
   */
  suggest;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_autocomplete#toc-managing-the-autocomplete-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Defines a Boolean function that is executed for each data item in the component
   * ([see examples]({% slug disableditems_autocomplete %})).
   * Determines whether the item will be disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Enables the [filtering]({% slug filtering_autocomplete %}) functionality.
   * If set to `true`, the component emits the `filterChange` event.
   *
   * @default false
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_autocomplete %}) functionality.
   *
   * @default false
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Sets the size of the component.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$52;
    this.renderer.removeClass(this.wrapper, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$52;
    this.renderer.removeClass(this.wrapper, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$52;
    this.renderer.removeClass(this.wrapper, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes which are essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * Fires each time the value changes&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_autocomplete)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time the user types in the input field.
   * You can filter the source based on the passed filtration value
   * ([see example](slug:events_autocomplete)).
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open.
   * This event is preventable. If you cancel it, the popup remains closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup opens.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close.
   * This event is preventable. If you cancel it, the popup remains open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup closes.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the AutoComplete.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the AutoComplete gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  template;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  groupTemplate;
  fixedGroupTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  container;
  popupTemplate;
  searchbar;
  optionsList;
  widgetClasses = true;
  get isFocused() {
    return this._isFocused;
  }
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper, "k-focus");
    this._isFocused = isFocused;
  }
  get isDisabled() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  get dir() {
    return this.direction;
  }
  text;
  listBoxId = `k-${guid()}`;
  optionPrefix = `k-${guid()}`;
  popupRef;
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  onChangeCallback = noop6;
  onTouchedCallback = noop6;
  constructor(localization, dataService, popupService, selectionService, navigationService, disabledItemsService, _zone, cdr, renderer, hostElement, injector, adaptiveService) {
    this.localization = localization;
    this.dataService = dataService;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this._zone = _zone;
    this.cdr = cdr;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata4);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.wrapper = this.hostElement.nativeElement;
    this.data = [];
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.selectionService.resetSelection([-1]);
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper, "tabindex");
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
  }
  /**
   * Resets the value of the AutoComplete.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `valueChange` event will not be fired.
   */
  reset() {
    this.value = NO_VALUE;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event.stopImmediatePropagation();
    this.focus();
    this.change(NO_VALUE);
    if (this.filterable) {
      this.filterChange.emit("");
    }
    this.selectionService.resetSelection([]);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * Focuses a specific item of the AutoComplete based on a provided index.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const isInRange = index >= 0 && index < this.data.length;
    if (isPresent5(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(-1);
    }
  }
  /**
   * Focuses the AutoComplete.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * Blurs the AutoComplete.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this._open && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  emitChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  verifySettings(newValue) {
    if (!isDevMode()) {
      return;
    }
    if (isPresent5(newValue) && typeof newValue !== "string") {
      throw new Error("Expected value of type string. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/autocomplete/value-binding/");
    }
  }
  search(text, startFrom = 0) {
    const index = this.findIndex(text, startFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      if (index + 1 < this.dataService.itemsCount) {
        this.search(text, index + 1);
      } else {
        this.selectionService.focus(-1);
      }
    } else {
      this.selectionService.focus(index);
      if (this.suggest) {
        this.suggestedText = getter2(this.dataService.itemAt(index), this.valueField);
      }
    }
  }
  navigate(index) {
    if (!this.isOpen) {
      return;
    }
    this.selectionService.focus(index);
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
    if (this.disabled || this.readonly || isNaN(focused)) {
      return;
    }
    const action = this.navigationService.process({
      current: focused,
      max: this.dataService.itemsCount - 1,
      min: 0,
      originalEvent: event
    });
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.Home && action !== NavigationAction.End && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {
      event.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      event.stopImmediatePropagation();
      this.togglePopup(false);
    }
  }
  handleEnter(event) {
    const focused = this.selectionService.focused;
    let value;
    if (this.isOpen) {
      event.originalEvent.preventDefault();
    }
    if (focused >= 0) {
      value = getter2(this.dataService.itemAt(focused), this.valueField);
    } else {
      const match2 = this.suggest && this.suggestedText && this.data.length && getter2(this.dataService.itemAt(0), this.valueField).toLowerCase() === this.searchbar.value.toLowerCase();
      if (this.isOpen && match2) {
        value = this.suggestedText;
      } else {
        value = this.searchbar.value;
      }
    }
    if (this.isActionSheetExpanded && focused >= 0) {
      this.togglePopup(false);
    }
    this.change(value);
  }
  handleEscape() {
    if (this.isOpen) {
      this.togglePopup(false);
    } else {
      this.value = "";
    }
    this.selectionService.focused = -1;
    this.suggestedText = null;
  }
  /**
   * @hidden
   */
  searchBarChange(text) {
    const currentTextLength = isPresent5(this.text) ? this.text.length : 0;
    this.backspacePressed = Boolean(text.length < currentTextLength);
    this.text = text;
    this.togglePopup(text.length > 0);
    if (!this.highlightFirst) {
      this.selectionService.focused = -1;
    }
    if (this.filterable) {
      this.filterChange.emit(text);
    } else if (this.highlightFirst) {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this._zone.run(() => {
        this.inputFocus.emit();
      });
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this._zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      this.blurComponent();
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      const focused = this.filterable ? this.selectionService.focused : -1;
      this.searchbar.input.nativeElement.scrollLeft = 0;
      let dataItem;
      let text;
      if (focused !== -1) {
        dataItem = this.dataService.itemAt(focused);
        text = getter2(dataItem, this.valueField) || "";
      } else {
        text = this.searchbar.value;
      }
      const exactMatch = text === this.searchbar.value;
      const insensitiveMatch = text.toLowerCase() === this.searchbar.value.toLowerCase();
      if (!exactMatch && insensitiveMatch) {
        this.selectionService.resetSelection([]);
      }
      const valueHasChanged = this.value !== this.text;
      const runInZone = hasObservers(this.inputBlur) || hasObservers(this.close) || isUntouched2(this.wrapper) || valueHasChanged || this.formControl?.updateOn === "blur";
      if (runInZone) {
        this._zone.run(() => {
          if (valueHasChanged) {
            this.change(this.searchbar.value);
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  /**
   * @hidden
   */
  closeActionSheet() {
    this.blurComponent();
    this.closed.emit();
  }
  change(value) {
    this.togglePopup(false);
    this.valueChangeSubject.next(value);
  }
  popupMouseDownHandler = (event) => event.preventDefault();
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _open = false;
  _value = "";
  suggestedText;
  backspacePressed;
  subs = new Subscription();
  valueChangeSubject = new Subject();
  touchstartDisposeHandler;
  wrapper;
  _isFocused = false;
  direction;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.valueChangeSubject.subscribe((value) => {
      const hasChange = this.value !== value;
      const index = this.findIndex(value);
      this.selectionService.focused = index;
      this.value = value;
      this.text = value;
      if (hasChange) {
        this.emitChange(value);
      }
    }));
    this.subs.add(this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)));
    this.subs.add(this.selectionService.onFocus.subscribe(this.handleItemFocus.bind(this)));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down).subscribe((event) => this.navigate(event.index)));
    this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));
    this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));
    this.subs.add(this.navigationService.enter.subscribe(this.handleEnter.bind(this)));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
  }
  findIndex(value, startFrom = 0) {
    let index;
    if (value && value.length && this.dataService.itemsCount) {
      index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);
    } else {
      index = -1;
    }
    return index;
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up AutoComplete on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.hostElement, target, this.popupRef)) {
          this._zone.run(() => this.blur());
        }
      })
    ));
  }
  handleItemChange(event) {
    const index = event.indices.length ? event.indices[0] : void 0;
    this.selectionService.resetSelection([-1]);
    if (!isPresent5(index)) {
      return;
    }
    const text = getter2(this.dataService.itemAt(index), this.valueField);
    this.change(text);
  }
  handleItemFocus(_event) {
    const focused = this.selectionService.focused;
    const shouldSuggest = Boolean(this.suggest && this.data && this.data.length && focused >= 0);
    if (shouldSuggest) {
      this.suggestedText = getter2(this.dataService.itemAt(focused), this.valueField);
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupAlign: popupPosition,
      anchorAlign: anchorPosition
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.subs.add(this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    }));
    this.subs.add(this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    }));
    this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.actionSheet.toggle(false);
      this.focus();
    }
    if (this._open) {
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  firstFocusableIndex(index) {
    const maxIndex = this.data.length - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  findIndexPredicate(text) {
    if (this.dataService.grouped) {
      return (item) => {
        let itemText = getter2(item.value, this.valueField);
        itemText = !isPresent5(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    } else {
      return (item) => {
        let itemText = getter2(item, this.valueField);
        itemText = !isPresent5(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    }
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper, getFillModeClass("input", this.fillMode));
    }
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.adaptiveTitle = setActionSheetTitle(this.searchbar.input, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  blurComponent() {
    this.isFocused = false;
    const valueHasChanged = this.value !== this.text;
    const runInZone = hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper) || valueHasChanged;
    if (runInZone) {
      this._zone.run(() => {
        if (valueHasChanged) {
          this.change(this.searchbar.value);
        }
        this.onBlur.emit();
        this.onTouchedCallback();
        this.togglePopup(false);
      });
    } else {
      this.togglePopup(false);
    }
  }
  static ɵfac = function AutoCompleteComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AutoCompleteComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _AutoCompleteComponent,
    selectors: [["kendo-autocomplete"]],
    contentQueries: function AutoCompleteComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function AutoCompleteComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(_c142, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function AutoCompleteComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-autocomplete", ctx.widgetClasses)("k-input", ctx.widgetClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      highlightFirst: "highlightFirst",
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      data: "data",
      value: "value",
      valueField: "valueField",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      loading: "loading",
      clearButton: "clearButton",
      suggest: "suggest",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      filterable: "filterable",
      virtual: "virtual",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      valueChange: "valueChange",
      filterChange: "filterChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur"
    },
    exportAs: ["kendoAutoComplete"],
    standalone: true,
    features: [ɵɵProvidersFeature([AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.autocomplete"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _AutoCompleteComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _AutoCompleteComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 17,
    vars: 30,
    consts: () => {
      let i18n_0;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_0 = goog.getMsg("NO DATA FOUND");
        i18n_0 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_0;
      } else {
        i18n_0 = $localize`:kendo.autocomplete.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_1;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_1 = goog.getMsg("clear");
        i18n_1 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_1;
      } else {
        i18n_1 = $localize`:kendo.autocomplete.clearTitle|The title of the clear button:clear`;
      }
      let i18n_2;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_2 = goog.getMsg("Options list");
        i18n_2 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_2;
      } else {
        i18n_2 = $localize`:kendo.autocomplete.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_3;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_3 = goog.getMsg("Close");
        i18n_3 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_3;
      } else {
        i18n_3 = $localize`:kendo.autocomplete.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["kendoAutoCompleteLocalizedMessages", "", "noDataText", i18n_0, "clearTitle", i18n_1, "popupLabel", i18n_2, "adaptiveCloseButtonTitle", i18n_3], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaExpanded", "isSuggestable", "isFilterable", "isLoading", "ariaControls", "id", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "visibility", "click", "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "placeholder", "searchBarValue"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click", "mousedown"], ["name", "x", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function AutoCompleteComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 4);
        ɵɵelementContainerStart(1, 5);
        ɵɵtwoWayListener("isFocusedChange", function AutoCompleteComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function AutoCompleteComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function AutoCompleteComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, AutoCompleteComponent_span_2_Template, 2, 1, "span", 6)(3, AutoCompleteComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 7);
        ɵɵelementStart(4, "input", 8);
        ɵɵlistener("onNavigate", function AutoCompleteComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function AutoCompleteComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function AutoCompleteComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function AutoCompleteComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function AutoCompleteComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, AutoCompleteComponent_span_5_Template, 2, 4, "span", 9)(6, AutoCompleteComponent_span_6_Template, 1, 0, "span", 10)(7, AutoCompleteComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 7)(8, AutoCompleteComponent_span_8_Template, 2, 1, "span", 11);
        ɵɵelementContainerEnd();
        ɵɵtemplate(9, AutoCompleteComponent_ng_template_9_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(11, null, 1);
        ɵɵtemplate(13, AutoCompleteComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 12);
        ɵɵelementStart(14, "kendo-adaptive-renderer", 13);
        ɵɵlistener("closePopup", function AutoCompleteComponent_Template_kendo_adaptive_renderer_closePopup_14_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.closeActionSheet());
        })("textInputChange", function AutoCompleteComponent_Template_kendo_adaptive_renderer_textInputChange_14_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("navigate", function AutoCompleteComponent_Template_kendo_adaptive_renderer_navigate_14_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(15, AutoCompleteComponent_ng_template_15_Template, 5, 17, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(16);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaExpanded", ctx.isOpen)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("isLoading", ctx.isLoading)("ariaControls", ctx.ariaControls)("id", ctx.focusableId)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.suggestion)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance();
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", true)("subtitle", ctx.adaptiveSubtitle)("placeholder", ctx.placeholder)("searchBarValue", ctx.text);
      }
    },
    dependencies: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoAutoComplete",
      providers: [AUTOCOMPLETE_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.autocomplete"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => AutoCompleteComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => AutoCompleteComponent)
      }],
      selector: "kendo-autocomplete",
      template: `
        <ng-container kendoAutoCompleteLocalizedMessages
            i18n-noDataText="kendo.autocomplete.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.autocomplete.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-popupLabel="kendo.autocomplete.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.autocomplete.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input
                kendoSearchbar
                [ariaExpanded]="isOpen"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [isLoading]="isLoading"
                [ariaControls]="ariaControls"
                [id]="focusableId"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="suggestion"
                [disabled]="disabled"
                [readonly]="readonly || this.isAdaptive"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="!loading && !readonly && (clearButton && text?.length)"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                [attr.title]="messageFor('clearTitle')"
                role="button"
                tabindex="-1"
                (click)="clearValue($event)"
                (mousedown)="$event.preventDefault()"
            >
                <kendo-icon-wrapper
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span *ngIf="loading" class="k-icon k-i-loading k-input-loading-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="true"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="closeActionSheet()"
            (textInputChange)="searchBarChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            [searchBarValue]="text">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="isAdaptive ? 'large' : size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="valueField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)"
            >
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: DataService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService2
    }, {
      type: DisabledItemsService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    adaptiveRendererComponent: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    highlightFirst: [{
      type: Input
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    suggest: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    widgetClasses: [{
      type: HostBinding,
      args: ["class.k-autocomplete"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var MultiselectMessages = {
  "array": "Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding",
  "object": "Expected values of Object type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-object-values",
  "primitive": "Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselect/data-binding/#toc-arrays-of-complex-data"
};
var MultiSelectTreeMessages = {
  "array": "Expected values of array type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding",
  "primitive": "Expected values of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-primitive-values",
  "object": "Expected values of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding/#toc-object-values",
  "dataItems": "Expected dataItems of type Object[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems",
  "dataItemsLength": "Expected dataItems length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-dataitems",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multiselecttree/value-binding",
  "valueDepth": "Expected valueDepth of type number[] to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth",
  "valueDepthLength": "Expected valueDepth length to match the number of provided values. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/MultiSelectTreeComponent/#toc-valuedepth"
};
var ComboBoxMessages = {
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-object-values",
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/combobox/data-binding/#toc-arrays-of-complex-data",
  "noItemHeight": "Expected virtual.itemHeight of type number."
};
var MultiColumnComboBoxMessages = {
  "data": "Provided data must consist only of objects. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/multicolumncombobox/data-binding/#toc-fields-configuration"
};
var DropDownListMessages = {
  "defaultItem": "defaultItem and data items must be of same type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownListComponent/#toc-defaultitem",
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-object-values",
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/value-binding/#toc-primitive-values",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdownlist/data-binding/#toc-arrays-of-complex-data"
};
var DropDownTreeMessages = {
  "primitive": "Expected value of primitive type. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-primitive-values",
  "object": "Expected value of type Object. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding/#toc-object-values",
  "dataItem": "Expected dataItem of type Object to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-dataitem",
  "textAndValue": "Expected textField and valueField options to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/dropdowntree/value-binding",
  "valueDepth": "Expected valueDepth to be set. See https://www.telerik.com/kendo-angular-ui/components/dropdowns/api/DropDownTreeComponent/#toc-valuedepth"
};
var COMBOBOX_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ComboBoxComponent)
};
var DEFAULT_SIZE$42 = "medium";
var DEFAULT_ROUNDED$42 = "medium";
var DEFAULT_FILL_MODE$42 = "solid";
var ComboBoxComponent = class _ComboBoxComponent extends MultiTabStop {
  wrapper;
  localization;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  dataService;
  zone;
  cdr;
  renderer;
  injector;
  hostElement;
  adaptiveService;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * Sets the HTML attributes of the inner focusable input element. Attributes essential for certain component functionalities cannot be changed.
   */
  inputAttributes;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  adaptiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  set text(text) {
    this._text = isPresent5(text) ? text.toString() : "";
  }
  get text() {
    return this._text;
  }
  /**
   * @hidden
   */
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented = this.triggerPopupEvents(open);
    if (!isDefaultPrevented) {
      this._toggle(open);
    }
  }
  get activeDescendant() {
    if (!this.isOpen || !isPresent5(this.selectionService.focused) || this.selectionService.focused === -1) {
      return null;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  dataItem;
  selected = [];
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   * @default true
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Specifies whether the ComboBox allows user-defined values that are not present in the dataset
   * ([more information and examples]({% slug custom_values_combobox %})).
   * Defaults to `false`.
   *
   * The feature is not available when using adaptive mode.
   * @default false
   */
  allowCustom = false;
  /**
   * Sets the data of the ComboBox.
   * The data must be provided in an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.setState();
    if (this._filtering) {
      const queryAndDataPresent = this.text.length > 0 && this.dataService.itemsCount > 0;
      const index = queryAndDataPresent ? this.firstFocusableIndex(0) : -1;
      this.selectionService.focused = index;
    }
    if (this.suggest && this.dataService.itemsCount && this.text) {
      this.suggestedText = getter2(this.dataService.itemAt(0), this.textField);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the ComboBox. The value can be a primitive (string, number) or a complex object. Use the `valuePrimitive` property to define the type.
   *
   * All selected values not present in the dataset are custom values. When the `Enter` key is pressed or the component loses focus, custom values are dismissed unless `allowCustom` is set to `true`.
   */
  set value(newValue) {
    this._value = newValue;
    this.setState();
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data item field that represents the item text. If the data contains only primitive values, do not define this property.
   *
   * The `textField` property can be set to a nested property value, for example, `category.name`.
   */
  textField;
  /**
   * Sets the data item field that represents the item value.
   * If the data contains only primitive values, do not define it.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Specifies the type of the selected value. If set to `true`, the selected value must be a primitive type.
   * ([more information and example]({% slug valuebinding_combobox %}#toc-primitive-values-from-object-fields))
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent5(this._valuePrimitive)) {
      return !isPresent5(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * A user-defined callback which returns normalized custom values.
   * Typically used when the data items are different from type `string`.
   * @param { Any } value - The custom value defined by the user.
   * @returns { Any }
   *
   * @example
   * ```ts
   * import { map } from 'rxjs/operators';
   *
   * _@Component({
   * selector: 'my-app',
   * template: `
   *   <kendo-combobox
   *       [allowCustom]="true"
   *       [data]="listItems"
   *       textField="text"
   *       valueField="value"
   *       [valueNormalizer]="valueNormalizer"
   *       (valueChange)="onValueChange($event)"
   *   >
   *   </kendo-combobox>
   * `
   * })
   *
   * class AppComponent {
   *   public listItems: Array<{ text: string, value: number }> = [
   *       { text: "Small", value: 1 },
   *       { text: "Medium", value: 2 },
   *       { text: "Large", value: 3 }
   *   ];
   *
   *   public onValueChange(value) {
   *       console.log("valueChange : ", value);
   *   }
   *
   *   public valueNormalizer = (text$: Observable<string>) => text$.pipe(map((text: string) => {
   *      return { ProductID: null, ProductName: text };
   *   }));
   *
   * }
   * ```
   */
  valueNormalizer = (text) => text.pipe(map((userInput) => userInput));
  /**
   * The hint that is displayed when the component is empty.
   * @default ''
   */
  placeholder = "";
  /**
   * Enables or disables the adaptive mode. By default, adaptive rendering is disabled.
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default, the ActionSheet title uses the text provided for the label of the ComboBox.
   * @default ''
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices. By default, the ActionSheet does not render a subtitle.
   */
  adaptiveSubtitle;
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Configures the popup of the ComboBox.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets and gets the loading state of the ComboBox.
   */
  loading;
  /**
   * Enables the auto-completion of the text based on the first data item.
   * @default false
   */
  suggest = false;
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   * @default true
   */
  clearButton = true;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the articles on [ComboBox Forms Support](slug:formssupport_combobox#toc-managing-the-combobox-disabled-state-in-reactive-forms) and [MultiColumnComboBox Forms Support](slug:formssupport_multicolumncombobox#toc-managing-the-multicolumncombobox-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Defines a Boolean function that is executed for each data item in the component ([see examples]({% slug disableditems_combobox %})). Determines whether the item is disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   * @default false
   */
  readonly = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Enables the [filtering]({% slug filtering_combobox %}) functionality.
   * If set to `true`, the component emits the `filterChange` event.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_combobox %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings, {
      itemHeight: this.defaultVirtualItemHeight,
      pageSize: this.defaultVirtualPageSize
    });
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$42;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Fires each time the value is changed&mdash;
   * when the component is blurred or the value is cleared through the **Clear** button
   * ([see example](slug:events_combobox)).
   * When the value of the component is programmatically changed to `ngModel` or `formControl`
   * through its API or form binding, the `valueChange` event is not triggered because it
   * might cause a mix-up with the built-in `valueChange` mechanisms of the `ngModel` or `formControl` bindings.
   */
  valueChange = new EventEmitter();
  /**
   * Fires each time an item selection is changed ([see example](slug:events_combobox)).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires each time the user types in the input field. You can filter the source based on the passed filtration value ([see example](slug:events_combobox)).
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open. This event is preventable. If you cancel it, the popup remains closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close. This event is preventable. If you cancel it, the popup remains open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the ComboBox.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the ComboBox gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the user focuses the `input` element.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires each time the `input` element gets blurred.
   */
  inputBlur = new EventEmitter();
  /**
   * @hidden
   */
  escape = new EventEmitter();
  template;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  groupTemplate;
  fixedGroupTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  container;
  popupTemplate;
  searchbar;
  optionsList;
  select;
  widgetClasses = true;
  get isDisabled() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  get dir() {
    return this.direction;
  }
  _isFocused = false;
  get isFocused() {
    return this._isFocused;
  }
  set isFocused(value) {
    this.renderer[value ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = value;
  }
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  listBoxId = `k-${guid()}`;
  optionPrefix = `k-${guid()}`;
  popupRef;
  get popupWidth() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get popupHeight() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  onChangeCallback = (_) => {
  };
  onTouchedCallback = (_) => {
  };
  /**
   * Used for the default virtualization settings config.
   */
  defaultVirtualItemHeight = 28;
  /**
   * Used for the default virtualization settings config.
   */
  defaultVirtualPageSize = 50;
  valueSubscription;
  _filtering = false;
  _text = "";
  filterText = "";
  _open = false;
  _value;
  _valuePrimitive;
  _previousDataItem;
  suggestedText;
  backspacePressed;
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  popupMouseDownHandler = (event) => event.preventDefault();
  customValueSubject = new Subject();
  valueSubject = new Subject();
  clearValueSubject = new Subject();
  direction;
  subs = new Subscription();
  touchstartDisposeHandler;
  selectClickDisposeHandler;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, cdr, renderer, injector, hostElement, adaptiveService) {
    super();
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.dataService = dataService;
    this.zone = zone;
    this.cdr = cdr;
    this.renderer = renderer;
    this.injector = injector;
    this.hostElement = hostElement;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata4);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.data = [];
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.attachStreams();
    this.createValueStream();
    this.subscribeTouchEvents();
    this.attachSelectClickHandler();
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
  }
  createValueStream() {
    const valueStream = this.valueSubject.pipe(filter((candidate) => {
      const current = getter2(this.value, this.valueField);
      const newValue = getter2(candidate, this.valueField);
      let newText = getter2(candidate, this.textField);
      if (!isPresent5(this.value) && !isPresent5(newValue)) {
        return false;
      }
      if (isPresent5(newText)) {
        newText = newText.toString();
      }
      if (current === newValue && this.text === newText) {
        this.clearFilter();
        return false;
      } else {
        return true;
      }
    }), map((candidate) => {
      const newValue = getter2(candidate, this.valueField);
      const newText = getter2(candidate, this.textField);
      return {
        dataItem: candidate,
        text: newText,
        value: this.valuePrimitive ? newValue : candidate
      };
    }));
    const customValueStreams = partition(() => this.allowCustom)(this.customValueSubject.pipe(throttleTime(300)));
    const allowCustomValueStream = customValueStreams[0].pipe(tap(() => {
      this.loading = true;
      this.disabled = true;
      this.cdr.detectChanges();
    }), filter(() => {
      const hasChange = this.text !== getter2(this.value, this.valueField);
      this.loading = hasChange;
      this.disabled = hasChange;
      if (!hasChange) {
        this.clearFilter();
      }
      return hasChange;
    }), this.valueNormalizer, map((normalizedValue) => {
      return {
        custom: true,
        dataItem: normalizedValue,
        text: this.text,
        value: normalizedValue
      };
    }));
    const disableCustomValueStream = customValueStreams[1].pipe(map(() => {
      return {
        custom: true,
        dataItem: void 0,
        text: void 0,
        value: void 0
      };
    }));
    const clearValueStream = this.clearValueSubject.pipe(map(() => ({
      dataItem: void 0,
      text: void 0,
      value: void 0
    })));
    if (this.valueSubscription) {
      this.valueSubscription.unsubscribe();
    }
    const merged = merge(valueStream, allowCustomValueStream, disableCustomValueStream, clearValueStream);
    this.valueSubscription = merged.pipe(catchError(() => {
      const selectionChanged = getter2(this.dataItem, this.valueField) !== void 0;
      this.dataItem = void 0;
      this.value = void 0;
      this.text = void 0;
      this.loading = false;
      this.disabled = false;
      if (selectionChanged) {
        this.selectionChange.emit(void 0);
      }
      this.emitValueChange();
      this.createValueStream();
      return of(null);
    })).subscribe((state) => {
      const selectionChanged = getter2(this.dataItem, this.valueField) !== getter2(state.dataItem, this.valueField);
      this.dataItem = state.dataItem;
      this.value = state.value;
      this.text = state.text;
      this.loading = false;
      this.disabled = false;
      this.clearFilter();
      if (state.custom) {
        this.selectionService.focused = -1;
      }
      if (selectionChanged) {
        const selectionArgs = state.custom ? void 0 : this.dataItem;
        this.selectionChange.emit(selectionArgs);
      }
      this.emitValueChange();
    });
  }
  attachStreams() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.home, this.navigationService.end).pipe(filter((event) => isPresent5(event.index))).subscribe((event) => this.navigate(event.index)));
    this.subs.add(this.navigationService.open.subscribe(this.handleNavigationOpen.bind(this)));
    this.subs.add(this.navigationService.close.subscribe(() => this.togglePopup(false)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(this.navigationService.enter.pipe(tap((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
      }
    })).subscribe(this.handleEnter.bind(this)));
    this.subs.add(merge(this.selectionService.onChange, this.selectionService.onSelect.pipe(filter(() => !this.isOpen))).pipe(tap(() => {
      this._filtering = false;
      this.togglePopup(false);
    }), map((event) => this.dataService.itemAt(event.indices[0]))).subscribe((dataItem) => {
      this.change(dataItem);
    }));
    this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), tap(() => this._filtering = false), map((event) => this.dataService.itemAt(event.indices[0]))).subscribe((dataItem) => {
      const selectionChanged = getter2(dataItem, this.valueField) !== getter2(this.dataItem, this.valueField);
      this.updateState({
        dataItem
      });
      if (selectionChanged) {
        this.selectionChange.emit(dataItem);
      }
    }));
  }
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    if (isPresent5(this.valueSubscription)) {
      this.valueSubscription.unsubscribe();
    }
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
    if (this.selectClickDisposeHandler) {
      this.selectClickDisposeHandler();
    }
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("valueNormalizer", changes)) {
      this.createValueStream();
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.setState();
    }
  }
  ngAfterContentChecked() {
    this.verifySettings();
  }
  /**
   * Focuses a specific item of the ComboBox based on a provided index.
   * If null or invalid index is provided the focus will be removed.
   */
  focusItemAt(index) {
    const isInRange = index >= 0 && index < this.data.length;
    if (isPresent5(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(-1);
    }
  }
  /**
   * Focuses the ComboBox.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * Blurs the ComboBox.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * Toggles the visibility of the popup or actionSheet. If you use the `toggle` method to open or close the popup or actionSheet,
   * the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !this._open;
      this._toggle(shouldOpen);
      this.cdr.markForCheck();
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(this._open || this.isActionSheetExpanded);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * Resets the value of the ComboBox.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `selectionChange` and `valueChange` events will not be fired.
   */
  reset() {
    this.value = void 0;
    this.clearState();
    this.resetSelection();
  }
  /**
   * @hidden
   *
   * Used by the TextBoxContainer to determine if the floating label
   * should be rendered in the input when the component is not focused.
   */
  isEmpty() {
    const textEmpty = !isPresent5(this.text) || isEmptyString(this.text);
    const valueEmpty = !isPresent5(this.value) || isEmptyString(this.value);
    return textEmpty && valueEmpty;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event?.stopImmediatePropagation();
    if (event) {
      this.focus();
    }
    this._previousDataItem = void 0;
    this.selectionService.resetSelection([]);
    this.clearValueSubject.next();
    this._filtering = false;
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value === null ? void 0 : value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}
        `;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.popupWidth;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.valuePrimitive === true && isPresent5(this.value) && typeof this.value === "object") {
      throw new Error(ComboBoxMessages.primitive);
    }
    if (this.valuePrimitive === false && isPresent5(this.value) && typeof this.value !== "object") {
      throw new Error(ComboBoxMessages.object);
    }
    const valueOrText = !isPresent5(this.valueField) !== !isPresent5(this.textField);
    if (valueOrText) {
      throw new Error(ComboBoxMessages.textAndValue);
    }
    if (this.virtual && isNaN(this.virtual.itemHeight)) {
      throw new Error(ComboBoxMessages.noItemHeight);
    }
  }
  setState() {
    if (this._filtering) {
      return;
    }
    const value = this.value;
    const valueField = this.valueField;
    const resolved = this.findDataItem({
      valueField,
      value
    });
    if (isPresent5(resolved.index) && resolved.index !== -1) {
      this.updateState({
        dataItem: resolved.dataItem,
        confirm: true
      });
      this.resetSelection(resolved.index);
    } else if (isPresent5(value) && this.allowCustom) {
      this.updateState({
        dataItem: value
      });
      this.resetSelection(-1);
    } else if (this._previousDataItem && this.value) {
      this.updateState({
        dataItem: this._previousDataItem
      });
      this.resetSelection();
    } else {
      this.clearState();
      this.resetSelection(-1);
    }
  }
  updateState({
    dataItem,
    confirm = false
  }) {
    this.dataItem = dataItem;
    this.text = getter2(dataItem, this.textField);
    if (confirm) {
      this._previousDataItem = dataItem;
    }
  }
  clearState() {
    this.text = void 0;
    this.dataItem = void 0;
  }
  resetSelection(index) {
    const clear = !isPresent5(index) || index < 0;
    this.selectionService.resetSelection(clear ? [] : [index]);
    this.selectionService.focused = index;
  }
  firstFocusableIndex(index) {
    const maxIndex = this.data.length - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  findIndexPredicate(text) {
    if (this.dataService.grouped) {
      return (item) => {
        let itemText = getter2(item.value, this.textField);
        itemText = !isPresent5(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    } else {
      return (item) => {
        let itemText = getter2(item, this.textField);
        itemText = !isPresent5(itemText) ? "" : itemText.toString().toLowerCase();
        return itemText.startsWith(text.toLowerCase());
      };
    }
  }
  findDataItem({
    valueField,
    value
  }) {
    const result = {
      dataItem: null,
      index: -1
    };
    const comparer = (element) => {
      const dataItem = this.dataService.grouped ? element.value : element;
      return getter2(dataItem, valueField) === getter2(value, valueField);
    };
    const index = this.dataService.findIndex(comparer);
    result.dataItem = this.dataService.itemAt(index);
    result.index = index;
    return result;
  }
  search(text, startFrom = 0) {
    const index = this.findIndex(text, startFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      if (index + 1 < this.dataService.itemsCount) {
        this.search(text, index + 1);
      } else {
        this.selectionService.focus(-1);
      }
    } else {
      this.selectionService.focus(index);
      if (this.suggest) {
        this.suggestedText = getter2(this.dataService.itemAt(index), this.textField);
      }
    }
  }
  /**
   * @hidden
   */
  getSuggestion() {
    const hasSelected = !!this.selectionService.selected.length;
    const shouldSuggest = this.suggest && !this.backspacePressed && this.suggestedText && this.text;
    if (!hasSelected && shouldSuggest && this.suggestedText.toLowerCase().startsWith(this.text.toLowerCase())) {
      return this.suggestedText;
    } else {
      this.suggestedText = void 0;
    }
  }
  navigate(index) {
    if (this.dataService.itemsCount === 0) {
      return;
    }
    this.text = getter2(this.dataService.itemAt(index), this.textField);
    this.selectionService.select(index);
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const hasSelected = isPresent5(this.selectionService.selected[0]);
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(0) : this.selectionService.focused;
    let offset = 0;
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.keyCode === Keys.Home || event.keyCode === Keys.End) {
      return;
    }
    if (!hasSelected) {
      if (event.keyCode === Keys.ArrowDown) {
        offset = -1;
      } else if (event.keyCode === Keys.ArrowUp) {
        offset = 1;
      }
    }
    const action = this.navigationService.process({
      current: offset + focused,
      max: this.dataService.itemsCount - 1,
      min: 0,
      originalEvent: event
    });
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Left && action !== NavigationAction.Right && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter)) {
      event.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      event.stopImmediatePropagation();
      this.togglePopup(false);
    }
  }
  handleEnter() {
    const text = this.text;
    const focused = this.selectionService.focused;
    const hasFocused = isPresent5(focused) && focused !== -1;
    const previousText = getter2(this._previousDataItem, this.textField) || "";
    const focusedItemText = getter2(this.dataService.itemAt(focused), this.textField);
    const textHasChanged = text !== previousText;
    this.togglePopup(false);
    this._filtering = false;
    if (this.allowCustom && textHasChanged) {
      if (text === focusedItemText || this.useSuggestion()) {
        this.selectionService.change(focused);
      } else {
        this.change(text, true);
      }
    }
    if (!this.allowCustom) {
      if (hasFocused) {
        this.selectionService.change(focused);
      } else if (textHasChanged) {
        this.change(text, true);
      }
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this.zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      this.blurComponent();
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      this._filtering = false;
      this.searchbar.input.nativeElement.scrollLeft = 0;
      const unresolvedSelection = getter2(this.dataItem, this.valueField) !== getter2(this.value, this.valueField);
      const currentText = this.searchbar.value;
      const textHasChanged = currentText !== (getter2(this.dataItem, this.textField) || "");
      const valueHasChanged = unresolvedSelection || textHasChanged;
      const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur";
      if (runInZone) {
        this.zone.run(() => {
          if (valueHasChanged) {
            const lowerCaseMatch = isPresent5(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();
            if (lowerCaseMatch || unresolvedSelection) {
              this.selectionService.change(this.selectionService.focused);
            } else {
              this.change(currentText, true);
            }
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
          this.togglePopup(false);
        });
      } else {
        this.togglePopup(false);
      }
    }
  }
  /**
   * @hidden
   */
  handleEscape() {
    this.isOpen ? this.togglePopup(false) : this.clearValue();
    const hasSelected = this.selectionService.selected.length > 0;
    if (!hasSelected) {
      this.suggestedText = null;
      this.selectionService.focused = -1;
    }
    hasObservers(this.escape) && this.escape.emit();
  }
  /**
   * @hidden
   */
  handleNavigationOpen() {
    this.restoreItemFocus();
    this.togglePopup(true);
  }
  /**
   * @hidden
   */
  searchBarChange(text) {
    const currentTextLength = this.text ? this.text.length : 0;
    this.backspacePressed = Boolean(text.length < currentTextLength);
    this.text = text;
    this.selectionService.resetSelection([]);
    this.togglePopup(true);
    this._filtering = true;
    if (this.filterable && this.filterText !== text) {
      this.filterText = text;
      this.filterChange.emit(text);
    } else {
      this.search(text);
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this.zone.run(() => this.inputFocus.emit());
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  /**
   * @hidden
   */
  closeActionSheet() {
    this.blurComponent();
    this.closed.emit();
  }
  change(candidate, isCustom = false) {
    if (isCustom) {
      this.customValueSubject.next(candidate);
    } else {
      this.valueSubject.next(candidate);
      if (this.isActionSheetExpanded) {
        this.togglePopup(false);
      }
    }
  }
  emitValueChange() {
    this.onChangeCallback(this.value);
    this.valueChange.emit(this.value);
    this._previousDataItem = this.dataItem;
  }
  /**
   * @hidden
   */
  selectClick() {
    if (!touchEnabled) {
      this.searchbar.focus();
      this.isFocused = true;
    }
    if (!this.isOpen) {
      this.restoreItemFocus();
    }
    this.togglePopup(!this.isOpen);
  }
  get listContainerClasses() {
    return ["k-list-container", "k-combobox-popup"].concat(this.popupSettings.popupClass || []);
  }
  /**
   * @hidden
   */
  preventEventDefault(event) {
    event.preventDefault();
  }
  get focusedItemText() {
    const focused = this.selectionService.focused;
    if (!isPresent5(focused) || focused === -1) {
      return null;
    }
    const itemText = getter2(this.dataService.itemAt(focused), this.textField);
    return !isPresent5(itemText) ? "" : itemText.toString();
  }
  /**
   * Focuses the first match when there's text in the input field, but no focused item.
   */
  restoreItemFocus() {
    const hasFocus = isPresent5(this.selectionService.focused) && this.selectionService.focused > -1;
    if (!hasFocus && this.text && this.dataService.itemsCount) {
      if (this.filterable) {
        this.selectionService.focused = this.firstFocusableIndex(0);
      } else {
        this.search(this.text);
      }
    }
  }
  useSuggestion() {
    if (!(this.suggest && isPresent5(this.searchbar.value))) {
      return false;
    }
    const focusedDataItem = this.dataService.itemAt(this.selectionService.focused);
    const focusedItemText = getter2(focusedDataItem, this.textField);
    if (!isPresent5(focusedItemText)) {
      return false;
    }
    return this.searchbar.value.toLowerCase() === focusedItemText.toLowerCase();
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute",
      anchorAlign: anchorPosition,
      popupAlign: popupPosition
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.popupWidth;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.popupHeight;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
    this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false));
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.actionSheet.toggle(false);
      this.focus();
    }
    if (this._open) {
      this.windowSize = this.adaptiveService.size;
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  clearFilter() {
    if (!(this.filterable && this.filterText)) {
      return;
    }
    this.filterText = "";
    this.filterChange.emit(this.filterText);
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this.zone.runOutsideAngular(() => (
      // Roll up ComboBox on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        const isInDropDown = inDropDown(this.wrapper, target, this.popupRef);
        if (this.isFocused && !isInDropDown) {
          this.zone.run(() => this.blur());
        } else if (this.isOpen && !isInDropDown) {
          this.zone.run(() => this.togglePopup(false));
        }
      })
    ));
  }
  attachSelectClickHandler() {
    const selectElement = this.select.nativeElement;
    const event = pointers ? "pointerdown" : "click";
    this.selectClickDisposeHandler = this.renderer.listen(selectElement, event, this.selectClick.bind(this));
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  findIndex(value, startFrom = 0) {
    let index;
    if (value && value.length && this.dataService.itemsCount) {
      index = this.dataService.findIndex(this.findIndexPredicate(value), startFrom);
    } else {
      index = -1;
    }
    return index;
  }
  openActionSheet() {
    this.windowSize = this.adaptiveService.size;
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.adaptiveTitle = setActionSheetTitle(this.searchbar.input, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  blurComponent() {
    this._filtering = false;
    this.searchbar.input.nativeElement.scrollLeft = 0;
    this.isFocused = false;
    const unresolvedSelection = getter2(this.dataItem, this.valueField) !== getter2(this.value, this.valueField);
    const currentText = this.searchbar.value;
    const textHasChanged = currentText !== (getter2(this.dataItem, this.textField) || "");
    const valueHasChanged = unresolvedSelection || textHasChanged;
    const runInZone = valueHasChanged || hasObservers(this.onBlur) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement);
    if (runInZone) {
      this.zone.run(() => {
        if (valueHasChanged) {
          const lowerCaseMatch = isPresent5(this.focusedItemText) && this.focusedItemText.toLowerCase() === currentText.toLowerCase();
          if (lowerCaseMatch || unresolvedSelection) {
            this.selectionService.change(this.selectionService.focused);
          } else {
            this.change(currentText, true);
          }
        }
        this.onBlur.emit();
        this.onTouchedCallback();
        this.togglePopup(false);
      });
    } else {
      this.togglePopup(false);
    }
  }
  static ɵfac = function ComboBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ComboBoxComponent,
    selectors: [["kendo-combobox"]],
    contentQueries: function ComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function ComboBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(_c142, 5);
        ɵɵviewQuery(_c162, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.select = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function ComboBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-combobox", ctx.widgetClasses)("k-input", ctx.widgetClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      inputAttributes: "inputAttributes",
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      allowCustom: "allowCustom",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      valuePrimitive: "valuePrimitive",
      valueNormalizer: "valueNormalizer",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      loading: "loading",
      suggest: "suggest",
      clearButton: "clearButton",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      filterable: "filterable",
      virtual: "virtual",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode"
    },
    outputs: {
      valueChange: "valueChange",
      selectionChange: "selectionChange",
      filterChange: "filterChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      escape: "escape"
    },
    exportAs: ["kendoComboBox"],
    standalone: true,
    features: [ɵɵProvidersFeature([COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.combobox"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _ComboBoxComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 20,
    vars: 38,
    consts: () => {
      let i18n_4;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_4 = goog.getMsg("NO DATA FOUND");
        i18n_4 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_4;
      } else {
        i18n_4 = $localize`:kendo.combobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_5;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_5 = goog.getMsg("clear");
        i18n_5 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_5;
      } else {
        i18n_5 = $localize`:kendo.combobox.clearTitle|The title of the clear button:clear`;
      }
      let i18n_6;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_6 = goog.getMsg("Select");
        i18n_6 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_6;
      } else {
        i18n_6 = $localize`:kendo.combobox.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_7;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_7 = goog.getMsg("Options list");
        i18n_7 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_7;
      } else {
        i18n_7 = $localize`:kendo.combobox.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_8;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_8 = goog.getMsg("Close");
        i18n_8 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_8;
      } else {
        i18n_8 = $localize`:kendo.combobox.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["select", ""], ["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["kendoComboBoxLocalizedMessages", "", "noDataText", i18n_4, "clearTitle", i18n_5, "selectButtonText", i18n_6, "popupLabel", i18n_7, "adaptiveCloseButtonTitle", i18n_8], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaExpanded", "ariaControls", "id", "isLoading", "isSuggestable", "isFilterable", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "kendoEventsOutsideAngular", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["tabindex", "-1", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "keydown.enter", "ngClass", "kendoEventsOutsideAngular"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "placeholder", "searchBarValue"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click", "kendoEventsOutsideAngular"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function ComboBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementContainerStart(1, 6);
        ɵɵtwoWayListener("isFocusedChange", function ComboBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function ComboBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function ComboBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, ComboBoxComponent_span_2_Template, 2, 1, "span", 7)(3, ComboBoxComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 8);
        ɵɵelementStart(4, "input", 9);
        ɵɵlistener("onNavigate", function ComboBoxComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function ComboBoxComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function ComboBoxComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function ComboBoxComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function ComboBoxComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, ComboBoxComponent_span_5_Template, 2, 7, "span", 10)(6, ComboBoxComponent_span_6_Template, 1, 0, "span", 11)(7, ComboBoxComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 8)(8, ComboBoxComponent_span_8_Template, 2, 1, "span", 12);
        ɵɵelementStart(9, "button", 13, 0);
        ɵɵlistener("keydown.enter", function ComboBoxComponent_Template_button_keydown_enter_9_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.stopImmediatePropagation());
        });
        ɵɵelement(11, "kendo-icon-wrapper", 14);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
        ɵɵtemplate(12, ComboBoxComponent_ng_template_12_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, ComboBoxComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 15);
        ɵɵelementContainer(15, null, 2);
        ɵɵelementStart(17, "kendo-adaptive-renderer", 16);
        ɵɵlistener("closePopup", function ComboBoxComponent_Template_kendo_adaptive_renderer_closePopup_17_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.closeActionSheet());
        })("textInputChange", function ComboBoxComponent_Template_kendo_adaptive_renderer_textInputChange_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("navigate", function ComboBoxComponent_Template_kendo_adaptive_renderer_navigate_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(18, ComboBoxComponent_ng_template_18_Template, 5, 17, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaExpanded", ctx.isOpen)("ariaControls", ctx.ariaControls)("id", ctx.focusableId)("isLoading", ctx.loading)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.getSuggestion())("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton && !ctx.loading && !ctx.disabled && !ctx.readonly && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(36, _c172, ctx.preventEventDefault));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", true)("subtitle", ctx.adaptiveSubtitle)("placeholder", ctx.placeholder)("searchBarValue", ctx.text);
      }
    },
    dependencies: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoComboBox",
      providers: [COMBOBOX_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.combobox"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => ComboBoxComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => ComboBoxComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => ComboBoxComponent)
      }],
      selector: "kendo-combobox",
      template: `
        <ng-container kendoComboBoxLocalizedMessages
            i18n-noDataText="kendo.combobox.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.combobox.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-selectButtonText="kendo.combobox.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-popupLabel="kendo.combobox.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.combobox.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input
                kendoSearchbar
                [ariaExpanded]="isOpen"
                [ariaControls]="ariaControls"
                [id]="focusableId"
                [isLoading]="loading"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="getSuggestion()"
                [disabled]="disabled"
                [readonly]="readonly || isAdaptive"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="clearButton && !loading && !disabled && !readonly && text?.length"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                aria-hidden="true"
                [attr.title]="messageFor('clearTitle')"
                (click)="clearValue($event)"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <button
                #select
                tabindex="-1"
                unselectable="on"
                type="button"
                class="k-input-button k-button k-icon-button"
                [ngClass]="selectButtonClasses"
                [attr.aria-label]="messageFor('selectButtonText')"
                [attr.disabled]="disabled ? '' : null"
                (keydown.enter)="$event.stopImmediatePropagation();"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    [name]="icon || 'caret-alt-down'"
                    innerCssClass="k-button-icon"
                    [svgIcon]="svgIcon || caretAltDownIcon"
                >
                </kendo-icon-wrapper>
            </button>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="true"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="closeActionSheet()"
            (textInputChange)="searchBarChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            [searchBarValue]="text"
        >
        </kendo-adaptive-renderer>
        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="isAdaptive ? 'large' : size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)"
            >
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService2
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    adaptiveRendererComponent: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    allowCustom: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    valueNormalizer: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    suggest: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    escape: [{
      type: Output
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    select: [{
      type: ViewChild,
      args: ["select", {
        static: true
      }]
    }],
    widgetClasses: [{
      type: HostBinding,
      args: ["class.k-combobox"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }]
  });
})();
var ValueTemplateDirective = class _ValueTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ValueTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ValueTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ValueTemplateDirective,
    selectors: [["", "kendoDropDownListValueTemplate", ""], ["", "kendoDropDownTreeValueTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ValueTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownListValueTemplate],[kendoDropDownTreeValueTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var FilterInputDirective = class _FilterInputDirective {
  element;
  zone;
  focused;
  constructor(element, zone) {
    this.element = element;
    this.zone = zone;
  }
  ngOnChanges() {
    if (this.focused) {
      this.nextTick(() => this.element.nativeElement.focus());
    }
  }
  nextTick(fn) {
    this.zone.runOutsideAngular(() => setTimeout(fn));
  }
  static ɵfac = function FilterInputDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterInputDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterInputDirective,
    selectors: [["", "filterInput", ""]],
    inputs: {
      focused: [0, "filterInput", "focused"]
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterInputDirective, [{
    type: Directive,
    args: [{
      selector: "[filterInput]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, {
    focused: [{
      type: Input,
      args: ["filterInput"]
    }]
  });
})();
var DROPDOWNLIST_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DropDownListComponent)
};
var DEFAULT_SIZE$32 = "medium";
var DEFAULT_ROUNDED$32 = "medium";
var DEFAULT_FILL_MODE$32 = "solid";
var DropDownListComponent = class _DropDownListComponent {
  wrapper;
  localization;
  popupService;
  selectionService;
  navigationService;
  disabledItemsService;
  dataService;
  _zone;
  renderer;
  cdr;
  injector;
  adaptiveService;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  caretAltDownSVGIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  customIconClass;
  /**
   * @hidden
   */
  adaptiveRenderer;
  /**
   * @hidden
   */
  searchInput;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRenderer?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRenderer?.actionSheetSearchBar;
  }
  get width() {
    const wrapperWidth = isDocumentAvailable() ? this.wrapper.nativeElement.offsetWidth : 0;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get widgetTabIndex() {
    if (this.disabled) {
      return void 0;
    }
    const providedTabIndex = Number(this.tabIndex);
    const defaultTabIndex = 0;
    return !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get ariaActivedescendant() {
    if (!isPresent5(this.dataItem) || !this.isOpen) {
      return;
    }
    return this.optionPrefix + "-" + this.selectionService.focused;
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    }
  }
  /**
   * @hidden
   */
  get ariaLive() {
    return this.filterable ? "polite" : "off";
  }
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * The sticky header displays by default. [see example.]({% slug grouping_autocomplete %}#toc-sticky-header)
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * Sets and gets the loading state of the `DropDownListComponent`.
   */
  loading;
  /**
   * Sets the data of the `DropDownListComponent`.
   *
   * The data must be an array-like list.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.setState();
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the value of the `DropDownListComponent`.
   * The value can be a primitive (string, number) or a complex object.
   * Use the `valuePrimitive` option to define the type.
   *
   * All selected values not present in the source are ignored.
   */
  set value(newValue) {
    if (!isPresent5(newValue)) {
      this._previousDataItem = void 0;
    }
    this._value = newValue;
    this.setState();
    this.cdr.markForCheck();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data item field that represents the item text.
   * If the data contains only primitive values, do not define this property.
   *
   * The `textField` property can point to a nested property value, for example, `category.name`.
   */
  textField;
  /**
   * Sets the data item field that represents the item value.
   * If the data contains only primitive values, do not define this property.
   *
   * The `valueField` property can point to a nested property value, for example, `category.id`.
   */
  valueField;
  /**
   * Enables or disables the adaptive mode. The adaptive rendering is disabled by default.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet rendered instead of the Popup on small screens.
   * By default, the ActionSheet title uses the label text of the `DropDownListComponent`.
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle of the ActionSheet rendered instead of the Popup on small screens.
   * By default, the ActionSheet does not render a subtitle.
   */
  adaptiveSubtitle = "";
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * Configures the popup of the `DropDownListComponent`.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. The open and close animations are enabled by default.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped. The `auto` mode is not supported when virtual scrolling is enabled.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup.
   *
   * The `listHeight` property affects only the list of options, not the whole popup container.
   * To set the height of the popup container, use `popupSettings.height`.
   *
   * When using `adaptiveMode` and the screen size is `small` or `medium`, the `listHeight` property is set to null.
   *
   * @default 200
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets the text of the default empty item. The value type must match the data type.
   */
  defaultItem;
  /**
   * Sets the disabled state of the component. To disable the component in reactive forms, see [Forms Support](slug:formssupport_ddl#toc-managing-the-dropdownlist-disabled-state-in-reactive-forms).
   */
  disabled;
  /**
   * Defines a Boolean function executed for each data item in the component. Determines whether the item is disabled. [See examples.]({% slug disableditems_ddl %})
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Enables the [filtering]({% slug filtering_ddl %}) functionality of the `DropDownListComponent`.
   */
  filterable = false;
  /**
   * Enables the [virtualization]({% slug virtualization_ddl %}) functionality.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Enables a case-insensitive search. Use this option when filtration is disabled.
   */
  ignoreCase = true;
  /**
   * Sets the delay before an item search is performed. Use this option when filtration is disabled.
   */
  delay = 500;
  /**
   * Specifies the type of the selected value. If set to `true`, the selected value must be a primitive value.
   * * [More information and example.]({% slug valuebinding_ddl %}#toc-primitive-values-from-object-fields)
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent5(this._valuePrimitive)) {
      return !isPresent5(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = rounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$32;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Toggles the left and right arrow keys navigation functionality.
   * @hidden
   */
  leftRightArrowsNavigation = true;
  /**
   * Fires each time the value changes. [See example.](slug:events_ddl).
   */
  valueChange = new EventEmitter();
  /**
   ** Fires each time the user types in the input field. You can filter the source based on the filtration value. When the value is programmatically changed, the `valueChange` event is not triggered. [See example.](slug:events_ddl).
   */
  filterChange = new EventEmitter();
  /**
   * Fires each time the item selection changes. [see example.](slug:events_ddl).
   */
  selectionChange = new EventEmitter();
  /**
   * Fires each time the popup is about to open. This event is preventable. If you cancel it, the popup remains closed. [see example.]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close. This event is preventable. If you cancel it, the popup remains open. [see example.]({% slug openstate_ddl %}#toc-preventing-opening-and-closing)
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires each time the user focuses the `DropDownListComponent`.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the `DropDownListComponent` gets blurred.
   */
  onBlur = new EventEmitter();
  itemTemplate;
  groupTemplate;
  fixedGroupTemplate;
  valueTemplate;
  headerTemplate;
  footerTemplate;
  noDataTemplate;
  container;
  popupTemplate;
  optionsList;
  /**
   * @hidden
   */
  blurComponent(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.hostElementBlurred.emit();
  }
  /**
   * @hidden
   */
  blurFilterInput() {
    this.filterBlurred.emit();
  }
  /**
   * @hidden
   */
  focusComponent(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.hostElementFocused.emit();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
    }
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  hostClasses = true;
  get isDisabledClass() {
    return this.disabled || null;
  }
  get isLoading() {
    return this.loading;
  }
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  get dir() {
    return this.direction;
  }
  get hostTabIndex() {
    return this.widgetTabIndex;
  }
  get readonlyClass() {
    return this.readonly;
  }
  get readonlyAttr() {
    return this.readonly ? "" : null;
  }
  get isBusy() {
    return this.isLoading;
  }
  role = "combobox";
  haspopup = "listbox";
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  /**
   * @hidden
   */
  keydown(event, input) {
    if (input) {
      event.stopPropagation();
    }
    const firstIndex = isPresent5(this.defaultItem) ? -1 : 0;
    const focused = isNaN(this.selectionService.focused) ? this.firstFocusableIndex(firstIndex) : this.selectionService.focused;
    let offset = 0;
    if (this.disabled || this.readonly) {
      return;
    }
    const isHomeEnd = event.keyCode === Keys.Home || event.keyCode === Keys.End;
    const isFilterFocused = this.filterable && this.isFocused && this.isOpen;
    if (isFilterFocused && isHomeEnd) {
      return;
    }
    const hasSelected = isPresent5(this.selectionService.selected[0]);
    const focusedItemNotSelected = isPresent5(this.selectionService.focused) && !this.selectionService.isSelected(this.selectionService.focused);
    if (!hasSelected || focusedItemNotSelected) {
      if (event.keyCode === Keys.ArrowDown || event.keyCode === Keys.ArrowRight && this.leftRightArrowsNavigation) {
        offset = -1;
      } else if (event.keyCode === Keys.ArrowUp || event.keyCode === Keys.ArrowLeft && this.leftRightArrowsNavigation) {
        offset = 1;
      }
    }
    const eventData = event;
    const action = this.navigationService.process({
      current: focused + offset,
      max: this.dataService.itemsCount - 1,
      min: this.defaultItem ? -1 : 0,
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)
    });
    const leftRightKeys = action === NavigationAction.Left || action === NavigationAction.Right && this.leftRightArrowsNavigation;
    if (action !== NavigationAction.Undefined && action !== NavigationAction.Tab && action !== NavigationAction.Backspace && action !== NavigationAction.Delete && action !== NavigationAction.PageDown && action !== NavigationAction.PageUp && action !== NavigationAction.SelectAll && !(leftRightKeys && this.filterable) && action !== NavigationAction.Enter) {
      eventData.preventDefault();
    }
    if (action === NavigationAction.Tab && this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
  }
  /**
   * @hidden
   */
  keypress(event) {
    if (this.disabled || this.readonly || this.filterable) {
      return;
    }
    this.onKeyPress(event);
  }
  /**
   * @hidden
   */
  click() {
    if (!this.isActionSheetExpanded) {
      this.focus();
      this.togglePopup(!this.isOpen);
    }
  }
  groupIndices = [];
  optionPrefix = `k-${guid()}`;
  valueLabelId;
  filterText = "";
  listBoxId = `k-${guid()}`;
  subs = new Subscription();
  _isFocused = false;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  direction;
  dataItem;
  popupRef;
  onTouchedCallback = (_) => {
  };
  onChangeCallback = (_) => {
  };
  popupMouseDownHandler;
  word = "";
  last = "";
  typingTimeout;
  filterFocused = new EventEmitter();
  filterBlurred = new EventEmitter();
  hostElementFocused = new EventEmitter();
  hostElementBlurred = new EventEmitter();
  touchstartDisposeHandler;
  _value;
  _open = false;
  _previousDataItem;
  _valuePrimitive;
  text;
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  constructor(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, _zone, renderer, cdr, injector, adaptiveService) {
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.dataService = dataService;
    this._zone = _zone;
    this.renderer = renderer;
    this.cdr = cdr;
    this.injector = injector;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata4);
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.data = [];
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.subscribeFocusEvents();
    this.popupMouseDownHandler = this.onMouseDown.bind(this);
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    if (this.ariaActivedescendant) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-activedescendant", this.ariaActivedescendant);
    }
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.detectChanges();
    }));
    this.assignAriaDescribedBy();
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
  }
  /**
   * @hidden
   * Used by the TextBoxContainer to determine if the component is empty.
   */
  isEmpty() {
    const value = this.value;
    return !(value === 0 || value === false || value || this.defaultItem);
  }
  /**
   * @hidden
   */
  onFilterFocus() {
    this.filterFocused.emit();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes["data"] && changes["data"].isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("defaultItem", changes, false)) {
      this.disabledItemsService.defaultItem = this.defaultItem;
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive", "defaultItem", "itemDisabled"], changes, false)) {
      this.setState();
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * Focuses a specific item of the `DropDownListComponent` based on the provided index. If there is a default item, it is positioned at index `-1`. If `null` or an invalid index is provided, the focus is removed.
   */
  focusItemAt(index) {
    const minIndex = isPresent5(this.defaultItem) ? -1 : 0;
    const isInRange = minIndex <= index && index < this.data.length;
    if (isPresent5(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(null);
    }
  }
  /**
   * Focuses the `DropDownListComponent`.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Blurs the `DropDownListComponent`.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
      this.cdr.detectChanges();
    }
  }
  /**
   * Toggles the visibility of the Popup or ActionSheet. If you use the `toggle` method to open or close the Popup, the `open` and `close` events are not fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !this._open;
      this._toggle(shouldOpen);
    });
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this._open) {
      this.createPopup();
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented = this.triggerPopupEvents(open);
    if (!isDefaultPrevented) {
      if (!open && this.filterable && this.isFocused) {
        this.focus();
      }
      this._toggle(open);
    }
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(this._open || this.isActionSheetExpanded);
  }
  /**
   * Resets the value of the `DropDownListComponent`. If you use the `reset` method to clear the value, the model does not update automatically and the `selectionChange` and `valueChange` events are not fired.
   */
  reset() {
    this.value = void 0;
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value === null ? void 0 : value;
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}`;
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /**
   * @hidden
   */
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-dropdownlist-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  getText() {
    return this.text;
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute"
    });
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.listBoxId);
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    popupWrapper.addEventListener("mousedown", this.popupMouseDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    const listBox = popupWrapper.querySelector("ul.k-list-ul");
    const ariaLabel = this.wrapper.nativeElement.getAttribute("aria-labelledby");
    if (ariaLabel) {
      listBox.setAttribute("aria-labelledby", ariaLabel);
    }
    this.subs.add(this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);
      this.setAriaactivedescendant();
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    }));
    this.subs.add(this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    }));
    if (!this.filterable) {
      this.subs.add(this.popupRef.popupAnchorViewportLeave.subscribe(() => this.togglePopup(false)));
    }
  }
  destroyPopup() {
    if (this.popupRef) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-activedescendant");
      this.popupRef.popupElement.removeEventListener("mousedown", this.popupMouseDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  updateState({
    dataItem,
    confirm = false
  }) {
    this.dataItem = dataItem;
    this.text = getter2(dataItem, this.textField);
    if (confirm) {
      this._previousDataItem = dataItem;
    }
  }
  clearState() {
    this.text = void 0;
    this.dataItem = void 0;
  }
  resetSelection(index) {
    const clear = !isPresent5(index);
    this.selectionService.resetSelection(clear ? [] : [index]);
    this.selectionService.focused = clear ? this.firstFocusableIndex(0) : index;
  }
  onSelectionChange({
    dataItem
  }) {
    this.updateState({
      dataItem
    });
    this.selectionChange.emit(dataItem);
    this.assignAriaDescribedBy();
    this.setAriaactivedescendant();
  }
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.add(this.selectionService.onSelect.pipe(filter(() => this.isOpen), map(this.itemFromEvent.bind(this))).subscribe(this.onSelectionChange.bind(this)));
    this.subs.add(merge(this.selectionService.onSelect.pipe(filter(() => !this.isOpen)), this.selectionService.onChange).pipe(map(this.itemFromEvent.bind(this)), tap(() => this.togglePopup(false))).subscribe(({
      dataItem,
      value: newValue,
      newSelection
    }) => {
      if (newSelection) {
        this.onSelectionChange({
          dataItem
        });
      }
      const shouldUsePrevious = !isPresent5(dataItem) && this._previousDataItem;
      const shouldUseNewValue = newValue !== getter2(this.value, this.valueField);
      if (shouldUsePrevious) {
        this.updateState({
          dataItem: this._previousDataItem
        });
        this.resetSelection();
      } else if (shouldUseNewValue) {
        this.value = this.valuePrimitive ? newValue : dataItem;
        this._previousDataItem = dataItem;
        this.emitChange(this.value);
      }
      this.clearFilter();
    }));
    this.subs.add(merge(this.navigationService.up, this.navigationService.down, this.navigationService.left.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.right.pipe(filter(() => this.leftRightArrowsNavigation), skipWhile(() => this.filterable)), this.navigationService.home, this.navigationService.end).pipe(filter((event) => !isNaN(event.index))).subscribe((event) => this.selectionService.select(event.index)));
    this.subs.add(merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    }));
    this.subs.add(this.navigationService.open.subscribe(() => this.togglePopup(true)));
    this.subs.add(this.navigationService.close.subscribe(() => {
      this.togglePopup(false);
      this.focus();
    }));
    this.subs.add(this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe(this.handleEnter.bind(this)));
    this.subs.add(this.navigationService.esc.subscribe(this.handleEscape.bind(this)));
    this.subs.add(this.filterBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.hostElementFocused)))).subscribe(() => {
      this.hostElementBlurred.emit();
    }));
    this._zone.runOutsideAngular(() => {
      this.subs.add(merge(this.hostElementBlurred.pipe(concatMap(() => interval(10).pipe(take(1), takeUntil(this.filterFocused)))), this.navigationService.tab).pipe(tap((event) => event instanceof NavigationEvent && this.focus()), filter(() => this.isFocused), filter(() => {
        const isBrowserSafari = isDocumentAvailable() && isSafari(navigator.userAgent);
        if (!isBrowserSafari) {
          return true;
        }
        const hasFocusedKendoButton = this.popupRef?.popupElement.querySelector(".k-button.k-focus");
        const shouldNotBlur = this.searchInput && hasFocusedKendoButton && hasObservers(this.filterChange);
        if (shouldNotBlur) {
          this.searchInput.nativeElement.focus();
          this.isFocused = true;
        }
        return !shouldNotBlur;
      })).subscribe(() => this.componentBlur()));
    });
  }
  setAriaactivedescendant() {
    if (this.ariaActivedescendant) {
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-activedescendant", this.ariaActivedescendant);
      if (this.searchInput) {
        this.renderer.setAttribute(this.searchInput.nativeElement, "aria-activedescendant", this.ariaActivedescendant);
      }
    }
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !this.touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up DropDownList on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            if (this.filterFocused) {
              this.togglePopup(false);
            }
            this.blur();
          });
        }
      })
    ));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.focusComponent = this.focusComponent.bind(this);
      this.blurComponent = this.blurComponent.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.focusComponent, useCapture);
        document.addEventListener("blur", this.blurComponent, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.focusComponent, useCapture);
      document.removeEventListener("blur", this.blurComponent, useCapture);
    }
  }
  itemFromEvent(event) {
    const index = event.indices[0];
    let dataItem = this.dataService.itemAt(index);
    dataItem = isPresent5(dataItem) ? dataItem : this.currentOrDefault(index);
    const value = getter2(dataItem, this.valueField);
    const newSelection = event.newSelection;
    return {
      dataItem,
      index,
      newSelection,
      value
    };
  }
  currentOrDefault(selectedIndex) {
    const defaultItemIndex = -1;
    if (isPresent5(this.dataItem) && selectedIndex !== defaultItemIndex) {
      return this.dataItem;
    } else {
      return this.defaultItem;
    }
  }
  firstFocusableIndex(index) {
    const maxIndex = this.dataService.itemsCount - 1;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index < maxIndex ? this.firstFocusableIndex(index + 1) : void 0;
    } else {
      return index;
    }
  }
  handleEnter() {
    if (this.isOpen) {
      this.selectionService.change(this.selectionService.focused);
      this.focus();
    } else {
      this.togglePopup(true);
    }
  }
  handleEscape() {
    if (isPresent5(this.selectionService.selected[0])) {
      this.selectionService.change(this.selectionService.selected[0]);
    } else {
      this.togglePopup(false);
      this.clearFilter();
    }
    this.focus();
  }
  clearFilter() {
    if (!(this.filterable && this.filterText)) {
      return;
    }
    this.filterText = "";
    this.cdr.markForCheck();
    this.filterChange.emit(this.filterText);
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.defaultItem && this.valueField && typeof this.defaultItem !== "object") {
      throw new Error(DropDownListMessages.defaultItem);
    }
    if (this.valuePrimitive === true && isPresent5(this.value) && typeof this.value === "object") {
      throw new Error(DropDownListMessages.primitive);
    }
    if (this.valuePrimitive === false && isPresent5(this.value) && typeof this.value !== "object") {
      throw new Error(DropDownListMessages.object);
    }
    const valueOrText = !isPresent5(this.valueField) !== !isPresent5(this.textField);
    if (valueOrText) {
      throw new Error(DropDownListMessages.textAndValue);
    }
  }
  componentBlur() {
    if (!this.isActionSheetExpanded) {
      this.isFocused = false;
      const selectionPresent = isPresent5(this.selectionService.selected[0]);
      const valueHasChanged = selectionPresent && getter2(this.value, this.valueField) !== getter2(this.dataService.itemAt(this.selectionService.selected[0]), this.valueField);
      if (valueHasChanged || hasObservers(this.close) || hasObservers(this.onBlur) || hasObservers(this.filterChange) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          if (valueHasChanged) {
            this.selectionService.change(this.selectionService.selected[0]);
          }
          this.togglePopup(false);
          this.clearFilter();
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      } else {
        this.togglePopup(false);
        this.cdr.markForCheck();
      }
    }
  }
  /**
   * @hidden
   */
  onMouseDown(event) {
    const tagName = event.target.tagName.toLowerCase();
    if (tagName !== "input") {
      event.preventDefault();
    }
  }
  onKeyPress(event) {
    if (event.which === 0 || event.keyCode === Keys.Enter) {
      return;
    }
    let character = String.fromCharCode(event.charCode || event.keyCode);
    if (this.ignoreCase) {
      character = character.toLowerCase();
    }
    if (character === " ") {
      event.preventDefault();
    }
    this.word += character;
    this.last = character;
    this.search();
  }
  search() {
    clearTimeout(this.typingTimeout);
    if (!this.filterable) {
      this.typingTimeout = setTimeout(() => {
        this.word = "";
      }, this.delay);
      this.selectNext();
    }
  }
  selectNext() {
    let data = this.dataService.filter((item) => isPresent5(item) && !item.header && !this.disabledItemsService.isItemDisabled(item)).map((item) => {
      if (this.dataService.grouped) {
        return {
          item: item.value,
          itemIndex: item.offsetIndex
        };
      }
      return {
        item,
        itemIndex: this.dataService.indexOf(item)
      };
    });
    const isInLoop = sameCharsOnly(this.word, this.last);
    let dataLength = data.length;
    const hasSelected = !isNaN(this.selectionService.selected[0]);
    let startIndex = !hasSelected ? 0 : this.selectionService.selected[0];
    let text, index, defaultItem;
    if (this.defaultItem && !this.disabledItemsService.isItemDisabled(this.defaultItem)) {
      defaultItem = {
        item: this.defaultItem,
        itemIndex: -1
      };
      dataLength += 1;
      startIndex += 1;
    }
    startIndex += isInLoop && hasSelected ? 1 : 0;
    data = shuffleData(data, startIndex, defaultItem);
    index = 0;
    for (; index < dataLength; index++) {
      text = getter2(data[index].item, this.textField);
      const loopMatch = Boolean(isInLoop && matchText(text, this.last, this.ignoreCase));
      const nextMatch = Boolean(matchText(text, this.word, this.ignoreCase));
      if (loopMatch || nextMatch) {
        index = data[index].itemIndex;
        break;
      }
    }
    if (index !== dataLength) {
      this.navigate(index);
    }
  }
  emitChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  navigate(index) {
    this.selectionService.select(index);
  }
  findDataItem({
    valueField,
    value
  }) {
    const result = {
      dataItem: null,
      index: -1
    };
    const prop = (dataItem) => getter2(dataItem, valueField);
    let comparer;
    if (this.dataService.grouped) {
      comparer = (element) => {
        return prop(element.value) === prop(value);
      };
    } else {
      comparer = (element) => {
        return prop(element) === prop(value);
      };
    }
    const index = this.dataService.findIndex(comparer);
    result.dataItem = this.dataService.itemAt(index);
    result.index = index;
    return result;
  }
  setState() {
    const value = this.value;
    const valueField = this.valueField;
    const textField = this.textField;
    const primitive = this.valuePrimitive;
    if (this.defaultItem) {
      const defaultValue = getter2(this.defaultItem, valueField);
      const currentValue = getter2(value, valueField);
      if (!isPresent5(value) || currentValue === defaultValue) {
        this.updateState({
          dataItem: this.defaultItem,
          confirm: true
        });
        this.resetSelection(-1);
        if (this.filterable && this.filterText && this.dataService.itemsCount) {
          this.selectionService.focused = this.firstFocusableIndex(0);
        }
        return;
      }
    }
    const resolved = this.findDataItem({
      valueField,
      value
    });
    const ofSameType = !(primitive && textField);
    if (resolved.dataItem) {
      this.updateState({
        dataItem: resolved.dataItem,
        confirm: true
      });
      this.resetSelection(resolved.index);
    } else if (isPresent5(value) && ofSameType) {
      this.updateState({
        dataItem: value
      });
      this.resetSelection();
    } else if (this._previousDataItem) {
      this.updateState({
        dataItem: this._previousDataItem
      });
      this.resetSelection();
    } else {
      this.clearState();
      this.resetSelection();
    }
  }
  /**
   * @hidden
   */
  handleFilter(event) {
    this.filterChange.emit(event.target.value);
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  assignAriaDescribedBy() {
    const currentValue = this.wrapper.nativeElement.getAttribute("aria-describedby") || "";
    const trimmed = currentValue.replace(this.valueLabelId, "").trim();
    this.valueLabelId = `k-${guid()}`;
    const newValue = `${this.valueLabelId} ${trimmed}`.trim();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-describedby", newValue);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    }
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
    if (this.filterable) {
      this.adaptiveRenderer.searchBarValue = "";
      this.filterChange.emit("");
    }
    this.closed.emit();
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this.cdr.detectChanges();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.listBoxId);
    setListBoxAriaLabelledBy(this.optionsList, this.wrapper, this.renderer);
    this.setAriaactivedescendant();
    this.adaptiveTitle = setActionSheetTitle(this.wrapper, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.opened.emit();
  }
  static ɵfac = function DropDownListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownListComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropDownListComponent,
    selectors: [["kendo-dropdownlist"]],
    contentQueries: function DropDownListComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.itemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
      }
    },
    viewQuery: function DropDownListComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c182, 5);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(_c142, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRenderer = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 19,
    hostBindings: function DropDownListComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("keydown", function DropDownListComponent_keydown_HostBindingHandler($event) {
          return ctx.keydown($event);
        })("keypress", function DropDownListComponent_keypress_HostBindingHandler($event) {
          return ctx.keypress($event);
        })("click", function DropDownListComponent_click_HostBindingHandler() {
          return ctx.click();
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabledClass)("id", ctx.focusableId)("dir", ctx.dir)("tabindex", ctx.hostTabIndex)("readonly", ctx.readonlyAttr)("aria-busy", ctx.isBusy)("role", ctx.role)("aria-haspopup", ctx.haspopup)("aria-invalid", ctx.hostAriaInvalid);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-dropdownlist", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-disabled", ctx.isDisabledClass)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      customIconClass: "customIconClass",
      showStickyHeader: "showStickyHeader",
      icon: "icon",
      svgIcon: "svgIcon",
      loading: "loading",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      defaultItem: "defaultItem",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      readonly: "readonly",
      filterable: "filterable",
      virtual: "virtual",
      ignoreCase: "ignoreCase",
      delay: "delay",
      valuePrimitive: "valuePrimitive",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      leftRightArrowsNavigation: "leftRightArrowsNavigation",
      focusableId: [0, "id", "focusableId"]
    },
    outputs: {
      valueChange: "valueChange",
      filterChange: "filterChange",
      selectionChange: "selectionChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur"
    },
    exportAs: ["kendoDropDownList"],
    standalone: true,
    features: [ɵɵProvidersFeature([DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.dropdownlist"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _DropDownListComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DropDownListComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 16,
    vars: 19,
    consts: () => {
      let i18n_9;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_9 = goog.getMsg("NO DATA FOUND");
        i18n_9 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_9;
      } else {
        i18n_9 = $localize`:kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_10;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_10 = goog.getMsg("Select");
        i18n_10 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_10;
      } else {
        i18n_10 = $localize`:kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_11;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_11 = goog.getMsg("Filter");
        i18n_11 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_11;
      } else {
        i18n_11 = $localize`:kendo.dropdownlist.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_12;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_12 = goog.getMsg("Options list");
        i18n_12 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_12;
      } else {
        i18n_12 = $localize`:kendo.dropdownlist.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_13;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13 = goog.getMsg("Close");
        i18n_13 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_13;
      } else {
        i18n_13 = $localize`:kendo.dropdownlist.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["searchInput", ""], ["kendoDropDownListLocalizedMessages", "", "noDataText", i18n_9, "selectButtonText", i18n_10, "filterInputLabel", i18n_11, "popupLabel", i18n_12, "adaptiveCloseButtonTitle", i18n_13, "filterInputPlaceholder", "Filter"], ["unselectable", "on", 1, "k-input-inner", 3, "click", "id"], [1, "k-input-value-text"], [4, "ngIf"], [3, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["tabindex", "-1", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass", "kendoEventsOutsideAngular"], ["unselectable", "on", "innerCssClass", "k-button-icon", 3, "name", "customFontClass", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "filterable"], [3, "templateContext"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "id", "size", "rounded", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "virtual", "ariaLive", "showStickyHeader", "defaultItem"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter", 3, "click"], [1, "k-searchbox", "k-input", 3, "ngClass"], ["innerCssClass", "k-input-icon", "name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "searchbox", "aria-autocomplete", "list", "aria-haspopup", "listbox", "tabindex", "-1", 1, "k-input-inner", 3, "ngModelChange", "keydown", "input", "focus", "blur", "click", "filterInput", "dir", "ngModel"], [1, "k-no-data"], [3, "ngIf", "templateContext"]];
    },
    template: function DropDownListComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "span", 6);
        ɵɵlistener("click", function DropDownListComponent_Template_span_click_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.preventDefault());
        });
        ɵɵelementStart(2, "span", 7);
        ɵɵtemplate(3, DropDownListComponent_3_Template, 1, 4, null, 8)(4, DropDownListComponent_ng_template_4_Template, 1, 1, "ng-template", 9);
        ɵɵelementEnd()();
        ɵɵtemplate(5, DropDownListComponent_span_5_Template, 1, 0, "span", 10);
        ɵɵelementStart(6, "button", 11);
        ɵɵelement(7, "kendo-icon-wrapper", 12);
        ɵɵelementEnd();
        ɵɵtemplate(8, DropDownListComponent_ng_template_8_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(10, DropDownListComponent_kendo_resize_sensor_10_Template, 1, 0, "kendo-resize-sensor", 13);
        ɵɵelementContainer(11, null, 1);
        ɵɵelementStart(13, "kendo-adaptive-renderer", 14);
        ɵɵlistener("closePopup", function DropDownListComponent_Template_kendo_adaptive_renderer_closePopup_13_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function DropDownListComponent_Template_kendo_adaptive_renderer_textInputChange_13_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFilterChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(14, DropDownListComponent_ng_template_14_Template, 6, 20, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r3 = ɵɵreference(15);
        ɵɵadvance();
        ɵɵproperty("id", ctx.valueLabelId);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx.valueTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.valueTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(17, _c172, ctx.onMouseDown));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance();
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("customFontClass", ctx.customIconClass)("svgIcon", ctx.svgIcon || ctx.caretAltDownSVGIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r3)("title", ctx.adaptiveTitle)("showTextInput", ctx.filterable)("subtitle", ctx.adaptiveSubtitle)("filterable", ctx.filterable);
      }
    },
    dependencies: [LocalizedMessagesDirective2, NgIf, TemplateContextDirective, NgClass, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, AdaptiveRendererComponent2, ReactiveFormsModule, DefaultValueAccessor, NgControlStatus, FilterInputDirective, FormsModule, NgModel, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownListComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoDropDownList",
      providers: [DROPDOWNLIST_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.dropdownlist"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => DropDownListComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DropDownListComponent)
      }],
      selector: "kendo-dropdownlist",
      template: `
        <ng-container kendoDropDownListLocalizedMessages
            i18n-noDataText="kendo.dropdownlist.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-selectButtonText="kendo.dropdownlist.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-filterInputLabel="kendo.dropdownlist.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.dropdownlist.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.dropdownlist.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"

            i18n-filterPlaceholder="kendo.dropdownlist.filterPlaceholder|The text for the input's placeholder when filtering is enabled"
            filterInputPlaceholder="Filter"
        >
        </ng-container>
        <span class="k-input-inner" unselectable="on" [id]="valueLabelId" (click)="$event.preventDefault()">
            <span class="k-input-value-text">
                <ng-template *ngIf="valueTemplate"
                    [templateContext]="{
                        templateRef: valueTemplate.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!valueTemplate">{{ getText() }}</ng-template>
            </span>
        </span>
        <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
        <button
            tabindex="-1"
            unselectable="on"
            type="button"
            class="k-input-button k-button k-icon-button"
            [ngClass]="selectButtonClasses"
            [attr.aria-label]="messageFor('selectButtonText')"
            [attr.disabled]="disabled ? '' : null"
            [kendoEventsOutsideAngular]="{
                mousedown: onMouseDown
            }"
        >
            <kendo-icon-wrapper
                unselectable="on"
                [name]="icon || 'caret-alt-down'"
                innerCssClass="k-button-icon"
                [customFontClass]="customIconClass"
                [svgIcon]="svgIcon || caretAltDownSVGIcon">
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="filterable"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onFilterChange($event)"
            [filterable]="filterable">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--filterable-->
            <ng-template [ngIf]="filterable && !isActionSheetExpanded">
                <div class="k-list-filter" (click)="$event.stopImmediatePropagation()">
                    <span
                        class="k-searchbox k-input"
                        [ngClass]="filterInputClasses">
                        <kendo-icon-wrapper
                            class="k-icon"
                            innerCssClass="k-input-icon"
                            name="search"
                            [svgIcon]="searchIcon">
                        </kendo-icon-wrapper>
                        <input
                            #searchInput
                            role="searchbox"
                            aria-autocomplete="list"
                            aria-haspopup="listbox"
                            [attr.aria-controls]="listBoxId"
                            tabindex="-1"
                            [filterInput]="isFocused && !touchEnabled"
                            [attr.aria-label]="messageFor('filterInputLabel')"
                            [dir]="direction"
                            [(ngModel)]="filterText"
                            class="k-input-inner"
                            (keydown)="keydown($event, searchInput)"
                            (input)="handleFilter($event)"
                            (focus)="onFilterFocus()"
                            (blur)="blurFilterInput()"
                            (click)="handleClick()" />
                    </span>
                </div>
            </ng-template>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [id]="listBoxId"
                [size]="isAdaptive ? 'large' : size"
                [rounded]="rounded"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="itemTemplate"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [virtual]="virtual"
                [ariaLive]="ariaLive"
                [showStickyHeader]="showStickyHeader"
                (pageChange)="pageChange($event)"
                [defaultItem]="defaultItem">
            </kendo-list>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, NgIf, TemplateContextDirective, NgClass, EventsOutsideAngularDirective, IconWrapperComponent, NgTemplateOutlet, ResizeSensorComponent, AdaptiveRendererComponent2, ReactiveFormsModule, FilterInputDirective, FormsModule, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService2
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: Renderer2
    }, {
      type: ChangeDetectorRef
    }, {
      type: Injector
    }, {
      type: AdaptiveService
    }];
  }, {
    customIconClass: [{
      type: Input
    }],
    adaptiveRenderer: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    searchInput: [{
      type: ViewChild,
      args: ["searchInput"]
    }],
    showStickyHeader: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    defaultItem: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    ignoreCase: [{
      type: Input
    }],
    delay: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    leftRightArrowsNavigation: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    selectionChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    itemTemplate: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    valueTemplate: [{
      type: ContentChild,
      args: [ValueTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdownlist"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    isDisabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    focusableId: [{
      type: Input,
      args: ["id"]
    }, {
      type: HostBinding,
      args: ["attr.id"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    readonlyClass: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    readonlyAttr: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    haspopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    keydown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    keypress: [{
      type: HostListener,
      args: ["keypress", ["$event"]]
    }],
    click: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var TagTemplateDirective = class _TagTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function TagTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TagTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _TagTemplateDirective,
    selectors: [["", "kendoMultiSelectTagTemplate", ""], ["", "kendoMultiSelectTreeTagTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTagTemplate],[kendoMultiSelectTreeTagTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var GroupTagTemplateDirective = class _GroupTagTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function GroupTagTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _GroupTagTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _GroupTagTemplateDirective,
    selectors: [["", "kendoMultiSelectGroupTagTemplate", ""], ["", "kendoMultiSelectTreeGroupTagTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GroupTagTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectGroupTagTemplate],[kendoMultiSelectTreeGroupTagTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var RemoveTagEvent = class extends PreventableEvent3 {
  /**
   * The data item or an array of data items that will be removed.
   */
  dataItem;
  /**
   * Constructs the event arguments for the `remove` event.
   * @param dataItem - The data item or an array of data items that will be removed.
   */
  constructor(dataItem) {
    super();
    this.dataItem = dataItem;
  }
};
var normalizeCheckboxesSettings = (settings) => {
  if (isObject(settings)) {
    const defaultSettings = {
      enabled: true,
      checkOnClick: true
    };
    return Object.assign({}, defaultSettings, settings);
  }
  return {
    enabled: Boolean(settings),
    checkOnClick: true
  };
};
var TagListComponent = class _TagListComponent {
  renderer;
  hostElement;
  /**
   * @hidden
   */
  xCircleIcon = xCircleIcon;
  tags;
  textField;
  valueField;
  valueDepth;
  focused;
  template;
  groupTemplate;
  disabled;
  tagPrefix;
  id;
  set size(size) {
    this.renderer.removeClass(this.hostElement.nativeElement, getSizeClass2("chip-list", this.size));
    if (size) {
      this.renderer.addClass(this.hostElement.nativeElement, getSizeClass2("chip-list", size));
    }
    this._size = size;
  }
  get size() {
    return this._size;
  }
  rounded = "medium";
  fillMode = "solid";
  /**
   * A collection with the disabled tags' indices.
   */
  disabledIndices = /* @__PURE__ */ new Set();
  removeTag = new EventEmitter();
  hostClass = true;
  get hostId() {
    return this.id;
  }
  taglistRole = "listbox";
  multiselectable = true;
  _size = "medium";
  constructor(renderer, hostElement) {
    this.renderer = renderer;
    this.hostElement = hostElement;
  }
  tagProp(tag, prop, index) {
    const propField = prop && this.getPropField(tag, prop, index);
    return getter2(tag, propField);
  }
  isTagDisabled(tag, positionIndex) {
    if (this.isGroupTag(tag)) {
      return tag.every((_tag, index) => this.disabledIndices.has(index + positionIndex));
    }
    return this.disabledIndices.has(positionIndex);
  }
  deleteTag(event, tag, index) {
    event.preventDefault();
    event.stopImmediatePropagation();
    if (!this.disabled && event.which === 1) {
      this.removeTag.emit({
        tag,
        index
      });
    }
  }
  itemId(tag, index) {
    if (tag) {
      return this.tagPrefix + "-" + index;
    }
  }
  isGroupTag(tag) {
    return tag instanceof Array;
  }
  tagAriaHidden(index) {
    return isPresent5(this.focused) && this.focused !== index;
  }
  getPropField(tag, prop, index) {
    const fieldsCount = prop.length - 1;
    if (typeof prop === "string") {
      return prop;
    } else if (this.valueDepth) {
      const depth = this.valueDepth[index];
      return fieldsCount < depth ? prop[fieldsCount] : prop[depth];
    } else {
      return prop.find((item) => item in tag);
    }
  }
  static ɵfac = function TagListComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TagListComponent)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _TagListComponent,
    selectors: [["kendo-taglist"]],
    hostVars: 5,
    hostBindings: function TagListComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("id", ctx.hostId)("role", ctx.taglistRole)("aria-multiselectable", ctx.multiselectable);
        ɵɵclassProp("k-chip-list", ctx.hostClass);
      }
    },
    inputs: {
      tags: "tags",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      focused: "focused",
      template: "template",
      groupTemplate: "groupTemplate",
      disabled: "disabled",
      tagPrefix: "tagPrefix",
      id: "id",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      disabledIndices: "disabledIndices"
    },
    outputs: {
      removeTag: "removeTag"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    ngContentSelectors: _c192,
    decls: 2,
    vars: 1,
    consts: [["groupTag", ""], ["singleTag", ""], ["class", "k-chip", 3, "ngClass", 4, "ngFor", "ngForOf"], [1, "k-chip", 3, "ngClass"], [1, "k-chip-content"], [4, "ngIf", "ngIfThen", "ngIfElse"], [1, "k-chip-actions"], ["aria-label", "delete", 1, "k-chip-action", "k-chip-remove-action"], ["name", "x-circle", 3, "mousedown", "svgIcon"], [1, "k-chip-label", "k-text-ellipsis"], [4, "ngIf"], [3, "ngIf"], [3, "templateContext"]],
    template: function TagListComponent_Template(rf, ctx) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, TagListComponent_div_0_Template, 10, 22, "div", 2);
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx.tags);
      }
    },
    dependencies: [NgForOf, NgClass, NgIf, TemplateContextDirective, IconWrapperComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TagListComponent, [{
    type: Component,
    args: [{
      selector: "kendo-taglist",
      template: `
        <div
            *ngFor="let tag of tags; let index = index;"
            [attr.id]="itemId(tag, index)"
            [attr.aria-selected]="true"
            [attr.role]="'option'"
            class="k-chip"
            [ngClass]="{
                'k-focus': index === focused,
                'k-disabled': isTagDisabled(tag, index),
                'k-chip-sm': size === 'small',
                'k-chip-md': size === 'medium',
                'k-chip-lg': size === 'large',
                'k-rounded-sm': rounded === 'small',
                'k-rounded-md': rounded === 'medium',
                'k-rounded-lg': rounded === 'large',
                'k-rounded-full': rounded === 'full',
                'k-chip-solid k-chip-solid-base': fillMode === 'solid',
                'k-chip-flat k-chip-flat-base': fillMode === 'flat',
                'k-chip-outline k-chip-outline-base': fillMode === 'outline'
            }"
        >
            <span class="k-chip-content">
                <ng-template *ngIf="isGroupTag(tag); then groupTag else singleTag"></ng-template>
                <ng-template #groupTag>
                    <span class="k-chip-label k-text-ellipsis">
                        <ng-template *ngIf="groupTemplate"
                            [templateContext]="{
                            templateRef: groupTemplate.templateRef,
                            $implicit: tag
                        }">
                        </ng-template>
                        <ng-template [ngIf]="!groupTemplate">{{ tag.length }} {{ tag.length === 1 ? 'item' : 'items' }} selected</ng-template>
                    </span>
                </ng-template>
                <ng-template #singleTag>
                    <span class="k-chip-label k-text-ellipsis">
                        <ng-template *ngIf="template"
                            [templateContext]="{
                            templateRef: template.templateRef,
                            $implicit: tag
                        }">
                        </ng-template>
                        <ng-template [ngIf]="!template">{{ tagProp(tag, textField, index) }}</ng-template>
                    </span>
                </ng-template>
            </span>
            <span class="k-chip-actions">
                <span aria-label="delete" [attr.aria-hidden]="index !== focused" class="k-chip-action k-chip-remove-action">
                    <kendo-icon-wrapper
                        (mousedown)="deleteTag($event, tag, index)"
                        name="x-circle"
                        [svgIcon]="xCircleIcon"
                    >
                    </kendo-icon-wrapper>
                </span>
            </span>
        </div>
        <ng-content></ng-content>
  `,
      standalone: true,
      imports: [NgForOf, NgClass, NgIf, TemplateContextDirective, IconWrapperComponent]
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    tags: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    focused: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    groupTemplate: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    tagPrefix: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    disabledIndices: [{
      type: Input
    }],
    removeTag: [{
      type: Output
    }],
    hostClass: [{
      type: HostBinding,
      args: ["class.k-chip-list"]
    }],
    hostId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    taglistRole: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    multiselectable: [{
      type: HostBinding,
      args: ["attr.aria-multiselectable"]
    }]
  });
})();
var MULTISELECT_VALUE_ACCESSOR = {
  multi: true,
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MultiSelectComponent)
};
var DEFAULT_SIZE$22 = "medium";
var DEFAULT_ROUNDED$22 = "medium";
var DEFAULT_FILL_MODE$22 = "solid";
var MultiSelectComponent = class _MultiSelectComponent {
  wrapper;
  localization;
  popupService;
  dataService;
  selectionService;
  navigationService;
  disabledItemsService;
  cdr;
  differs;
  renderer;
  _zone;
  injector;
  hostElement;
  adaptiveService;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  xIcon = xIcon;
  listBoxId = `k-${guid()}`;
  tagListId = `k-${guid()}`;
  tagPrefix = "tag-" + guid();
  optionPrefix = "option-" + guid();
  popupRef;
  text;
  tags;
  focusedTagIndex = void 0;
  /**
   * @hidden
   */
  adaptiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  get ariaControls() {
    return this.isOpen ? this.listBoxId : void 0;
  }
  /**
   * @hidden
   */
  get isControlRequired() {
    return isControlRequired(this.formControl);
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * Focuses a specific item in the MultiSelect based on the provided index.
   * Sets the index to `-1` to focus the custom item if available.
   * Pass `null` or an invalid index to remove focus.
   */
  focusItemAt(index) {
    const minIndex = this.allowCustom ? -1 : 0;
    const isInRange = minIndex <= 0 && index < this.data.length;
    if (isPresent5(index) && isInRange && !this.disabledItemsService.isIndexDisabled(index)) {
      this.selectionService.focus(index);
    } else {
      this.selectionService.focus(null);
    }
  }
  /**
   * Focuses the MultiSelect input element.
   */
  focus() {
    if (!this.disabled) {
      this.searchbar.focus();
    }
  }
  /**
   * @hidden
   */
  handleInputFocus() {
    this.handleFocus();
    if (hasObservers(this.inputFocus)) {
      this._zone.run(() => {
        this.inputFocus.emit();
      });
    }
  }
  /**
   * Removes focus from the MultiSelect input element.
   */
  blur() {
    if (!this.disabled) {
      this.searchbar.blur();
    }
  }
  /**
   * @hidden
   */
  handleFocus() {
    this._zone.run(() => {
      if (!this.isFocused && hasObservers(this.onFocus)) {
        this.onFocus.emit();
      }
      this.isFocused = true;
    });
  }
  /**
   * @hidden
   */
  handleBlur() {
    if (!this.isActionSheetExpanded) {
      this.blurComponent();
    }
  }
  /**
   * @hidden
   */
  handleInputBlur() {
    if (!this.isActionSheetExpanded) {
      if (!this.isFocused) {
        return;
      }
      if (hasObservers(this.inputBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.closePopup();
          if (!(this.isOpen && this.allowCustom)) {
            this.clearFilter();
          }
          this.inputBlur.emit();
          this.onTouchedCallback();
        });
      } else {
        if (!this.allowCustom) {
          this.clearFilter();
        }
        this.closePopup();
      }
    }
  }
  /**
   * @hidden
   */
  onPointerDown(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
      this.cdr.detectChanges();
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * Shows or hides the current group sticky header when using grouped data.
   * By default the sticky header is displayed ([see example]({% slug grouping_autocomplete %}#toc-sticky-header)).
   */
  showStickyHeader = true;
  /**
   * @hidden
   */
  focusableId = `k-${guid()}`;
  /**
   * Controls whether the options list closes after item selection finishes ([see example]({% slug openstate_multiselect %}#toc-keeping-the-options-list-open-while-on-focus)).
   * Set to `false` to keep the list open while the component has focus.
   *
   * @default true
   */
  autoClose = true;
  /**
   * Controls the loading state of the MultiSelect.
   * Set to `true` to display the loading indicator.
   */
  loading;
  /**
   * Sets the data source for the MultiSelect.
   * Provide the data as an array of items.
   */
  set data(data) {
    this.dataService.data = data || [];
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    if (this.initialized) {
      this.setState(this.value);
    }
  }
  get data() {
    const virtual = this.virtual;
    if (virtual) {
      const start = virtual.skip || 0;
      const end = start + virtual.pageSize;
      virtual.total = this.dataService.data.length;
      return this.dataService.data.slice(start, end);
    }
    return this.dataService.data;
  }
  /**
   * Sets the selected values of the MultiSelect.
   * Accepts primitive values (strings, numbers) or complex objects.
   * Use the `valuePrimitive` property to define the value type.
   * > The component ignores selected values that don't exist in the data source.
   */
  set value(values) {
    this._value = values ? values : [];
    if (!this.differ && this.value) {
      this.differ = this.differs.find(this.value).create();
    }
    this.valueChangeDetected = true;
    if (this.initialized) {
      this.setState(this.value);
    }
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the field name that contains the item value in the data objects.
   * Skip this property when your data contains only primitive values.
   * Supports nested property paths like `category.id`.
   */
  valueField;
  /**
   * Sets the field name that contains the item text in the data objects.
   * Skip this property when your data contains only primitive values.
   * Supports nested property paths like `category.name`.
   */
  textField;
  /**
   * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) attribute of the component.
   *
   * @default 0
   */
  tabindex = 0;
  /**
   * @hidden
   */
  set tabIndex(tabIndex) {
    this.tabindex = tabIndex;
  }
  get tabIndex() {
    return this.tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * @default "medium"
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * @default "medium"
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fill mode of the component.
   *
   * @default "solid"
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$22;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Sets the placeholder text for the MultiSelect input.
   * When the values are selected, it disappears.
   */
  set placeholder(text) {
    this._placeholder = text || "";
  }
  get placeholder() {
    return this.selectedDataItems.length ? "" : this._placeholder;
  }
  /**
   * Controls the adaptive mode behavior of the component.
   * Set to `auto` to enable adaptive rendering on small screens.
   *
   * @default "none"
   */
  adaptiveMode = "none";
  /**
   * Sets the title text for the ActionSheet in adaptive mode.
   * Uses the component's label text by default.
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text for the ActionSheet in adaptive mode.
   * No subtitle appears by default.
   */
  adaptiveSubtitle;
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
   * Controls the disabled state of the component.
   * When true, sets the component to disabled.
   * To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_multiselect#toc-managing-the-multiselect-disabled-state-in-reactive-forms).
   *
   * @default false
   */
  disabled = false;
  /**
   * Determines wether the item will be disabled. The function is executed for each data item.
   * The function receives the item as an argument and should return `true` if the item is disabled.
   */
  set itemDisabled(fn) {
    if (typeof fn !== "function") {
      throw new Error(`itemDisabled must be a function, but received ${JSON.stringify(fn)}.`);
    }
    this.disabledItemsService.itemDisabled = fn;
  }
  /**
   * Controls whether checkboxes appear before each item in the popup list.
   * Pass `true` to enable checkboxes or an object to configure checkbox settings.
   *
   * @default false
   */
  set checkboxes(settings) {
    this._checkboxes = normalizeCheckboxesSettings(settings);
  }
  get checkboxes() {
    return this._checkboxes;
  }
  /**
   * Controls the read-only state of the component.
   * When true, the component does not allow user input or selection changes.
   *
   * @default false
   */
  readonly = false;
  /**
   * Enables the filtering functionality of the MultiSelect.
   * Set to `true` to allow users to filter the data by typing.
   *
   * @default false
   */
  filterable = false;
  /**
   * Enables virtualization to improve performance with large datasets.
   * Pass `true` for default settings or an object to configure virtualization.
   */
  set virtual(settings) {
    this._virtualSettings = normalizeVirtualizationSettings(settings);
  }
  get virtual() {
    return this._virtualSettings;
  }
  /**
   * Configures the popup appearance and behavior.
   * Set properties like `animate`, `width`, `height`, `popupClass`, and `appendTo`.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({
      animate: true
    }, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Sets the height of the options list in the popup.
   * This affects only the list height, not the entire popup container.
   *
   * @default 200
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Controls the type of selected values.
   * Set to `true` for primitive values or `false` for object references.
   * When undefined, the component determines the type based on `valueField`.
   */
  set valuePrimitive(isPrimitive) {
    this._valuePrimitive = isPrimitive;
  }
  get valuePrimitive() {
    if (!isPresent5(this._valuePrimitive)) {
      return !isPresent5(this.valueField);
    }
    return this._valuePrimitive;
  }
  /**
   * Controls whether a clear button appears when items are selected.
   * Set to `true` to show the button that clears all selections.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Sets a function that transforms selected data items into display tags.
   * Use this to customize how selected items appear as tags.
   *
   * @default (tags) => tags || []
   */
  tagMapper = (tags) => tags || [];
  /**
   * Allows users to add custom values not present in the data source.
   * Set to `true` to enable custom value input.
   * This feature is not available in adaptive mode.
   *
   * @default false
   */
  allowCustom = false;
  /**
   * Sets a function that normalizes custom user input into data items.
   * Use this when your data items differ from simple strings.
   */
  valueNormalizer = (text) => text.pipe(map((userInput) => {
    const comparer = (item) => typeof item === "string" && userInput.toLowerCase() === item.toLowerCase();
    const matchingValue = this.value.find(comparer);
    if (matchingValue) {
      return matchingValue;
    }
    const matchingItem = this.dataService.find(comparer);
    return matchingItem ? matchingItem : userInput;
  }));
  /**
   * Sets HTML attributes for the inner input element.
   * You cannot change attributes essential for component functionality.
   */
  inputAttributes;
  /**
   * Fires when the user types in the input field.
   * Use this event to filter the data source based on user input.
   */
  filterChange = new EventEmitter();
  /**
   * Fires when the value changes through user interaction or the Clear button.
   * This event does not fire when you change the value programmatically.
   */
  valueChange = new EventEmitter();
  /**
   * Fires before the popup opens.
   * You can prevent the popup from opening by calling `preventDefault()` on the event.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup opens completely.
   */
  opened = new EventEmitter();
  /**
   * Fires before the popup closes.
   * You can prevent the popup from closing by calling `preventDefault()` on the event.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup closes completely.
   */
  closed = new EventEmitter();
  /**
   * Fires when the user focuses the MultiSelect component.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the MultiSelect component loses focus.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the user focuses the input element inside the MultiSelect.
   */
  inputFocus = new EventEmitter();
  /**
   * Fires when the input element inside the MultiSelect loses focus.
   */
  inputBlur = new EventEmitter();
  /**
   * Fires before a tag gets removed from the selection.
   * You can prevent tag removal by calling `preventDefault()` on the event.
   */
  removeTag = new EventEmitter();
  container;
  searchbar;
  tagList;
  popupTemplate;
  optionsList;
  template;
  customItemTemplate;
  groupTemplate;
  fixedGroupTemplate;
  headerTemplate;
  footerTemplate;
  tagTemplate;
  groupTagTemplate;
  noDataTemplate;
  /**
   * @hidden
   */
  suffixTemplate;
  /**
   * @hidden
   */
  prefixTemplate;
  hostClasses = true;
  get dir() {
    return this.direction;
  }
  get disabledClass() {
    return this.disabled;
  }
  get isLoading() {
    return this.loading;
  }
  /**
   * @hidden
   */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   */
  applyValue() {
    if (!this.isActionSheetExpanded) {
      return;
    }
    const isValueChanged = !(this.value.every((i) => this._valueHolder.find((item) => i === item)) && this._valueHolder.length === this.value.length);
    if (isValueChanged) {
      this.value = this._valueHolder;
      this._valueHolder = [];
      this.emitValueChange();
    }
    this.clearFilter();
    this.togglePopup(false);
    if (this.allowCustom && this.isCustomValueSelected) {
      this.isCustomValueSelected = false;
    }
  }
  disabledIndices;
  initialized = false;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _valueHolder = [];
  isCustomValueSelected = false;
  constructor(wrapper, localization, popupService, dataService, selectionService, navigationService, disabledItemsService, cdr, differs, renderer, _zone, injector, hostElement, adaptiveService) {
    this.wrapper = wrapper;
    this.localization = localization;
    this.popupService = popupService;
    this.dataService = dataService;
    this.selectionService = selectionService;
    this.navigationService = navigationService;
    this.disabledItemsService = disabledItemsService;
    this.cdr = cdr;
    this.differs = differs;
    this.renderer = renderer;
    this._zone = _zone;
    this.injector = injector;
    this.hostElement = hostElement;
    this.adaptiveService = adaptiveService;
    validatePackage(packageMetadata4);
    this.popupPointerDownHandler = this.onPointerDown.bind(this);
    this.data = [];
    this.direction = this.localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeTouchEvents();
  }
  get listContainerClasses() {
    const containerClasses = ["k-list-container", "k-multiselect-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  get customItemSizeClass() {
    const currentSize = this.isAdaptive ? "large" : this.size;
    return `${currentSize ? getSizeClass2("list", currentSize) : ""}`;
  }
  get width() {
    let wrapperOffsetWidth = 0;
    if (isDocumentAvailable()) {
      wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    }
    const width = this.popupSettings.width || wrapperOffsetWidth;
    const minWidth = isNaN(wrapperOffsetWidth) ? wrapperOffsetWidth : `${wrapperOffsetWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get activeDescendant() {
    const focusedTagIndex = this.focusedTagIndex;
    const focusedListIndex = this.selectionService.focused;
    let prefix;
    let focusedIndex;
    if (isPresent5(focusedTagIndex) && !this.isOpen) {
      focusedIndex = focusedTagIndex;
      prefix = this.tagPrefix;
    } else if (isPresent5(focusedListIndex) && focusedListIndex !== -1 && this.isOpen) {
      focusedIndex = focusedListIndex;
      prefix = this.optionPrefix;
    } else {
      return null;
    }
    return prefix + "-" + focusedIndex;
  }
  get clearButtonVisiblity() {
    if (touchEnabled) {
      return "visible";
    }
  }
  /**
   * @hidden
   */
  verifySettings() {
    if (!isDevMode() || this.value.length === 0) {
      return;
    }
    if (!isArray2(this.value)) {
      throw new Error(MultiselectMessages.array);
    }
    if (this.valuePrimitive === true && isObjectArray(this.value)) {
      throw new Error(MultiselectMessages.primitive);
    }
    if (this.valuePrimitive === false && !isObjectArray(this.value)) {
      throw new Error(MultiselectMessages.object);
    }
    const valueOrText = !isPresent5(this.valueField) !== !isPresent5(this.textField);
    if (valueOrText) {
      throw new Error(MultiselectMessages.textAndValue);
    }
  }
  /**
   * @hidden
   */
  change(event) {
    if (event.isMultipleSelection) {
      if (isPresent5(event.added) && event.added.length > 0) {
        event.added.forEach((itemIndex) => {
          const dataItem = this.dataService.itemAt(itemIndex);
          const newItem = this.valuePrimitive && isPresent5(dataItem) && isPresent5(getter2(dataItem, this.valueField)) ? getter2(dataItem, this.valueField) : dataItem;
          if (newItem) {
            if (!this.isAdaptive || !this.isActionSheetExpanded) {
              this.value = [...this.value, newItem];
            } else {
              this._valueHolder = [...this._valueHolder, newItem];
            }
          }
        });
      }
      if (isPresent5(event.removed) && event.removed.length > 0) {
        event.removed.forEach((itemIndex) => {
          const dataItem = this.dataService.itemAt(itemIndex);
          const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
          if (!this.isAdaptive || !this.isActionSheetExpanded) {
            this.value = this.value.filter(filter2);
          } else {
            this._valueHolder = this._valueHolder.filter(filter2);
          }
        });
        this.cdr.detectChanges();
      }
    } else {
      const isCustomItem = (isPresent5(event.added) || isPresent5(event.removed)) && (event.added === -1 || event.removed === -1);
      if (isCustomItem) {
        this.addCustomValue(this.text);
        return;
      }
      if (isPresent5(event.added)) {
        const dataItem = this.dataService.itemAt(event.added);
        const newItem = this.valuePrimitive && isPresent5(dataItem) && isPresent5(getter2(dataItem, this.valueField)) ? getter2(dataItem, this.valueField) : dataItem;
        if (!this.isAdaptive || !this.isActionSheetExpanded) {
          this.value = [...this.value, newItem];
        } else {
          this._valueHolder = [...this._valueHolder, newItem];
        }
      }
      if (isPresent5(event.removed)) {
        const dataItem = this.dataService.itemAt(event.removed);
        const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
        if (!this.isAdaptive || !this.isActionSheetExpanded) {
          this.value = this.value.filter(filter2);
        } else {
          this._valueHolder = this._valueHolder.filter(filter2);
        }
        this.selectionService.focused = event.removed;
        this.cdr.detectChanges();
      }
    }
    if (!this.isAdaptive || !this.isActionSheetExpanded) {
      this.emitValueChange();
    }
  }
  /**
   * @hidden
   */
  setState(value) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const selection = selectedIndices(this.value, data, this.valueField);
    this.selectionService.resetSelection(selection);
    if (this.disabledItemsService.isIndexDisabled(this.selectionService.focused)) {
      this.selectionService.focused = this.firstFocusableIndex(0);
    }
    if (this.isOpen && this.selectionService.focused === void 0) {
      if (this.dataService.itemsCount > 0) {
        this.selectionService.focused = this.firstFocusableIndex(0);
        if (this.allowCustom) {
          this.selectionService.focused = 0;
        }
      } else if (this.allowCustom) {
        this.selectionService.focused = -1;
      }
    }
    if (this.valuePrimitive && !this.valueField) {
      this.selectedDataItems = value.slice();
    }
    if (isObjectArray(value) || this.valuePrimitive && this.valueField) {
      this.selectedDataItems = resolveAllValues(value, data, this.valueField);
    }
    if (this.selectedDataItems.length < value.length) {
      this.selectedDataItems = value.map((current) => {
        const dataItem = this.selectedDataItems.find((item) => getter2(item, this.valueField) === getter2(current, this.valueField));
        return isPresent5(dataItem) ? dataItem : this.resolveDataItemFromTags(current);
      }).filter((dataItem) => isPresent5(dataItem));
    }
    this.tags = this.tagMapper(this.selectedDataItems.slice(0));
    this.disabledIndices = this.disabledItemsMapper();
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilter(text) {
    if (this.isActionSheetExpanded && this.allowCustom && this.isCustomValueSelected) {
      this.addCustomValue(this.text);
      this.addCustomValue(text);
    }
    this.text = text;
    if (text && !this.isOpen) {
      this.openPopup();
    }
    if (this.filterable) {
      this.filterChange.emit(text);
    } else {
      this.searchTextAndFocus(text);
    }
    this.searchbar.setInputSize();
  }
  /**
   * @hidden
   */
  pageChange(event) {
    const virtual = this.virtual;
    virtual.skip = event.skip;
  }
  /**
   * @hidden
   */
  clearFilter() {
    if (this.filterable && this.text) {
      this.filterChange.emit("");
    }
    this.text = "";
    this.searchbar.input.nativeElement.value = "";
    this.searchbar.setInputSize();
  }
  /**
   * @hidden
   */
  handleNavigate(event) {
    const navigateInput = this.text && event.keyCode !== Keys.ArrowDown && event.keyCode !== Keys.ArrowUp;
    const selectValue = this.text && event.keyCode === Keys.Enter || event.keyCode === Keys.Escape;
    const deleteTag = !this.text && event.keyCode === Keys.Backspace && this.tags.length > 0;
    if (event.keyCode === Keys.Backspace && this.isActionSheetExpanded) {
      return;
    }
    if (deleteTag) {
      this.handleBackspace();
      return;
    }
    if (this.disabled || navigateInput && !selectValue) {
      return;
    }
    const eventData = event;
    const focused = isNaN(this.selectionService.focused) ? -1 : this.selectionService.focused;
    const action = this.navigationService.process({
      current: focused,
      max: this.dataService.itemsCount - 1,
      min: this.allowCustom && this.text ? -1 : 0,
      open: this.isOpen,
      originalEvent: eventData
    });
    if (action !== NavigationAction.Undefined && (action === NavigationAction.Enter && this.isOpen || action !== NavigationAction.Enter) && !this.isActionSheetExpanded && action === NavigationAction.Tab) {
      event.preventDefault();
    }
  }
  /**
   * @hidden
   */
  handleRemoveTag({
    tag
  }) {
    const eventArgs = new RemoveTagEvent(tag);
    if (this.disabled || this.readonly) {
      return;
    }
    this.focus();
    this.removeTag.emit(eventArgs);
    if (eventArgs.isDefaultPrevented()) {
      return;
    }
    if (tag instanceof Array) {
      this.removeGroupTag(tag);
    } else {
      this.removeSingleTag(tag);
    }
    this.cdr.detectChanges();
  }
  /**
   * @hidden
   */
  clearAll(event) {
    event?.stopImmediatePropagation();
    event?.preventDefault();
    this.focus();
    this.clearFilter();
    this.selectionService.lastClickedIndex = null;
    const selected = this.selectionService.selected;
    this.value = this.value.filter((_item, index) => this.disabledItemsService.isIndexDisabled(selected[index]));
    this.emitValueChange();
  }
  /**
   * @hidden
   */
  addCustomValue(text) {
    this.customValueSubject.next(text);
  }
  ngAfterContentChecked() {
    this.verifySettings();
  }
  ngDoCheck() {
    const valueChanges = this.differ && this.differ.diff(this.value);
    if (valueChanges && !this.valueChangeDetected) {
      this.setState(this.value);
    }
    this.valueChangeDetected = false;
  }
  ngOnInit() {
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.createCustomValueStream();
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setState(this.value);
    this.setComponentClasses();
    this.initialized = true;
  }
  ngOnChanges(changes) {
    const virtual = this.virtual;
    const requestInitialData = virtual && changes.data && changes.data.isFirstChange();
    if (requestInitialData) {
      this.pageChange({
        skip: 0,
        take: virtual.pageSize
      });
    }
    if (isChanged("valueNormalizer", changes)) {
      this.createCustomValueStream();
    }
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes)) {
      this.setState(this.value);
    }
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.cdr.detectChanges();
    this.searchbar.setInputSize();
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "mousedown", this.handleMousedown.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
    this._zone.onStable.pipe(take(1)).subscribe(() => {
      const ariaLabel = this.searchbar.input.nativeElement.getAttribute("aria-labelledby") || this.searchbar.input.nativeElement.getAttribute("data-kendo-label-id");
      if (ariaLabel) {
        this.renderer.setAttribute(this.tagList.hostElement.nativeElement, "aria-labelledby", ariaLabel);
      }
    });
  }
  ngOnDestroy() {
    this._toggle(false);
    this.unsubscribeEvents();
  }
  /**
   * Toggles the visibility of the popup or actionSheet
   * ([see example]({% slug openstate_multiselect %}#toc-setting-the-initially-opened-component)).
   * If you use the `toggle` method to open or close the popup or actionSheet, the respective `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !this._open;
      this._toggle(shouldOpen);
      this.cdr.markForCheck();
    });
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(this._open || this.isActionSheetExpanded);
  }
  /**
   * Resets the MultiSelect by clearing the text and value.
   * This method does not trigger the `selectionChange` and `valueChange` events.
   */
  reset() {
    this.text = "";
    this.value = [];
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  // NG MODEL BINDINGS
  /**
   * @hidden
   */
  writeValue(value) {
    this.value = value || [];
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.cdr.markForCheck();
    this.disabled = isDisabled2;
  }
  /**
   * @hidden
   */
  onTagMapperChange() {
    this.tags = this.tagMapper(this.selectedDataItems.slice(0));
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleClick() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.togglePopup(true);
    }
  }
  onChangeCallback = (_) => {
  };
  onTouchedCallback = (_) => {
  };
  _placeholder = "";
  _open = false;
  _value = [];
  _popupSettings = {
    animate: true
  };
  _virtualSettings;
  _valuePrimitive;
  _checkboxes = {
    enabled: false
  };
  _isFocused = false;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  selectedDataItems = [];
  popupPointerDownHandler;
  isOpenPrevented = false;
  customValueSubject = new Subject();
  customValueSubscription;
  subs = new Subscription();
  touchstartDisposeHandler;
  direction;
  differ;
  valueChangeDetected;
  subscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    const isOpen = () => this.isOpen;
    const isClosed = () => !this.isOpen;
    const isTagFocused = () => !this.isOpen && this.focusedTagIndex !== void 0;
    [this.selectionService.onChange.subscribe(this.handleItemChange.bind(this)), this.navigationService.esc.subscribe(this.closePopup.bind(this)), this.navigationService.enter.pipe(filter(isOpen)).subscribe(this.handleEnter.bind(this)), this.navigationService.open.subscribe(this.openPopup.bind(this)), this.navigationService.close.subscribe(this.handleClose.bind(this)), this.navigationService.up.pipe(filter(isOpen)).subscribe((event) => this.handleUp(event.index)), this.navigationService.home.pipe(filter(() => isClosed)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => isClosed)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(isTagFocused)).subscribe(this.handleDelete.bind(this)), this.navigationService.left.subscribe(this.direction === "rtl" ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.subscribe(this.direction === "rtl" ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.down.subscribe((event) => this.handleDownKey(event.index)), this.navigationService.selectprevious.pipe(filter(isOpen)).subscribe((event) => this.handleSelectUpDown(event)), this.navigationService.selectnext.pipe(filter(isOpen)).subscribe((event) => this.handleSelectUpDown(event)), this.navigationService.selectalltobeginning.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToBeginning()), this.navigationService.selectalltoend.pipe(filter(isOpen)).subscribe(() => this.handleSelectAllToEnd()), merge(this.navigationService.pagedown, this.navigationService.pageup).subscribe((event) => {
      if (this.isOpen) {
        event.originalEvent.preventDefault();
        this.optionsList.scrollWithOnePage(NavigationAction[event.originalEvent.code]);
      }
    })].forEach((s) => this.subs.add(s));
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up MultiSelect on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if ((this.isFocused || this.isOpen) && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            this.blur();
            if (this.isOpen) {
              this.togglePopup(false);
            }
          });
        }
      })
    ));
  }
  unsubscribeEvents() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.subs.unsubscribe();
    if (this.customValueSubscription) {
      this.customValueSubscription.unsubscribe();
    }
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  removeGroupTag(dataItems) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const dataItemValues = new Set(dataItems.map((item) => getter2(item, this.valueField)));
    this.value = this.value.filter((value) => {
      const index = selectedIndices([value], data, this.valueField)[0];
      const isDataItemDisabled = this.disabledItemsService.isIndexDisabled(index);
      return !dataItemValues.has(getter2(value, this.valueField)) || isDataItemDisabled;
    });
    this.emitValueChange();
  }
  removeSingleTag(dataItem) {
    let data = this.dataService.data;
    if (this.dataService.grouped) {
      data = data.filter((item) => !item.header).map((item) => item.value);
    }
    const index = selectedIndices([dataItem], data, this.valueField)[0];
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return;
    }
    if (isNumber2(index)) {
      this.selectionService.deselect(index);
      this.selectionService.focused = index;
      this.togglePopup(false);
    } else {
      const filter2 = (item) => getter2(item, this.valueField) !== getter2(dataItem, this.valueField);
      this.value = this.value.filter(filter2);
      this.emitValueChange();
    }
  }
  /**
   * @hidden
   *
   * Determines which of the provided tags should be disabled and stores their position indices
   */
  disabledItemsMapper() {
    const {
      selected
    } = this.selectionService;
    return new Set(this.selectedDataItems.reduce((indices, _item, index) => {
      if (this.disabledItemsService.isIndexDisabled(selected[index])) {
        indices.push(index);
      }
      return indices;
    }, []));
  }
  createCustomValueStream() {
    if (this.customValueSubscription) {
      this.customValueSubscription.unsubscribe();
    }
    this.customValueSubscription = this.customValueSubject.pipe(tap(() => {
      this.loading = true;
      this.disabled = true;
      this.cdr.detectChanges();
    }), this.valueNormalizer, catchError(() => {
      this.loading = false;
      this.disabled = false;
      if (this.autoClose) {
        this.togglePopup(false);
      }
      if (this.autoClose || !this.filterable) {
        this.clearFilter();
      }
      this.nextTick(() => {
        this.searchbar.focus();
      });
      this.createCustomValueStream();
      return of(null);
    })).subscribe((normalizedValue) => {
      this.loading = false;
      this.disabled = false;
      if (isPresent5(normalizedValue)) {
        const newValue = this.valuePrimitive ? getter2(normalizedValue, this.valueField) : normalizedValue;
        const itemIndex = this.dataService.indexOf(newValue);
        const customItem = itemIndex === -1;
        if (this.value.indexOf(newValue) === -1) {
          !this.isActionSheetExpanded && (this.tags = this.tagMapper([...this.selectedDataItems, normalizedValue]));
          if (!customItem) {
            this.selectionService.add(itemIndex);
          } else if (this.isActionSheetExpanded) {
            const isValueInHolder = this._valueHolder.some((item) => getter2(item, this.valueField) === newValue);
            if (isValueInHolder) {
              this._valueHolder = this._valueHolder.filter((item) => getter2(item, this.valueField) !== newValue);
              this.isCustomValueSelected = false;
            } else {
              this._valueHolder = [...this._valueHolder, newValue];
              this.isCustomValueSelected = true;
            }
          } else {
            this.value = [...this.value, newValue];
          }
        } else if (!customItem && this.selectionService.isSelected(itemIndex)) {
          this.selectionService.deselect(itemIndex);
          this.selectionService.focused = itemIndex;
        } else if (this.isActionSheetExpanded) {
          this._valueHolder = this._valueHolder.filter((item) => getter2(item, this.valueField) !== newValue);
          this.isCustomValueSelected = false;
        } else {
          this.value = this.value.filter((item) => getter2(item, this.valueField) !== newValue);
        }
        !this.isActionSheetExpanded && this.emitValueChange();
      }
      if (this.autoClose) {
        this.togglePopup(false);
      }
      if ((this.autoClose || !this.filterable) && !this.isActionSheetExpanded) {
        this.clearFilter();
      }
      if (!this.isActionSheetExpanded) {
        this.nextTick(() => {
          this.searchbar.focus();
        });
      }
    });
  }
  handleItemChange(event) {
    this.change(event);
    if (this.autoClose && !event.preventClosingPopup && !this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
    if ((this.autoClose || !this.filterable) && !this.isActionSheetExpanded) {
      this.clearFilter();
    }
  }
  handleMousedown(event) {
    if (event.target.closest(".k-input-prefix") || event.target.closest(".k-input-suffix")) {
      return;
    }
    if (!this.isActionSheetExpanded) {
      const inputElement = this.searchbar.input.nativeElement;
      if (event.button === 0) {
        if (this.isFocused && (this.isOpen || this.isOpenPrevented) && event.target === inputElement) {
          return;
        }
        if (!touchEnabled || touchEnabled && event.target.tagName !== "SPAN") {
          this.searchbar.focus();
        }
        if (this.popupRef && this.popupRef.popupElement.contains(event.target)) {
          return;
        }
        event.preventDefault();
        this.togglePopup(!this.isOpen);
      }
    }
  }
  handleKeydown(event) {
    if (this.isFocused && this.isOpen && (event.ctrlKey || event.metaKey) && event.keyCode === Keys.KeyA) {
      event.preventDefault();
      this.handleSelectAll();
    }
  }
  handleEnter(event) {
    const service = this.selectionService;
    const focusedIndex = this.selectionService.focused;
    this.selectionService.lastClickedIndex = focusedIndex;
    if (this.isOpen) {
      event.originalEvent.preventDefault();
    }
    if (focusedIndex === -1) {
      if (this.allowCustom && this.text) {
        this.addCustomValue(this.text);
      }
      return;
    }
    if (service.isSelected(focusedIndex)) {
      service.deselect(focusedIndex);
      service.focused = focusedIndex;
    } else {
      service.add(focusedIndex);
    }
    if (this.autoClose && !this.isActionSheetExpanded) {
      this.togglePopup(false);
    }
    if (this.autoClose || !this.filterable) {
      this.clearFilter();
    }
  }
  handleClose() {
    this.closePopup();
    this.searchbar.focus();
  }
  handleEnd() {
    this.focusedTagIndex = this.tags.length - 1;
  }
  handleHome() {
    this.focusedTagIndex = 0;
  }
  sortSelectionAscending() {
    return this.selectionService.selected.sort((a, b) => a - b);
  }
  handleSelectAll() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const dataItemsWithoutHeadersCount = this.dataService.data.filter((i) => !i.header).length;
    if (!this.dataService.grouped && selectedItemsCount === dataItemsCount || this.dataService.grouped && selectedItemsCount === dataItemsWithoutHeadersCount) {
      this.clearAll();
    } else {
      this.selectionService.selectFromTo(0, dataItemsCount - 1);
      this.selectionService.emitMultipleAddedRemoved();
    }
  }
  handleSelectAllToBeginning() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const focusedItem = this.selectionService.focused;
    const largestIndex = this.sortSelectionAscending()[selectedItemsCount - 1];
    if (selectedItemsCount !== dataItemsCount) {
      this.selectionService.unselectFromTo(largestIndex, focusedItem + 1);
      this.selectionService.selectFromTo(0, focusedItem);
    }
    this.nextTick(() => this.selectionService.focus(0));
    this.selectionService.emitMultipleAddedRemoved();
  }
  handleSelectAllToEnd() {
    const selectedItemsCount = this.selectionService.selected.length;
    const dataItemsCount = this.dataService.data.length;
    const focusedItem = this.selectionService.focused;
    if (selectedItemsCount !== dataItemsCount) {
      this.selectionService.unselectFromTo(focusedItem - 1, 0);
      this.selectionService.selectFromTo(focusedItem, dataItemsCount - 1);
    }
    if (this.dataService.grouped) {
      const lastItemIndex = this.dataService.groupIndices[this.dataService.groupIndices.length - 1] - 1;
      this.nextTick(() => this.selectionService.focus(lastItemIndex));
    } else {
      this.nextTick(() => this.selectionService.focus(dataItemsCount - 1));
    }
    this.selectionService.emitMultipleAddedRemoved();
  }
  handleSelectUpDown(event) {
    const focusedIndex = this.selectionService.focused;
    if (!isPresent5(focusedIndex)) {
      return;
    }
    let indexToSelect;
    if (event.originalEvent.key === "ArrowUp") {
      indexToSelect = focusedIndex > 0 ? focusedIndex - 1 : focusedIndex;
    } else {
      indexToSelect = focusedIndex < this.dataService.data.length - 1 ? focusedIndex + 1 : focusedIndex;
    }
    if (!isPresent5(this.selectionService.lastClickedIndex)) {
      this.selectionService.lastClickedIndex = focusedIndex;
    }
    this.selectRangeFromTo(indexToSelect);
  }
  /**
   * Selects all items between the focused item and the last clicked item (index). Also removes all other selected items.
   */
  selectRangeFromTo(indexToSelect) {
    const lastClickedIndex = this.selectionService.lastClickedIndex;
    if (lastClickedIndex > indexToSelect) {
      this.selectionService.unselectNotNeededIndices(indexToSelect, lastClickedIndex, this.dataService.data.length);
      this.selectionService.selectFromTo(indexToSelect, this.selectionService.lastClickedIndex);
      this.selectionService.emitMultipleAddedRemoved();
    } else {
      this.selectionService.unselectNotNeededIndices(lastClickedIndex, indexToSelect, this.dataService.data.length);
      this.selectionService.selectFromTo(lastClickedIndex, indexToSelect);
      this.selectionService.emitMultipleAddedRemoved();
    }
    this.nextTick(() => this.selectionService.focus(indexToSelect));
  }
  handleUp(index) {
    this.selectionService.focused = index;
  }
  handleBackspace() {
    if (this.focusedTagIndex !== void 0) {
      this.handleDelete();
    } else {
      this.handleRemoveTag({
        tag: this.tags[this.tags.length - 1]
      });
      this.searchbar.focus();
    }
  }
  handleDelete() {
    this.handleRemoveTag({
      tag: this.tags[this.focusedTagIndex]
    });
    if (this.focusedTagIndex === this.tags.length) {
      this.focusedTagIndex = void 0;
    }
  }
  handleLeftKey() {
    if (this.focusedTagIndex === void 0 || this.focusedTagIndex < 0) {
      this.focusedTagIndex = this.tags.length - 1;
    } else if (this.focusedTagIndex !== 0) {
      this.focusedTagIndex--;
    }
  }
  handleDownKey(index) {
    if (this.isOpen) {
      this.selectionService.focused = index || this.firstFocusableIndex(0);
    } else {
      this.openPopup();
    }
  }
  handleRightKey() {
    const last = this.tags.length - 1;
    if (this.focusedTagIndex === last) {
      this.focusedTagIndex = void 0;
    } else if (this.focusedTagIndex < last) {
      this.focusedTagIndex++;
    }
  }
  findIndex(text, startsFrom = 0) {
    let itemText;
    text = text.toLowerCase();
    const index = this.dataService.findIndex((item) => {
      if (this.dataService.grouped) {
        itemText = getter2(item.value, this.textField);
      } else {
        itemText = getter2(item, this.textField);
      }
      itemText = !isPresent5(itemText) ? "" : itemText.toString().toLowerCase();
      return text && itemText.startsWith(text);
    }, startsFrom);
    if (this.disabledItemsService.isIndexDisabled(index)) {
      return index + 1 > this.dataService.itemsCount ? -1 : this.findIndex(text, index + 1);
    } else {
      return index;
    }
  }
  searchTextAndFocus(text) {
    const index = this.findIndex(text);
    this.selectionService.focused = index;
  }
  closePopup() {
    this.togglePopup(false);
    this.focusedTagIndex = void 0;
  }
  openPopup() {
    this.togglePopup(true);
    this.focusedTagIndex = void 0;
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const isDefaultPrevented = this.triggerPopupEvents(open);
    if (open) {
      this.isOpenPrevented = isDefaultPrevented;
    }
    if (!isDefaultPrevented) {
      this._toggle(open);
    }
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  _toggle(open) {
    this._open = open;
    this.destroyPopup();
    if (this.isActionSheetExpanded) {
      this.actionSheet.toggle(false);
      this.closed.emit();
      this.isFocused = false;
    }
    if (this._open) {
      this.createPopup();
    }
  }
  destroyPopup() {
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("pointerdown", this.popupPointerDownHandler);
      this.popupRef.close();
      this.popupRef = null;
    }
  }
  createPopup() {
    if (this.virtual) {
      this.virtual.skip = 0;
    }
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      appendTo: this.appendTo,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      popupClass: this.listContainerClasses,
      positionMode: appendToComponent ? "fixed" : "absolute"
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    popupWrapper.addEventListener("pointerdown", this.popupPointerDownHandler);
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    popupWrapper.setAttribute("dir", this.direction);
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
      this.optionsList.scrollToItem(this.selectionService.focused);
      this.selectionService.focus(this.selectionService.focused);
      this.opened.emit();
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
    this.popupRef.popupAnchorViewportLeave.subscribe(() => {
      this.togglePopup(false);
    });
  }
  emitValueChange() {
    this.onChangeCallback(this.value);
    this.valueChange.emit(this.value);
  }
  resolveDataItemFromTags(value) {
    if (!(this.tags && this.tags.length && isPresent5(value))) {
      return void 0;
    }
    const tags = this.tags.reduce((acc, tag) => {
      const items = isArray2(tag) ? tag : [tag];
      acc.push(...items);
      return acc;
    }, []);
    return tags.find((tag) => getter2(tag, this.valueField) === getter2(value, this.valueField));
  }
  firstFocusableIndex(index) {
    const maxIndex = this.dataService.itemsCount;
    if (this.disabledItemsService.isIndexDisabled(index)) {
      const nextIndex = index + 1;
      return nextIndex < maxIndex ? this.firstFocusableIndex(nextIndex) : void 0;
    } else {
      return index;
    }
  }
  nextTick(f) {
    this._zone.runOutsideAngular(() => {
      setTimeout(() => this._zone.run(f));
    });
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this._valueHolder = [...this.value];
    this.cdr.detectChanges();
    setListBoxAriaLabelledBy(this.optionsList, this.searchbar.input, this.renderer);
    this.adaptiveTitle = setActionSheetTitle(this.searchbar.input, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.opened.emit();
    this.optionsList.scrollToItem(this.selectionService.focused);
    this.selectionService.focus(this.selectionService.focused);
    this.actionSheetSearchBar.focus();
  }
  blurComponent() {
    if (!this.isFocused) {
      return;
    }
    this.isFocused = false;
    if (hasObservers(this.onBlur) || hasObservers(this.filterChange) || hasObservers(this.close) || isUntouched2(this.wrapper.nativeElement)) {
      this._zone.run(() => {
        this.closePopup();
        if (!(this.isOpen && this.allowCustom)) {
          this.clearFilter();
        }
        this.onBlur.emit();
        this.onTouchedCallback();
      });
    } else {
      if (!this.allowCustom) {
        this.clearFilter();
      }
      this.closePopup();
    }
  }
  static ɵfac = function MultiSelectComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectComponent)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(KeyValueDiffers), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiSelectComponent,
    selectors: [["kendo-multiselect"]],
    contentQueries: function MultiSelectComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, CustomItemTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FixedGroupTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, SuffixTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, PrefixTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customItemTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fixedGroupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.suffixTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.prefixTemplate = _t.first);
      }
    },
    viewQuery: function MultiSelectComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(SearchBarComponent, 7);
        ɵɵviewQuery(TagListComponent, 7);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(_c142, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.searchbar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionsList = _t.first);
      }
    },
    hostVars: 11,
    hostBindings: function MultiSelectComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("dir", ctx.dir);
        ɵɵclassProp("k-readonly", ctx.readonly)("k-multiselect", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.disabledClass)("k-loading", ctx.isLoading);
      }
    },
    inputs: {
      showStickyHeader: "showStickyHeader",
      focusableId: "focusableId",
      autoClose: "autoClose",
      loading: "loading",
      data: "data",
      value: "value",
      valueField: "valueField",
      textField: "textField",
      tabindex: "tabindex",
      tabIndex: "tabIndex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      placeholder: "placeholder",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      disabled: "disabled",
      itemDisabled: "itemDisabled",
      checkboxes: "checkboxes",
      readonly: "readonly",
      filterable: "filterable",
      virtual: "virtual",
      popupSettings: "popupSettings",
      listHeight: "listHeight",
      valuePrimitive: "valuePrimitive",
      clearButton: "clearButton",
      tagMapper: "tagMapper",
      allowCustom: "allowCustom",
      valueNormalizer: "valueNormalizer",
      inputAttributes: "inputAttributes"
    },
    outputs: {
      filterChange: "filterChange",
      valueChange: "valueChange",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      onFocus: "focus",
      onBlur: "blur",
      inputFocus: "inputFocus",
      inputBlur: "inputBlur",
      removeTag: "removeTag"
    },
    exportAs: ["kendoMultiSelect"],
    standalone: true,
    features: [ɵɵProvidersFeature([MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiselect"
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _MultiSelectComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiSelectComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 19,
    vars: 42,
    consts: () => {
      let i18n_14;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_14 = goog.getMsg("NO DATA FOUND");
        i18n_14 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_14;
      } else {
        i18n_14 = $localize`:kendo.multiselect.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_15;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15 = goog.getMsg("clear");
        i18n_15 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_15;
      } else {
        i18n_15 = $localize`:kendo.multiselect.clearTitle|The title of the clear button:clear`;
      }
      let i18n_16;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_16 = goog.getMsg("Options list");
        i18n_16 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_16;
      } else {
        i18n_16 = $localize`:kendo.multiselect.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_17;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17 = goog.getMsg("Close");
        i18n_17 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_17;
      } else {
        i18n_17 = $localize`:kendo.multiselect.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode.:Close`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["optionsList", ""], ["kendoMultiSelectLocalizedMessages", "", "noDataText", i18n_14, "clearTitle", i18n_15, "popupLabel", i18n_16, "adaptiveCloseButtonTitle", i18n_17], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], [1, "k-input-values"], [3, "removeTag", "size", "rounded", "fillMode", "id", "tags", "textField", "valueField", "focused", "disabled", "template", "groupTemplate", "tagPrefix", "disabledIndices"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaControls", "ariaExpanded", "id", "tagListId", "isLoading", "isFilterable", "activeDescendant", "userInput", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "visibility", "mousedown", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "placeholder", "searchBarValue"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "mousedown"], ["name", "x", 1, "k-icon", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [3, "pageChange", "size", "rounded", "id", "optionPrefix", "data", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "multipleSelection", "virtual", "checkboxes", "isMultiselect", "isActionSheetExpanded", "showStickyHeader", "customItemTemplate", "text", "allowCustom"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"]];
    },
    template: function MultiSelectComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 4);
        ɵɵelementContainerStart(1, 5);
        ɵɵtwoWayListener("isFocusedChange", function MultiSelectComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MultiSelectComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MultiSelectComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, MultiSelectComponent_span_2_Template, 2, 1, "span", 6)(3, MultiSelectComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 7);
        ɵɵelementStart(4, "div", 8)(5, "kendo-taglist", 9);
        ɵɵlistener("removeTag", function MultiSelectComponent_Template_kendo_taglist_removeTag_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleRemoveTag($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(6, "input", 10);
        ɵɵlistener("onNavigate", function MultiSelectComponent_Template_input_onNavigate_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function MultiSelectComponent_Template_input_valueChange_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFilter($event));
        })("onBlur", function MultiSelectComponent_Template_input_onBlur_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function MultiSelectComponent_Template_input_onFocus_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function MultiSelectComponent_Template_input_click_6_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd()();
        ɵɵtemplate(7, MultiSelectComponent_span_7_Template, 2, 4, "span", 11)(8, MultiSelectComponent_span_8_Template, 1, 0, "span", 12)(9, MultiSelectComponent_kendo_separator_9_Template, 1, 0, "kendo-separator", 7)(10, MultiSelectComponent_span_10_Template, 2, 1, "span", 13);
        ɵɵelementContainerEnd();
        ɵɵtemplate(11, MultiSelectComponent_ng_template_11_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(13, MultiSelectComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 14);
        ɵɵelementContainer(14, null, 1);
        ɵɵelementStart(16, "kendo-adaptive-renderer", 15);
        ɵɵlistener("closePopup", function MultiSelectComponent_Template_kendo_adaptive_renderer_closePopup_16_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.applyValue());
        })("textInputChange", function MultiSelectComponent_Template_kendo_adaptive_renderer_textInputChange_16_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFilter($event));
        })("navigate", function MultiSelectComponent_Template_kendo_adaptive_renderer_navigate_16_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(17, MultiSelectComponent_ng_template_17_Template, 5, 24, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(18);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance(2);
        ɵɵproperty("size", ctx.size)("rounded", ctx.rounded)("fillMode", ctx.fillMode)("id", ctx.tagListId)("tags", ctx.tags)("textField", ctx.textField)("valueField", ctx.valueField)("focused", ctx.focusedTagIndex)("disabled", ctx.disabled)("template", ctx.tagTemplate)("groupTemplate", ctx.groupTagTemplate)("tagPrefix", ctx.tagPrefix)("disabledIndices", ctx.disabledIndices);
        ɵɵadvance();
        ɵɵproperty("ariaControls", ctx.ariaControls)("ariaExpanded", ctx.isOpen)("id", ctx.focusableId)("tagListId", ctx.tagListId)("isLoading", ctx.loading)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("disabled", ctx.disabled)("readonly", ctx.readonly || ctx.isAdaptive)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && ((ctx.tags == null ? null : ctx.tags.length) || (ctx.text == null ? null : ctx.text.length)));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", true)("subtitle", ctx.adaptiveSubtitle)("placeholder", ctx.placeholder)("searchBarValue", ctx.text);
      }
    },
    dependencies: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, TagListComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMultiSelect",
      providers: [MULTISELECT_VALUE_ACCESSOR, DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiselect"
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => MultiSelectComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiSelectComponent)
      }],
      selector: "kendo-multiselect",
      template: `
        <ng-container kendoMultiSelectLocalizedMessages
            i18n-noDataText="kendo.multiselect.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.multiselect.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-popupLabel="kendo.multiselect.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.multiselect.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode."
            adaptiveCloseButtonTitle="Close"
        >
        </ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <div class="k-input-values">
                <kendo-taglist
                    [size]="size"
                    [rounded]="rounded"
                    [fillMode]="fillMode"
                    [id]="tagListId"
                    [tags]="tags"
                    [textField]="textField"
                    [valueField]="valueField"
                    [focused]="focusedTagIndex"
                    [disabled]="disabled"
                    [template]="tagTemplate"
                    [groupTemplate]="groupTagTemplate"
                    [tagPrefix]="tagPrefix"
                    [disabledIndices]="disabledIndices"
                    (removeTag)="handleRemoveTag($event)"
                >
                </kendo-taglist>
                <input
                    kendoSearchbar
                    [ariaControls]="ariaControls"
                    [ariaExpanded]="isOpen"
                    [id]="focusableId"
                    [tagListId]="tagListId"
                    [isLoading]="loading"
                    [isFilterable]="filterable"
                    [activeDescendant]="activeDescendant"
                    [userInput]="text"
                    [disabled]="disabled"
                    [readonly]="readonly || this.isAdaptive"
                    [tabIndex]="tabIndex"
                    [isRequired]="isControlRequired"
                    [placeholder]="placeholder"
                    [inputAttributes]="inputAttributes"
                    (onNavigate)="handleNavigate($event)"
                    (valueChange)="handleFilter($event)"
                    (onBlur)="handleInputBlur()"
                    (onFocus)="handleInputFocus()"
                    (click)="handleClick()"
                />
            </div>

            <span
                *ngIf="!loading && !readonly && clearButton && (tags?.length || text?.length)"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                [attr.title]="messageFor('clearTitle')"
                role="button"
                tabindex="-1"
                (mousedown)="clearAll($event)"
            >
                <kendo-icon-wrapper
                    class="k-icon"
                    name="x"
                    [svgIcon]="xIcon"
                >
                </kendo-icon-wrapper>
            </span>
            <span
                *ngIf="loading"
                class="k-icon k-i-loading k-input-loading-icon"
            >
            </span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
        </ng-container>

        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="true"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="applyValue()"
            (textInputChange)="handleFilter($event)"
            [placeholder]="placeholder"
            (navigate)="handleNavigate($event)"
            [searchBarValue]="text">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--header template-->
            <ng-template *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate.templateRef
                }">
            </ng-template>
            <!--list-->
            <kendo-list
                #optionsList
                [size]="isAdaptive ? 'large' : size"
                [rounded]="rounded"
                [id]="listBoxId"
                [optionPrefix]="optionPrefix"
                [data]="data"
                [textField]="textField"
                [valueField]="valueField"
                [template]="template"
                [groupTemplate]="groupTemplate"
                [fixedGroupTemplate]="fixedGroupTemplate"
                [height]="listHeight"
                [show]="isOpen"
                [multipleSelection]="true"
                [virtual]="virtual"
                (pageChange)="pageChange($event)"
                [checkboxes]="checkboxes"
                [isMultiselect]="true"
                [isActionSheetExpanded]="isActionSheetExpanded"
                [showStickyHeader]="showStickyHeader"
                [customItemTemplate]="customItemTemplate"
                [text]="text"
                [allowCustom]="allowCustom"
            >
            </kendo-list>
            <!--no data template-->
            <div class="k-no-data" *ngIf="data.length === 0">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate ? noDataTemplate.templateRef : undefined
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
            <!--footer template-->
            <ng-template *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate.templateRef
                }">
            </ng-template>
        </ng-template>
  `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, TagListComponent, SearchBarComponent, IconWrapperComponent, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, ListComponent]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: DataService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService2
    }, {
      type: DisabledItemsService
    }, {
      type: ChangeDetectorRef
    }, {
      type: KeyValueDiffers
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    adaptiveRendererComponent: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    showStickyHeader: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    autoClose: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    tabIndex: [{
      type: Input,
      args: ["tabIndex"]
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    checkboxes: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    filterable: [{
      type: Input
    }],
    virtual: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    valuePrimitive: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    tagMapper: [{
      type: Input
    }],
    allowCustom: [{
      type: Input
    }],
    valueNormalizer: [{
      type: Input
    }],
    inputAttributes: [{
      type: Input
    }],
    filterChange: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    inputFocus: [{
      type: Output
    }],
    inputBlur: [{
      type: Output
    }],
    removeTag: [{
      type: Output
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    searchbar: [{
      type: ViewChild,
      args: [SearchBarComponent, {
        static: true
      }]
    }],
    tagList: [{
      type: ViewChild,
      args: [TagListComponent, {
        static: true
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    optionsList: [{
      type: ViewChild,
      args: ["optionsList", {
        static: false
      }]
    }],
    template: [{
      type: ContentChild,
      args: [ItemTemplateDirective, {
        static: false
      }]
    }],
    customItemTemplate: [{
      type: ContentChild,
      args: [CustomItemTemplateDirective, {
        static: false
      }]
    }],
    groupTemplate: [{
      type: ContentChild,
      args: [GroupTemplateDirective, {
        static: false
      }]
    }],
    fixedGroupTemplate: [{
      type: ContentChild,
      args: [FixedGroupTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    tagTemplate: [{
      type: ContentChild,
      args: [TagTemplateDirective, {
        static: false
      }]
    }],
    groupTagTemplate: [{
      type: ContentChild,
      args: [GroupTagTemplateDirective, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: [SuffixTemplateDirective]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: [PrefixTemplateDirective]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-multiselect"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    dir: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    disabledClass: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }]
  });
})();
var ColumnCellTemplateDirective = class _ColumnCellTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnCellTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnCellTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnCellTemplateDirective,
    selectors: [["", "kendoMultiColumnComboBoxColumnCellTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnCellTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiColumnComboBoxColumnCellTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ColumnHeaderTemplateDirective = class _ColumnHeaderTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function ColumnHeaderTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ColumnHeaderTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _ColumnHeaderTemplateDirective,
    selectors: [["", "kendoMultiColumnComboBoxColumnHeaderTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnHeaderTemplateDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiColumnComboBoxColumnHeaderTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ComboBoxColumnComponent = class _ComboBoxColumnComponent {
  /**
   * @hidden
   */
  cellTemplate;
  /**
   * @hidden
   */
  headerTemplate;
  /**
   * Sets the field to which the column is bound.
   *
   * > The `field` property can be set to point to a nested property value - e.g. `category.name`.
   */
  field;
  /**
   * Sets the title of the column.
   */
  title;
  /**
   * Sets the width of the column (in pixels).
   */
  width;
  /**
   * Controls the visibility of the column. When `true`, hides the column from view.
   * @default false
   */
  hidden = false;
  /**
   * Sets custom styles for the table cells of the column (except for the header cells).
   *
   * The `style` property uses the NgStyle directive to apply styles.
   */
  style;
  /**
   * Sets custom styles for the header cell of the column.
   *
   * The `headerStyle` property uses the NgStyle directive to apply styles.
   */
  headerStyle;
  /**
   * Sets custom CSS classes for the column cells.
   *
   * The `class` property uses the NgClass directive to apply classes.
   */
  class;
  /**
   * Sets custom CSS classes for the column header cell.
   *
   * The `headerClass` property uses the NgClass directive to apply classes.
   */
  headerClass;
  /**
   * Sets the condition that needs to be satisfied for a column to remain visible. If you set the [`hidden`]({% slug api_dropdowns_comboboxcolumncomponent %}#toc-hidden) property, the behavior of media is overridden.
   */
  media;
  /**
   * @hidden
   */
  matchesMedia = true;
  static ɵfac = function ComboBoxColumnComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxColumnComponent)();
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _ComboBoxColumnComponent,
    selectors: [["kendo-combobox-column"]],
    contentQueries: function ComboBoxColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ColumnCellTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, ColumnHeaderTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cellTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
      }
    },
    inputs: {
      field: "field",
      title: "title",
      width: "width",
      hidden: "hidden",
      style: "style",
      headerStyle: "headerStyle",
      class: "class",
      headerClass: "headerClass",
      media: "media"
    },
    standalone: true,
    features: [ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function ComboBoxColumnComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxColumnComponent, [{
    type: Component,
    args: [{
      selector: "kendo-combobox-column",
      template: "",
      standalone: true
    }]
  }], null, {
    cellTemplate: [{
      type: ContentChild,
      args: [ColumnCellTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [ColumnHeaderTemplateDirective, {
        static: false
      }]
    }],
    field: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    style: [{
      type: Input
    }],
    headerStyle: [{
      type: Input
    }],
    class: [{
      type: Input
    }],
    headerClass: [{
      type: Input
    }],
    media: [{
      type: Input
    }]
  });
})();
var SCROLLBAR_WIDTH;
var scrollbarWidth = () => {
  if (isNaN(SCROLLBAR_WIDTH)) {
    const div = document.createElement("div");
    div.style.cssText = "overflow: scroll; overflow-x: hidden; zoom: 1; clear: both; display: block;";
    div.innerHTML = "&nbsp;";
    document.body.appendChild(div);
    SCROLLBAR_WIDTH = div.offsetWidth - div.scrollWidth;
    document.body.removeChild(div);
  }
  return SCROLLBAR_WIDTH;
};
var allColumnsWidthsSet = (columns) => {
  if (!isPresent5(columns) || columns.length === 0) {
    return false;
  }
  return columns.toArray().every((column) => !isNaN(column.width) && column.width > 0);
};
var getRowWidthFromColumnsMeta = (columns) => {
  if (!allColumnsWidthsSet(columns)) {
    return null;
  }
  const bordersWidth = 2;
  const initialRowWidht = scrollbarWidth() + bordersWidth;
  return columns.reduce((totalWidth, column) => {
    if (!column.hidden && column.matchesMedia) {
      totalWidth += parseInt(column.width, 10);
    }
    return totalWidth;
  }, initialRowWidht);
};
var MultiColumnComboBoxComponent = class _MultiColumnComboBoxComponent extends ComboBoxComponent {
  hostElement;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  hostClasses = true;
  /**
   * @hidden
   */
  get isDisabled() {
    return this.disabled;
  }
  /**
   * Contains a query list of all declared `ComboBoxColumnComponent` columns.
   * Use this property to access and configure the columns displayed in the dropdown.
   */
  columns;
  /**
   * @hidden
   */
  set header(header) {
    this.updateHeaderPadding(header && header.nativeElement);
  }
  /**
   * @hidden
   */
  set headerTable(headerTable) {
    this._headerTable = headerTable;
    if (this.headerTable) {
      this.zone.onStable.pipe(take(1)).subscribe(() => {
        this.rowWidth = this.calculateRowWidth();
      });
    }
  }
  get headerTable() {
    return this._headerTable;
  }
  /**
   * @hidden
   */
  set headerColumns(columns) {
    this.zone.onStable.pipe(take(1)).subscribe(() => {
      this.headerColumnWidths = columns.map((column) => column.nativeElement.offsetWidth);
    });
  }
  /**
   * @hidden
   */
  rowWidth;
  /**
   * @hidden
   */
  headerColumnWidths = [];
  /**
   * @hidden
   */
  totalColumnsWidth;
  get popupWidth() {
    const wrapperOffsetWidth = this.wrapper.nativeElement.offsetWidth;
    const min = `${wrapperOffsetWidth}px`;
    const width = this.popupSettings.width || getRowWidthFromColumnsMeta(this.columns) || wrapperOffsetWidth;
    const max = isNaN(width) ? width : `${width}px`;
    return {
      min,
      max
    };
  }
  _headerTable;
  removeWindowResizeListener = noop6;
  columnsChangeSubscription = new Subscription();
  /**
   * @hidden
   */
  get tableSizeClass() {
    return `${this.size ? getSizeClass2("table", this.size) : ""}`;
  }
  /**
   * @hidden
   */
  get listContainerClasses() {
    return ["k-popup", "k-dropdowngrid-popup"].concat(this.popupSettings.popupClass || []);
  }
  constructor(localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, wrapper, injector, hostElement, adaptiveService) {
    super(wrapper, localization, popupService, selectionService, navigationService, disabledItemsService, dataService, zone, changeDetector, renderer, injector, hostElement, adaptiveService);
    this.hostElement = hostElement;
    this.defaultVirtualItemHeight = 36;
    this.defaultVirtualPageSize = 30;
  }
  ngAfterViewInit() {
    this.updateColumnsMediaState();
    this.addWindowResizeListener();
    this.windowSize = this.adaptiveService.size;
    this.rowWidth = this.calculateRowWidth();
    this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);
    this.columnsChangeSubscription = this.columns.changes.subscribe(() => {
      this.rowWidth = this.calculateRowWidth();
      this.totalColumnsWidth = this.columns.reduce((total, currentColumn) => total + currentColumn.width, 0);
    });
    this.cdr.detectChanges();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.removeWindowResizeListener();
    if (this.columnsChangeSubscription) {
      this.columnsChangeSubscription.unsubscribe();
    }
  }
  /**
   * @hidden
   */
  textFrom(dataItem, field) {
    return getter2(dataItem, field);
  }
  /**
   * @hidden
   *
   * Adds or removes a padding value at the end of the header container equal to the size of the scrollbar.
   * As when the items container has a scrollbar, the column headers and the cells are misaligned.
   * When the container has a scrollbar, the padding style is added, and when there is none - it is removed.
   */
  updateHeaderPadding(header) {
    if (!isPresent5(header)) {
      return;
    }
    const headerPaddingPosition = this.localization.rtl ? "padding-left" : "padding-right";
    if (this.optionsList.hasScrollbar() && scrollbarWidth() > 0) {
      this.renderer.setStyle(header, headerPaddingPosition, `${scrollbarWidth()}px`);
    } else {
      this.renderer.removeStyle(header, headerPaddingPosition);
    }
  }
  /**
   *
   * @hidden
   */
  getColumnWidth(index) {
    if (!this.virtual) {
      return this.columns.get(index).width;
    }
    return this.headerColumnWidths[index];
  }
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (isPresent5(this.data) && this.data.length > 0 && this.data.some((item) => !isObject(item))) {
      throw new Error(MultiColumnComboBoxMessages.data);
    }
    if (!isPresent5(this.valueField) || !isPresent5(this.textField)) {
      throw new Error(MultiColumnComboBoxMessages.textAndValue);
    }
    super.verifySettings();
  }
  addWindowResizeListener() {
    if (!isDocumentAvailable()) {
      return;
    }
    this.zone.runOutsideAngular(() => this.removeWindowResizeListener = this.renderer.listen(window, "resize", this.updateColumnsMediaState.bind(this)));
  }
  updateColumnsMediaState() {
    if (!(isPresent5(this.columns) && isDocumentAvailable()) || this.isActionSheetExpanded) {
      return;
    }
    this.columns.forEach((column) => {
      const matchesMedia = !column.media || window.matchMedia(column.media).matches;
      if (column.matchesMedia !== matchesMedia) {
        column.matchesMedia = matchesMedia;
        if (this.isOpen) {
          this.zone.run(() => this.popupRef.popupElement.style.width = this.popupWidth.max);
        }
      }
    });
  }
  calculateRowWidth() {
    if (this.isActionSheetExpanded || !this.virtual) {
      return;
    }
    return this.headerTable?.nativeElement.offsetWidth;
  }
  static ɵfac = function MultiColumnComboBoxComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiColumnComboBoxComponent)(ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(SelectionService2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(DisabledItemsService), ɵɵdirectiveInject(DataService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiColumnComboBoxComponent,
    selectors: [["kendo-multicolumncombobox"]],
    contentQueries: function MultiColumnComboBoxComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, ComboBoxColumnComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      }
    },
    viewQuery: function MultiColumnComboBoxComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(_c212, 5);
        ɵɵviewQuery(_c222, 5);
        ɵɵviewQuery(_c232, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTable = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerColumns = _t);
      }
    },
    hostVars: 4,
    hostBindings: function MultiColumnComboBoxComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵclassProp("k-dropdowngrid", ctx.hostClasses)("k-disabled", ctx.isDisabled);
      }
    },
    standalone: true,
    features: [ɵɵProvidersFeature([SelectionService2, DataService, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multicolumncombobox"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: FilterableComponent,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }, {
      provide: MultiTabStop,
      useExisting: forwardRef(() => _MultiColumnComboBoxComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 20,
    vars: 38,
    consts: () => {
      let i18n_18;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_18 = goog.getMsg("NO DATA FOUND");
        i18n_18 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_18;
      } else {
        i18n_18 = $localize`:kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_19;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_19 = goog.getMsg("clear");
        i18n_19 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_19;
      } else {
        i18n_19 = $localize`:kendo.multicolumncombobox.clearTitle|The title of the clear button:clear`;
      }
      let i18n_20;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_20 = goog.getMsg("Select");
        i18n_20 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_20;
      } else {
        i18n_20 = $localize`:kendo.multicolumncombobox.selectButtonText|The title of the select button:Select`;
      }
      let i18n_21;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21 = goog.getMsg("Options list");
        i18n_21 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_21;
      } else {
        i18n_21 = $localize`:kendo.multicolumncombobox.popupLabel|The label of the popup element that contains the list of options
                when its role is 'region':Options list`;
      }
      let i18n_22;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_22 = goog.getMsg("Close");
        i18n_22 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_22;
      } else {
        i18n_22 = $localize`:kendo.multicolumncombobox.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      return [["select", ""], ["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["header", ""], ["headerWrap", ""], ["headerTable", ""], ["rowTemplate", ""], ["optionsList", ""], ["columnHeader", ""], ["kendoMultiColumnComboBoxLocalizedMessages", "", "noDataText", i18n_18, "clearTitle", i18n_19, "selectButtonText", i18n_20, "popupLabel", i18n_21, "adaptiveCloseButtonTitle", i18n_22], ["kendoDropDownSharedEvents", "", 3, "isFocusedChange", "handleBlur", "onFocus", "hostElement", "isFocused"], ["class", "k-input-prefix k-input-prefix-horizontal", 4, "ngIf"], [4, "ngIf"], ["kendoSearchbar", "", 3, "onNavigate", "valueChange", "onBlur", "onFocus", "click", "ariaControls", "ariaExpanded", "id", "isLoading", "isSuggestable", "isFilterable", "activeDescendant", "userInput", "suggestedText", "disabled", "readonly", "tabIndex", "isRequired", "placeholder", "inputAttributes"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "kendoEventsOutsideAngular", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["class", "k-input-suffix k-input-suffix-horizontal", 4, "ngIf"], ["tabindex", "-1", "aria-hidden", "true", "unselectable", "on", "type", "button", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass", "kendoEventsOutsideAngular"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "resize", 4, "ngIf"], [3, "closePopup", "textInputChange", "navigate", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "placeholder", "searchBarValue"], [1, "k-input-prefix", "k-input-prefix-horizontal"], [3, "ngTemplateOutlet"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click", "kendoEventsOutsideAngular"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [1, "k-input-suffix", "k-input-suffix-horizontal"], [4, "ngTemplateOutlet"], [3, "resize"], [1, "k-data-table", 3, "ngClass"], [1, "k-table-header"], [1, "k-table-header-wrap"], ["role", "presentation", 1, "k-table"], [4, "ngFor", "ngForOf"], [1, "k-table-thead"], [1, "k-table-row"], [3, "pageChange", "listResize", "popupListScroll", "optionPrefix", "data", "size", "textField", "valueField", "template", "groupTemplate", "fixedGroupTemplate", "height", "show", "id", "virtual", "type", "rowWidth", "showStickyHeader"], ["class", "k-no-data", 4, "ngIf"], [3, "templateContext"], [3, "width", 4, "ngIf"], ["class", "k-table-th", 3, "ngStyle", "ngClass", 4, "ngIf"], [1, "k-table-th", 3, "ngStyle", "ngClass"], ["class", "k-table-td", 3, "ngClass", "width", "max-width", "ngStyle", 4, "ngIf"], [1, "k-table-td", 3, "ngClass", "ngStyle"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"], [1, "k-table-footer"], [1, "k-table"], [1, "k-table-tfoot"], [1, "k-table-td"]];
    },
    template: function MultiColumnComboBoxComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 10);
        ɵɵelementContainerStart(1, 11);
        ɵɵtwoWayListener("isFocusedChange", function MultiColumnComboBoxComponent_Template_ng_container_isFocusedChange_1_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx.isFocused, $event) || (ctx.isFocused = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("handleBlur", function MultiColumnComboBoxComponent_Template_ng_container_handleBlur_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleBlur());
        })("onFocus", function MultiColumnComboBoxComponent_Template_ng_container_onFocus_1_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFocus());
        });
        ɵɵtemplate(2, MultiColumnComboBoxComponent_span_2_Template, 2, 1, "span", 12)(3, MultiColumnComboBoxComponent_kendo_separator_3_Template, 1, 0, "kendo-separator", 13);
        ɵɵelementStart(4, "input", 14);
        ɵɵlistener("onNavigate", function MultiColumnComboBoxComponent_Template_input_onNavigate_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        })("valueChange", function MultiColumnComboBoxComponent_Template_input_valueChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("onBlur", function MultiColumnComboBoxComponent_Template_input_onBlur_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputBlur());
        })("onFocus", function MultiColumnComboBoxComponent_Template_input_onFocus_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleInputFocus());
        })("click", function MultiColumnComboBoxComponent_Template_input_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleClick());
        });
        ɵɵelementEnd();
        ɵɵtemplate(5, MultiColumnComboBoxComponent_span_5_Template, 2, 7, "span", 15)(6, MultiColumnComboBoxComponent_span_6_Template, 1, 0, "span", 16)(7, MultiColumnComboBoxComponent_kendo_separator_7_Template, 1, 0, "kendo-separator", 13)(8, MultiColumnComboBoxComponent_span_8_Template, 2, 1, "span", 17);
        ɵɵelementStart(9, "button", 18, 0);
        ɵɵelement(11, "kendo-icon-wrapper", 19);
        ɵɵelementEnd();
        ɵɵelementContainerEnd();
        ɵɵtemplate(12, MultiColumnComboBoxComponent_ng_template_12_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(14, MultiColumnComboBoxComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 20);
        ɵɵelementContainer(15, null, 2);
        ɵɵelementStart(17, "kendo-adaptive-renderer", 21);
        ɵɵlistener("closePopup", function MultiColumnComboBoxComponent_Template_kendo_adaptive_renderer_closePopup_17_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.closeActionSheet());
        })("textInputChange", function MultiColumnComboBoxComponent_Template_kendo_adaptive_renderer_textInputChange_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.searchBarChange($event));
        })("navigate", function MultiColumnComboBoxComponent_Template_kendo_adaptive_renderer_navigate_17_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleNavigate($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(18, MultiColumnComboBoxComponent_ng_template_18_Template, 19, 23, "ng-template", null, 3, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(19);
        ɵɵadvance();
        ɵɵproperty("hostElement", ctx.hostElement);
        ɵɵtwoWayProperty("isFocused", ctx.isFocused);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.prefixTemplate && ctx.prefixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ariaControls", ctx.ariaControls)("ariaExpanded", ctx.isOpen)("id", ctx.focusableId)("isLoading", ctx.loading)("isSuggestable", ctx.suggest)("isFilterable", ctx.filterable)("activeDescendant", ctx.activeDescendant)("userInput", ctx.text)("suggestedText", ctx.getSuggestion())("disabled", ctx.disabled)("readonly", ctx.readonly)("tabIndex", ctx.tabIndex)("isRequired", ctx.isControlRequired)("placeholder", ctx.placeholder)("inputAttributes", ctx.inputAttributes);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.clearButton && !ctx.loading && !ctx.disabled && (!ctx.readonly || ctx.readonly && ctx.isAdaptiveModeEnabled && ctx.windowSize !== "large") && (ctx.text == null ? null : ctx.text.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate && ctx.suffixTemplate.showSeparator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.suffixTemplate);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses)("kendoEventsOutsideAngular", ɵɵpureFunction1(36, _c172, ctx.preventEventDefault));
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance(2);
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
        ɵɵadvance(3);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", true)("subtitle", ctx.adaptiveSubtitle)("placeholder", ctx.placeholder)("searchBarValue", ctx.text);
      }
    },
    dependencies: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, NgForOf, NgStyle, ListComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiColumnComboBoxComponent, [{
    type: Component,
    args: [{
      providers: [SelectionService2, DataService, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multicolumncombobox"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: FilterableComponent,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }, {
        provide: MultiTabStop,
        useExisting: forwardRef(() => MultiColumnComboBoxComponent)
      }],
      selector: "kendo-multicolumncombobox",
      template: `
        <ng-container
            kendoMultiColumnComboBoxLocalizedMessages
            i18n-noDataText="
                kendo.multicolumncombobox.noDataText|The text displayed in the popup when there are no items
            "
            noDataText="NO DATA FOUND"
            i18n-clearTitle="kendo.multicolumncombobox.clearTitle|The title of the clear button"
            clearTitle="clear"
            i18n-selectButtonText="kendo.multicolumncombobox.selectButtonText|The title of the select button"
            selectButtonText="Select"
            i18n-popupLabel="
                kendo.multicolumncombobox.popupLabel|The label of the popup element that contains the list of options
                when its role is 'region'
            "
            popupLabel="Options list"
            i18n-adaptiveCloseButtonTitle="kendo.multicolumncombobox.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"
        ></ng-container>

        <ng-container
            kendoDropDownSharedEvents
            [hostElement]="hostElement"
            [(isFocused)]="isFocused"
            (handleBlur)="handleBlur()"
            (onFocus)="handleFocus()"
        >
            <span *ngIf="prefixTemplate" class="k-input-prefix k-input-prefix-horizontal">
                <ng-template [ngTemplateOutlet]="prefixTemplate?.templateRef">
                </ng-template>
            </span>
            <kendo-separator *ngIf="prefixTemplate && prefixTemplate.showSeparator"></kendo-separator>
            <input
                kendoSearchbar
                [ariaControls]="ariaControls"
                [ariaExpanded]="isOpen"
                [id]="focusableId"
                [isLoading]="loading"
                [isSuggestable]="suggest"
                [isFilterable]="filterable"
                [activeDescendant]="activeDescendant"
                [userInput]="text"
                [suggestedText]="getSuggestion()"
                [disabled]="disabled"
                [readonly]="readonly"
                [tabIndex]="tabIndex"
                [isRequired]="isControlRequired"
                [placeholder]="placeholder"
                [inputAttributes]="inputAttributes"
                (onNavigate)="handleNavigate($event)"
                (valueChange)="searchBarChange($event)"
                (onBlur)="handleInputBlur()"
                (onFocus)="handleInputFocus()"
                (click)="handleClick()"
            />
            <span
                *ngIf="clearButton && !loading && !disabled && (!readonly || readonly && isAdaptiveModeEnabled && windowSize !== 'large')  && text?.length"
                class="k-clear-value"
                [style.visibility]="clearButtonVisiblity"
                aria-hidden="true"
                [attr.title]="messageFor('clearTitle')"
                (click)="clearValue($event)"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper name="x" [svgIcon]="xIcon"> </kendo-icon-wrapper>
            </span>

            <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
            <kendo-separator *ngIf="suffixTemplate && suffixTemplate.showSeparator"></kendo-separator>
            <span *ngIf="suffixTemplate" class="k-input-suffix k-input-suffix-horizontal">
                <ng-template [ngTemplateOutlet]="suffixTemplate?.templateRef">
                </ng-template>
            </span>
            <button
                #select
                tabindex="-1"
                aria-hidden="true"
                unselectable="on"
                type="button"
                class="k-input-button k-button k-icon-button"
                [ngClass]="selectButtonClasses"
                [attr.aria-label]="messageFor('selectButtonText')"
                [attr.disabled]="disabled ? '' : null"
                [kendoEventsOutsideAngular]="{
                    mousedown: preventEventDefault
                }"
            >
                <kendo-icon-wrapper
                    [name]="icon || 'caret-alt-down'"
                    innerCssClass="k-button-icon"
                    [svgIcon]="svgIcon || caretAltDownIcon"
                >
                </kendo-icon-wrapper>
            </button>
        </ng-container>

        <ng-template #popupTemplate>
            <!--popup/actionsheet content-->
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"> </kendo-resize-sensor>

        <!-- when the popupSettings.appendTo value is set to 'component', this container is used -->
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="true"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="closeActionSheet()"
            (textInputChange)="searchBarChange($event)"
            (navigate)="handleNavigate($event)"
            [placeholder]="placeholder"
            [searchBarValue]="text">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <!--user-defined header template -->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }"
            >
            </ng-template>
            <!--data table-->
            <div class="k-data-table" [ngClass]="tableSizeClass">
                <!--grid header-->
                <div #header class="k-table-header">
                    <div #headerWrap class="k-table-header-wrap">
                        <table #headerTable class="k-table" role="presentation">
                            <colgroup>
                                <ng-container *ngFor="let column of columns">
                                    <col *ngIf="!column.hidden && column.matchesMedia" [style.width.px]="column.width" />
                                </ng-container>
                            </colgroup>
                            <thead class="k-table-thead">
                                <tr class="k-table-row">
                                    <ng-container *ngFor="let column of columns">
                                        <th
                                            #columnHeader
                                            *ngIf="!column.hidden && column.matchesMedia"
                                            class="k-table-th"
                                            [ngStyle]="column.headerStyle"
                                            [ngClass]="column.headerClass"
                                        >
                                            <ng-container *ngIf="!column.headerTemplate">
                                                {{ column.title || column.field }}
                                            </ng-container>
                                            <ng-template
                                                *ngIf="column.headerTemplate"
                                                [templateContext]="{
                                                    templateRef: column.headerTemplate?.templateRef,
                                                    $implicit: column,
                                                    column: column
                                                }"
                                            >
                                            </ng-template>
                                        </th>
                                    </ng-container>
                                </tr>
                            </thead>
                        </table>
                    </div>
                </div>
                <!-- item template -->
                <ng-template #rowTemplate let-dataItem>
                    <ng-container *ngFor="let column of columns; let i = index">
                        <span
                            *ngIf="!column.hidden && column.matchesMedia"
                            class="k-table-td"
                            [ngClass]="column.class"
                            [style.width.px]="getColumnWidth(i)"
                            [style.max-width.px]="getColumnWidth(i)"
                            [ngStyle]="column.style"
                        >
                            <ng-container *ngIf="!column.cellTemplate">
                                {{ textFrom(dataItem, column.field) }}
                            </ng-container>
                            <ng-template
                                *ngIf="column.cellTemplate"
                                [templateContext]="{
                                    templateRef: column.cellTemplate?.templateRef,
                                    $implicit: dataItem,
                                    dataItem: dataItem,
                                    column: column
                                }"
                            >
                            </ng-template>
                        </span>
                    </ng-container>
                </ng-template>
                <kendo-list
                    #optionsList
                    [optionPrefix]="optionPrefix"
                    [data]="data"
                    [size]="isAdaptive ? 'large' : size"
                    [textField]="textField"
                    [valueField]="valueField"
                    [template]="{ templateRef: rowTemplate }"
                    [groupTemplate]="groupTemplate"
                    [fixedGroupTemplate]="fixedGroupTemplate"
                    [height]="listHeight"
                    [show]="isOpen"
                    [id]="listBoxId"
                    [virtual]="virtual"
                    [type]="'dropdowngrid'"
                    [rowWidth]="rowWidth"
                    [showStickyHeader]="showStickyHeader"
                    (pageChange)="pageChange($event)"
                    (listResize)="updateHeaderPadding(header)"
                    (popupListScroll)="headerWrap.scrollLeft = $event.target.scrollLeft;"
                >
                </kendo-list>

                <!--no-data template-->
                <div class="k-no-data" *ngIf="data.length === 0">
                    <ng-template
                        [ngIf]="noDataTemplate"
                        [templateContext]="{
                            templateRef: noDataTemplate?.templateRef
                        }"
                    >
                    </ng-template>
                    <ng-template [ngIf]="!noDataTemplate">
                        <div>{{ messageFor('noDataText') }}</div>
                    </ng-template>
                </div>

                <!--user-defined footer template-->
                <ng-container *ngIf="footerTemplate">
                    <div class="k-table-footer">
                        <table class="k-table">
                            <tfoot class="k-table-tfoot">
                                <tr class="k-table-row">
                                    <td class="k-table-td">
                                        <ng-template
                                            [templateContext]="{
                                                templateRef: footerTemplate.templateRef
                                            }"
                                        >
                                        </ng-template>
                                    </td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                </ng-container>
            </div>
        </ng-template>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, SharedDropDownEventsDirective, NgIf, NgTemplateOutlet, SeparatorComponent, SearchBarComponent, EventsOutsideAngularDirective, IconWrapperComponent, NgClass, ResizeSensorComponent, AdaptiveRendererComponent2, TemplateContextDirective, NgForOf, NgStyle, ListComponent]
    }]
  }], function() {
    return [{
      type: LocalizationService
    }, {
      type: PopupService
    }, {
      type: SelectionService2
    }, {
      type: NavigationService2
    }, {
      type: DisabledItemsService
    }, {
      type: DataService
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdowngrid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }],
    columns: [{
      type: ContentChildren,
      args: [ComboBoxColumnComponent]
    }],
    header: [{
      type: ViewChild,
      args: ["header", {
        static: false
      }]
    }],
    headerTable: [{
      type: ViewChild,
      args: ["headerTable", {
        static: false
      }]
    }],
    headerColumns: [{
      type: ViewChildren,
      args: ["columnHeader"]
    }]
  });
})();
var NodeTemplateDirective2 = class _NodeTemplateDirective {
  templateRef;
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
  static ɵfac = function NodeTemplateDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NodeTemplateDirective)(ɵɵdirectiveInject(TemplateRef));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _NodeTemplateDirective,
    selectors: [["", "kendoDropDownTreeNodeTemplate", ""], ["", "kendoMultiSelectTreeNodeTemplate", ""]],
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NodeTemplateDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeNodeTemplate], [kendoMultiSelectTreeNodeTemplate]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var DEFAULT_POPUP_SETTINGS$1 = {
  animate: true
};
var hasChildren$1 = () => false;
var fetchChildren$1 = () => of([]);
var itemDisabled$1 = () => false;
var isNodeVisible$1 = () => true;
var DEFAULT_SIZE$12 = "medium";
var DEFAULT_ROUNDED$12 = "medium";
var DEFAULT_FILL_MODE$12 = "solid";
var stopPropagation = (event) => event.stopImmediatePropagation();
var DropDownTreeComponent = class _DropDownTreeComponent {
  injector;
  wrapper;
  popupService;
  navigationService;
  renderer;
  _zone;
  cdr;
  localization;
  adaptiveService;
  /**
   * @hidden
   */
  icon;
  /**
   * @hidden
   */
  svgIcon;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  caretAltDownIcon = caretAltDownIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  /**
   * @hidden
   */
  adaptiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRendererComponent?.actionSheetSearchBar;
  }
  hostClasses = true;
  get isReadonly() {
    return this.readonly ? "" : null;
  }
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  get isDisabled() {
    return this.disabled || null;
  }
  get isLoading() {
    return this.loading;
  }
  get isBusy() {
    return this.loading ? "true" : null;
  }
  get hostAriaControls() {
    return this.isOpen ? this.treeViewId : void 0;
  }
  get id() {
    return this.focusableId;
  }
  direction;
  get hostTabIndex() {
    return this.tabindex;
  }
  role = "combobox";
  ariaHasPopup = "tree";
  get isAriaExpanded() {
    return this.isOpen;
  }
  get hostAriaAutocomplete() {
    return this.filterable ? "list" : null;
  }
  noDataTemplate;
  headerTemplate;
  footerTemplate;
  nodeTemplate;
  valueTemplate;
  popupTemplate;
  container;
  set treeview(treeview) {
    if (treeview) {
      if (this.isFocused && !this.filterable || this.touchEnabled) {
        treeview.focus();
      }
      treeview.animate = true;
      this._treeview = treeview;
    }
  }
  get treeview() {
    return this._treeview;
  }
  filterInput;
  /**
   * Fires each time the popup is about to open
   * ([see example]({% slug openstate_ddt %})).
   * This event is preventable. If you cancel it, the popup will remain closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup has been opened.
   */
  opened = new EventEmitter();
  /**
   * Fires each time the popup is about to close
   * ([see example]({% slug openstate_ddt %})).
   * This event is preventable. If you cancel it, the popup will remain open.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup has been closed.
   */
  closed = new EventEmitter();
  /**
   * Fires when the user expands a node in the popup TreeView.
   */
  nodeExpand = new EventEmitter();
  /**
   * Fires when the user collapses a node in the popup TreeView.
   */
  nodeCollapse = new EventEmitter();
  /**
   * Fires each time the user focuses the DropDownTree.
   */
  onFocus = new EventEmitter();
  /**
   * Fires each time the DropDownTree gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires each time the value is changed
   * ([see example](slug:events_ddt)).
   */
  valueChange = new EventEmitter();
  /**
   * Fires when the value of the built-in filter input element changes.
   */
  filterChange = new EventEmitter();
  /**
   * Sets and gets the loading state of the DropDownTree.
   */
  loading;
  /**
   * If set to `true`, renders a button on hovering over the component.
   * Clicking this button resets the value of the component to `undefined` and triggers the `change` event.
   */
  clearButton = true;
  /**
   * Sets the data of the DropDownTree.
   *
   * > The data has to be provided in an array-like list with objects.
   */
  set data(data) {
    this._nodes = data;
    this.setState();
  }
  get data() {
    return this._nodes;
  }
  /**
   * Sets the value of the DropDownTree.
   * It can either be of the primitive (string, numbers) or of the complex (objects) type.
   * To define the type, use the `valuePrimitive` option.
   *
   */
  set value(newValue) {
    this._value = newValue;
    this.setState();
  }
  get value() {
    return this._value;
  }
  /**
   * The fields of the data item that provide the text content of the nodes inside the
   * DropDownTree ([see example]({% slug databinding_ddt %})). If the `textField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * The fields of the data item that provide the value of the nodes inside the
   * DropDownTree ([see example]({% slug databinding_ddt %})). If the `valueField`
   * input is set to an array, each hierarchical level uses the field that corresponds
   * to the same index in the array, or the last item in the array.
   *
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Sets the level in the data set where the value can be found when `valueField` is an Array.
   * The field serves to correctly allocate a data item used when the DropDownTree is initialized with a value.
   */
  valueDepth;
  /**
   * A function which determines if a specific node has child nodes.
   */
  hasChildren = hasChildren$1;
  /**
   * A function which provides the child nodes for a given parent node.
   */
  fetchChildren = fetchChildren$1;
  /**
   * Sets the placeholder of the input element of the DropDownTree.
   */
  placeholder = "";
  /**
   * Configures the popup of the DropDownTree.
   *
   * The available options are:
   * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.
   * - `width: Number | String`&mdash;Sets the width of the popup container. By default, the width of the host element is used. If set to `auto`, the component automatically adjusts the width of the popup and no item labels are wrapped.
   * - `height: Number`&mdash;Sets the height of the popup container.
   * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.
   * - `appendTo: "root" | "component" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS$1, settings);
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Keeps the current `dataItem` object in order to resolve selection.
   * Needs to be provided when `value` is bound in and `valuePrimitive` is set to true.
   */
  set dataItem(item) {
    this._dataItem = item;
    this.setState();
  }
  get dataItem() {
    return this._dataItem ? this._dataItem : this.value;
  }
  /**
   * Sets the height of the options list in the popup. By default, `listHeight` is 200px.
   *
   * > The `listHeight` property affects only the list of options and not the whole popup container.
   * > To set the height of the popup container, use `popupSettings.height`.
   *
   * When using `adaptiveMode` and the screen size is `small` or `medium` the `listHeight` property is set to null.
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Sets the disabled state of the component. To learn how to disable the component in reactive forms, refer to the article on [Forms Support](slug:formssupport_ddt#toc-managing-the-dropdowntree-disabled-state-in-reactive-forms).
   */
  disabled = false;
  /**
   * Sets the read-only state of the component.
   *
   * @default false
   */
  readonly = false;
  /**
   * Specifies the type of the selected value
   * ([more information and example]({% slug valuebinding_ddt %}#toc-primitive-values)).
   * If set to `true`, the selected value has to be of a primitive value.
   */
  valuePrimitive = false;
  /**
   * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
   */
  set tabindex(value) {
    const providedTabIndex = Number(value);
    const defaultTabIndex = 0;
    this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the size of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `none`
   *
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius of the component.
   *
   * The possible values are:
   * * `small`
   * * `medium` (default)
   * * `large`
   * * `full`
   * * `none`
   *
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fillMode of the component.
   *
   * The possible values are:
   * * `flat`
   * * `solid` (default)
   * * `outline`
   * * `none`
   *
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE$12;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * A function that is executed for each data item and determines if a specific item is disabled.
   */
  itemDisabled = itemDisabled$1;
  /**
   * A function that is executed for each data item and determines if a specific node is expanded.
   */
  isNodeExpanded;
  /**
   * A callback which determines whether a tree node should be rendered as hidden. The utility `.k-hidden` class is used to hide the nodes.
   * Useful for custom filtering implementations.
   */
  isNodeVisible = isNodeVisible$1;
  /**
   * Indicates whether the child nodes will be fetched on node expand or will be initially prefetched.
   * @default true
   */
  loadOnDemand = true;
  /**
   * Renders the built-in input element for filtering the DropDownTree.
   * If set to `true`, the component emits the `filterChange` event, which can be used to [filter the DropDownTree manually]({% slug filtering_ddt %}#toc-manual-filtering).
   * A built-in filtering implementation is available to use with the [`kendoDropDownTreeHierarchyBinding`]({% slug api_dropdowns_dropdowntreehierarchybindingdirective %}) and [`kendoDropDownTreeFlatBinding`]({% slug api_dropdowns_dropdowntreeflatbindingdirective %}) directives.
   */
  filterable = false;
  /**
   * @hidden
   */
  filter = "";
  /**
   * @hidden
   *
   * Used by the kendo-label and kendo-floatinglabel to access and associate the focusable element with the provided label via aria-labelledby.
   */
  focusableId = `k-${guid()}`;
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  get width() {
    const wrapperWidth = this.wrapper.nativeElement.offsetWidth;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(isPresent5(this.popupRef) || this.isActionSheetExpanded);
  }
  get clearButtonVisiblity() {
    if (this.touchEnabled) {
      return "visible";
    }
  }
  get isFilterActive() {
    return this.filterInput && document.activeElement === this.filterInput.nativeElement;
  }
  popupRef;
  /**
   * @hidden
   */
  selectedKeys = [];
  /**
   * @hidden
   */
  selectBy;
  /**
   * @hidden
   */
  text;
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filterChange.emit(text);
    }
  }
  /**
   * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
   */
  adaptiveMode = "none";
  /**
   * Sets the title of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet title uses the text provided for the label of the DropDownTree.
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle of the ActionSheet that is rendered instead of the Popup when using small screen devices.
   * By default the ActionSheet does not render a subtitle.
  */
  adaptiveSubtitle = "";
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  /**
   * @hidden
   *
   * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  set isExpanded(callback) {
    this.isNodeExpanded = callback;
  }
  get isExpanded() {
    return this.isNodeExpanded;
  }
  /**
   * @hidden
   *
   * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get expand() {
    return this.nodeExpand;
  }
  /**
   * @hidden
   *
   * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get collapse() {
    return this.nodeCollapse;
  }
  /**
   * @hidden
   *
   * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives.
   */
  set nodes(nodes) {
    this.data = nodes;
  }
  get nodes() {
    return this.data;
  }
  /**
   * @hidden
   *
   * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives
   */
  set children(callback) {
    this.fetchChildren = callback;
  }
  get children() {
    return this.fetchChildren;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
   * The `DataBoundComponent` interface is used in the data-binding directives.
   */
  set isVisible(callback) {
    this.isNodeVisible = callback;
  }
  get isVisible() {
    return this.isNodeVisible;
  }
  /**
   * @hidden
   */
  filterStateChange = new EventEmitter();
  /**
   * @hidden
   */
  allNodesHidden = false;
  /**
   * @hidden
   *
   * Used to associate the value label with the wrapper via aria-describedby.
   */
  valueLabelId = `k-${guid()}`;
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  treeViewId = `k-${guid()}`;
  _nodes;
  _value;
  _popupSettings = DEFAULT_POPUP_SETTINGS$1;
  _tabindex = 0;
  _isFocused = false;
  _dataItem;
  _treeview;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _searchableNodes = [];
  _typedValue = "";
  printableCharacters = new Subject();
  subs = new Subscription();
  touchstartDisposeHandler;
  // Keep an instance of the last focused node for when the popup close is prevented
  // in order to be able to properly restore the focus
  lastNodeOnFocus;
  constructor(injector, wrapper, popupService, navigationService, renderer, _zone, cdr, localization, adaptiveService) {
    this.injector = injector;
    this.wrapper = wrapper;
    this.popupService = popupService;
    this.navigationService = navigationService;
    this.renderer = renderer;
    this._zone = _zone;
    this.cdr = cdr;
    this.localization = localization;
    this.adaptiveService = adaptiveService;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeTouchEvents();
    this.subscribeFocusEvents();
  }
  ngOnInit() {
    this.subs.add(this.printableCharacters.pipe(tap((char) => {
      this._typedValue += char;
      const itemToFocus = this._searchableNodes.find((node) => {
        return node.text.toLowerCase().startsWith(this._typedValue);
      });
      this.treeview.focus(itemToFocus?.index);
    }), debounceTime(1e3)).subscribe(() => {
      this._typedValue = "";
    }));
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.assignAriaDescribedBy();
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setComponentClasses();
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.unsubscribeEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.setState();
    }
    if (isChanged("value", changes, false)) {
      if (changes["value"] && !changes["dataItem"] && !this.valuePrimitive) {
        this.dataItem = this.value;
      }
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
    if (this.data?.length > 0 && this.popupRef) {
      this.allNodesHidden = this.areNodesHidden(this.data);
    }
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "click", this.handleClick.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  /**
   * @hidden
   *
   * Used by the kendo-floatinglabel component to determine if the floating label
   * should be rendered inside the input when the component is not focused.
   */
  isEmpty() {
    return !this.text && !this.placeholder;
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    if (isDisabled2 || sameState) {
      return;
    }
    const togglePrevented = this.triggerPopupEvents(open);
    if (!togglePrevented) {
      if (open) {
        this.createPopup();
      } else {
        this.destroyPopup();
      }
    }
  }
  /**
   * @hidden
   */
  handleFocus(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleBlur(e) {
    if (!this.isActionSheetExpanded) {
      const relatedTarget = e && e.relatedTarget;
      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {
        return;
      }
      this.isFocused = false;
      this.togglePopup(false);
      if (hasObservers(this.onBlur) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleKeydown(event, input) {
    if (this.disabled || this.readonly) {
      return;
    }
    if (event.keyCode === Keys.Tab && this.isActionSheetExpanded) {
      this.togglePopup(false);
      return;
    }
    if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {
      this.printableCharacters.next(event.key);
    }
    const eventData = event;
    this.navigationService.process({
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: this.isOpen && !input && !(event.target instanceof HTMLInputElement)
    });
  }
  /**
   * Focuses a specific item of the DropDownTree based on a provided index in the format of `1_1`.
   * The targeted item should be expanded in order for it to be focused.
   * If null or invalid index is provided the focus will be set on the first item.
   */
  focusItemAt(index) {
    if (this.treeview) {
      const lookup = this.treeview.itemLookup(index);
      const isItemDisabled = !isPresent5(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
      if (!isItemDisabled) {
        this.treeview.focus(index);
      }
    }
  }
  /**
   * Focuses the DropDownTree.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Blurs the DropDownTree.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
    }
  }
  /**
   * Resets the value of the DropDownTree.
   * If you use the `reset` method to clear the value of the component,
   * the model will not update automatically and the `valueChange` event will not be fired.
   */
  reset() {
    this.value = void 0;
    this.dataItem = void 0;
  }
  /**
   * Toggles the visibility of the popup or actionSheet.
   * ([see example]({% slug openstate_ddt %})).
   * If you use the `toggle` method to open or close the popup or actionSheet, the `open` and `close` events will not be fired.
   *
   * @param open - The state of the popup.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !isPresent5(this.popupRef);
      this.destroyPopup();
      if (shouldOpen) {
        this.createPopup();
      }
    });
  }
  /**
   * @hidden
   */
  get popupContainerClasses() {
    const containerClasses = ["k-dropdowntree-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   */
  onSelectionChange({
    dataItem,
    index
  }) {
    this.valueDepth = index.split("_").length - 1;
    const valueField = this.getField(this.valueField, dataItem);
    const newValue = this.valuePrimitive ? getter(valueField)(dataItem) : dataItem;
    const shouldUpdateValue = newValue !== this.value;
    if (shouldUpdateValue) {
      this.value = newValue;
      this.dataItem = dataItem;
      this.emitValueChange(this.value);
    }
    this.togglePopup(false);
    this.focus();
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  /**
   * @hidden
   */
  clearValue(event) {
    event.stopImmediatePropagation();
    this.focus();
    this.value = void 0;
    this.dataItem = void 0;
    this.clearState();
    this.valueChange.emit(void 0);
    this.emitValueChange();
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  preventEventDefault(event) {
    event.preventDefault();
  }
  /**
   * @hidden
   */
  writeValue(value) {
    if (!isPresent5(value) && isPresent5(this.value)) {
      this.dataItem = null;
    }
    this.value = value === null ? void 0 : value;
    if (isPresent5(this.value) && !this.valuePrimitive) {
      this.dataItem = this.value;
    }
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilterInputChange(input) {
    const value = typeof input === "string" ? input : input.value;
    this.filter = value;
    this.filterChange.next(value);
    this.allNodesHidden = this.areNodesHidden(this.nodes);
    this._zone.onStable.pipe(take(1)).subscribe(() => {
      if (this.data.length === 0 || this.allNodesHidden || this.filter === "") {
        this.filterInput?.nativeElement.focus();
      }
    });
  }
  /**
   * @hidden
   */
  get selectButtonClasses() {
    return `${this.size ? getSizeClass2("button", this.size) : ""} ${this.fillMode ? "k-button-" + this.fillMode : ""} ${this.fillMode ? "k-button-" + this.fillMode + "-base" : ""}`;
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  onTouchedCallback = noop6;
  onChangeCallback = noop6;
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (this.valuePrimitive === true && isPresent5(this.value) && typeof this.value === "object") {
      throw new Error(DropDownTreeMessages.primitive);
    }
    if (this.valuePrimitive === true && isPresent5(this.value) && typeof this.dataItem !== "object") {
      throw new Error(DropDownTreeMessages.dataItem);
    }
    if (this.valuePrimitive === false && isPresent5(this.value) && typeof this.value !== "object") {
      throw new Error(DropDownTreeMessages.object);
    }
    if (!isPresent5(this.valueField) || !isPresent5(this.textField)) {
      throw new Error(DropDownTreeMessages.textAndValue);
    }
    if ((isArray2(this.valueField) || isArray2(this.textField)) && isPresent5(this.value) && !isPresent5(this.valueDepth)) {
      throw new Error(DropDownTreeMessages.valueDepth);
    }
  }
  emitValueChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  getText(textField, dataItem) {
    if (isPresent5(dataItem) && isPresent5(textField)) {
      const field = this.getField(textField, dataItem);
      return getter(field)(dataItem);
    }
    return null;
  }
  /**
   * @hidden
   */
  onChildrenLoaded() {
    setTimeout(() => {
      if (this.popupRef) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
      }
      if (this.isActionSheetExpanded) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
      }
    });
  }
  /**
   * @hidden
   *
   * Determines the `valueField` and `textField` for a specific level in the data set
   *  @param field - the field value (string | string[])
   *  @param value - current value
   */
  getField(field, value) {
    const fieldsCount = field.length - 1;
    if (typeof field === "string") {
      return field;
    } else if (isPresent5(this.valueDepth)) {
      return fieldsCount < this.valueDepth ? field[fieldsCount] : field[this.valueDepth];
    } else if (value && typeof value === "object") {
      return field.find((item) => item in value);
    }
  }
  areNodesHidden(nodes) {
    return nodes.every((node, index) => !this.isVisible(node, String(index)));
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (open) {
      this.open.emit(eventArgs);
    } else {
      this.close.emit(eventArgs);
    }
    return eventArgs.isDefaultPrevented();
  }
  createPopup() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      this.cdr.detectChanges();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      appendTo: this.appendTo,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupClass: this.popupContainerClasses
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    this.renderer.setStyle(popupWrapper, "minWidth", min);
    this.renderer.setStyle(popupWrapper, "width", max);
    this.renderer.setStyle(popupWrapper, "height", this.height);
    this.renderer.setAttribute(popupWrapper, "dir", this.direction);
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    this.popupRef.popupOpen.subscribe(() => {
      this.allNodesHidden = this.areNodesHidden(this.data);
      this.popupRef.popupElement.addEventListener("click", (event) => stopPropagation(event));
      this.cdr.detectChanges();
      this.opened.emit();
      this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
    });
    this.popupRef.popupClose.subscribe(() => {
      this.closed.emit();
    });
  }
  destroyPopup() {
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this.popupRef) {
      this.popupRef.popupElement.removeEventListener("click", (event) => stopPropagation(event));
      this.popupRef.close();
      this.popupRef = null;
      this.clearFilter();
    }
  }
  clearFilter() {
    if (this.filter !== "") {
      this.filter = "";
      this.allNodesHidden = false;
      if (hasObservers(this.filterChange)) {
        this._zone.run(() => {
          this.filterChange.emit("");
        });
      }
    }
  }
  handleClick(e) {
    this.windowSize = this.adaptiveService.size;
    if (!this.isActionSheetExpanded) {
      if (this.popupRef && !this.popupRef.popupElement.contains(e.target) || !this.popupRef && !e.target.className.includes("k-treeview-leaf")) {
        this.togglePopup(!this.isOpen);
      }
    }
  }
  handleEscape() {
    this.togglePopup(false);
    this.focus();
  }
  setState() {
    if (isPresent5(this.value) && isPresent5(this.dataItem) && isPresent5(this.valueField)) {
      this.text = this.getText(this.textField, this.dataItem);
      const valueField = this.getField(this.valueField, this.dataItem);
      this.selectBy = valueField;
      this.selectedKeys = [getter(valueField)(this.dataItem)];
    } else {
      this.clearState();
    }
    this.cdr.markForCheck();
  }
  clearState() {
    this.text = void 0;
    this.selectedKeys = [];
  }
  subscribeEvents() {
    [this.navigationService.open.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(true);
    }), this.navigationService.close.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(false);
      this.focus();
    }), this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe((e) => {
      if (e.originalEvent.target === this.wrapper.nativeElement) {
        this.togglePopup(true);
      }
      if (!this.isOpen) {
        this.focus();
      }
    }), this.navigationService.esc.subscribe(() => this.handleEscape()), this.navigationService.tab.subscribe(() => {
      this.focus();
      if (this.isOpen) {
        this.treeview.blur();
        this.removeTreeViewFromTabOrder();
      }
    }), this.navigationService.down.subscribe((event) => {
      if (!this.treeview) {
        return;
      }
      event.originalEvent.preventDefault();
      if (!this.treeview.isActive) {
        this.treeview.focus();
      }
    }), this.navigationService.up.subscribe((event) => {
      if (!this.treeview) {
        return;
      }
      event.originalEvent.preventDefault();
      if (this.filterable && this.treeview["navigationService"]["activeIndex"] === "0") {
        if (this.isActionSheetExpanded) {
          this.actionSheetSearchBar.focus();
        } else {
          this.filterInput.nativeElement.focus();
        }
      }
    })].forEach((sub) => this.subs.add(sub));
  }
  subscribeTouchEvents() {
    if (!isDocumentAvailable() || !this.touchEnabled) {
      return;
    }
    this._zone.runOutsideAngular(() => (
      // Roll up DropDownTree on iOS when tapped outside
      this.touchstartDisposeHandler = this.renderer.listen(document, "touchstart", (e) => {
        const target = e.target;
        if (this.isFocused && !inDropDown(this.wrapper, target, this.popupRef)) {
          this._zone.run(() => {
            if (this.isOpen) {
              this.treeview.blur();
            }
            this.blur();
          });
        }
      })
    ));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.handleFocus = this.handleFocus.bind(this);
      this.handleDocumentBlur = this.handleDocumentBlur.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.handleFocus, useCapture);
        document.addEventListener("blur", this.handleDocumentBlur, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.handleFocus, useCapture);
      document.removeEventListener("blur", this.handleDocumentBlur, useCapture);
    }
  }
  unsubscribeEvents() {
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
    if (this.touchstartDisposeHandler) {
      this.touchstartDisposeHandler();
    }
  }
  handleDocumentBlur(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.handleBlur(event);
  }
  assignAriaDescribedBy() {
    const currentValue = this.wrapper.nativeElement.getAttribute("aria-describedby") || "";
    const newValue = `${this.valueLabelId} ${currentValue.trim()}`.trim();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-describedby", newValue);
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("picker", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("picker", this.fillMode));
    }
  }
  /**
   * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur
   * and the user will not be able to tab to the rest of the browser elements
   */
  removeTreeViewFromTabOrder() {
    const nodes = this.treeview.element.nativeElement.querySelectorAll("li");
    nodes.forEach((item) => {
      if (item.getAttribute("tabindex") === "0") {
        this.lastNodeOnFocus = item;
        this.lastNodeOnFocus.setAttribute("tabindex", "-1");
      }
    });
  }
  closeActionSheet() {
    this.actionSheet.toggle(false);
    if (this.filterable) {
      this.clearFilter();
    }
    this.wrapper.nativeElement.focus();
    this.closed.emit();
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this.adaptiveTitle = setActionSheetTitle(this.wrapper, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.opened.emit();
    this.removeTreeViewFromTabOrder();
  }
  static ɵfac = function DropDownTreeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeComponent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _DropDownTreeComponent,
    selectors: [["kendo-dropdowntree"]],
    contentQueries: function DropDownTreeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, ValueTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.valueTemplate = _t.first);
      }
    },
    viewQuery: function DropDownTreeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(_c262, 5);
        ɵɵviewQuery(_c272, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeview = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
      }
    },
    hostVars: 22,
    hostBindings: function DropDownTreeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("readonly", ctx.isReadonly)("aria-invalid", ctx.hostAriaInvalid)("aria-disabled", ctx.isDisabled)("aria-busy", ctx.isBusy)("aria-controls", ctx.hostAriaControls)("id", ctx.id)("dir", ctx.direction)("tabindex", ctx.hostTabIndex)("role", ctx.role)("aria-haspopup", ctx.ariaHasPopup)("aria-expanded", ctx.isAriaExpanded)("aria-autocomplete", ctx.hostAriaAutocomplete);
        ɵɵclassProp("k-dropdowntree", ctx.hostClasses)("k-picker", ctx.hostClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      icon: "icon",
      svgIcon: "svgIcon",
      loading: "loading",
      clearButton: "clearButton",
      data: "data",
      value: "value",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      hasChildren: "hasChildren",
      fetchChildren: "fetchChildren",
      placeholder: "placeholder",
      popupSettings: "popupSettings",
      dataItem: "dataItem",
      listHeight: "listHeight",
      disabled: "disabled",
      readonly: "readonly",
      valuePrimitive: "valuePrimitive",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      itemDisabled: "itemDisabled",
      isNodeExpanded: "isNodeExpanded",
      isNodeVisible: "isNodeVisible",
      loadOnDemand: "loadOnDemand",
      filterable: "filterable",
      filter: "filter",
      focusableId: "focusableId",
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle"
    },
    outputs: {
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      nodeExpand: "nodeExpand",
      nodeCollapse: "nodeCollapse",
      onFocus: "focus",
      onBlur: "blur",
      valueChange: "valueChange",
      filterChange: "filterChange"
    },
    exportAs: ["kendoDropDownTree"],
    standalone: true,
    features: [ɵɵProvidersFeature([DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
      provide: L10N_PREFIX,
      useValue: "kendo.dropdowntree"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: DataBoundComponent,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }, {
      provide: ExpandableComponent,
      useExisting: forwardRef(() => _DropDownTreeComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 15,
    vars: 17,
    consts: () => {
      let i18n_23;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23 = goog.getMsg("NO DATA FOUND");
        i18n_23 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_23;
      } else {
        i18n_23 = $localize`:kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_24;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_24 = goog.getMsg("clear");
        i18n_24 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_24;
      } else {
        i18n_24 = $localize`:kendo.dropdowntree.clearTitle|The title of the clear button:clear`;
      }
      let i18n_25;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25 = goog.getMsg("Select");
        i18n_25 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_25;
      } else {
        i18n_25 = $localize`:kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button:Select`;
      }
      let i18n_26;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_26 = goog.getMsg("Filter");
        i18n_26 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_26;
      } else {
        i18n_26 = $localize`:kendo.dropdowntree.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_27;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27 = goog.getMsg("Options list");
        i18n_27 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_27;
      } else {
        i18n_27 = $localize`:kendo.dropdowntree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_28;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_28 = goog.getMsg("Close");
        i18n_28 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_28;
      } else {
        i18n_28 = $localize`:kendo.dropdowntree.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      let i18n_29;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_29 = goog.getMsg("Filter");
        i18n_29 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_29;
      } else {
        i18n_29 = $localize`:kendo.dropdowntree.filterInputPlaceholder|The text for the input's placeholder when filtering is enabled:Filter`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["filterInput", ""], ["treeview", ""], ["kendoDropDownTreeLocalizedMessages", "", "noDataText", i18n_23, "clearTitle", i18n_24, "selectButtonText", i18n_25, "filterInputLabel", i18n_26, "popupLabel", i18n_27, "adaptiveCloseButtonTitle", i18n_28, "filterInputPlaceholder", i18n_29], [1, "k-input-inner", 3, "click"], ["class", "k-input-value-text", 4, "ngIf"], ["class", "k-clear-value", "aria-hidden", "true", 3, "visibility", "click", 4, "ngIf"], ["class", "k-i-loading k-input-loading-icon k-icon", 4, "ngIf"], ["tabindex", "-1", "type", "button", "aria-hidden", "true", 1, "k-input-button", "k-button", "k-icon-button", 3, "ngClass"], ["innerCssClass", "k-button-icon", 3, "name", "svgIcon"], [3, "closePopup", "textInputChange", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "placeholder", "searchBarValue", "filterable"], [3, "resize", 4, "ngIf"], [1, "k-input-value-text"], [4, "ngIf"], [3, "ngIf"], [3, "templateContext"], ["aria-hidden", "true", 1, "k-clear-value", 3, "click"], ["name", "x", 3, "svgIcon"], [1, "k-i-loading", "k-input-loading-icon", "k-icon"], [4, "ngTemplateOutlet"], ["class", "k-list-filter", 4, "ngIf"], ["kendoTreeViewSelectable", "", 3, "size", "nodes", "maxHeight", "animate", "selectedKeys", "selectBy", "textField", "children", "hasChildren", "loadOnDemand", "isExpanded", "isDisabled", "nodeTemplate", "filter", "isVisible", "selectedKeysChange", "focusout", "keydown", "selectionChange", "expand", "collapse", "childrenLoaded", 4, "ngIf"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter"], [1, "k-textbox", "k-input", 3, "ngClass"], [1, "k-input-prefix"], ["name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "textbox", 1, "k-input-inner", 3, "input", "keydown.arrowdown", "keydown.alt.arrowup", "keydown.escape", "filterInput", "value", "kendoEventsOutsideAngular", "scope"], ["kendoTreeViewSelectable", "", 3, "selectedKeysChange", "focusout", "keydown", "selectionChange", "expand", "collapse", "childrenLoaded", "size", "nodes", "animate", "selectedKeys", "selectBy", "textField", "children", "hasChildren", "loadOnDemand", "isExpanded", "isDisabled", "nodeTemplate", "filter", "isVisible"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "resize"]];
    },
    template: function DropDownTreeComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 5);
        ɵɵelementStart(1, "span", 6);
        ɵɵlistener("click", function DropDownTreeComponent_Template_span_click_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView($event.preventDefault());
        });
        ɵɵtemplate(2, DropDownTreeComponent_span_2_Template, 3, 2, "span", 7);
        ɵɵelementEnd();
        ɵɵtemplate(3, DropDownTreeComponent_span_3_Template, 2, 4, "span", 8)(4, DropDownTreeComponent_span_4_Template, 1, 0, "span", 9);
        ɵɵelementStart(5, "button", 10);
        ɵɵelement(6, "kendo-icon-wrapper", 11);
        ɵɵelementEnd();
        ɵɵtemplate(7, DropDownTreeComponent_ng_template_7_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(9, null, 1);
        ɵɵelementStart(11, "kendo-adaptive-renderer", 12);
        ɵɵlistener("closePopup", function DropDownTreeComponent_Template_kendo_adaptive_renderer_closePopup_11_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function DropDownTreeComponent_Template_kendo_adaptive_renderer_textInputChange_11_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleFilterInputChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(12, DropDownTreeComponent_ng_template_12_Template, 5, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor)(14, DropDownTreeComponent_kendo_resize_sensor_14_Template, 1, 0, "kendo-resize-sensor", 13);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(13);
        ɵɵadvance();
        ɵɵattribute("id", ctx.valueLabelId);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.valueTemplate || ctx.text || ctx.placeholder);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.text == null ? null : ctx.text.length) && !ctx.disabled);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance();
        ɵɵproperty("ngClass", ctx.selectButtonClasses);
        ɵɵattribute("aria-label", ctx.messageFor("selectButtonText"))("disabled", ctx.disabled ? "" : null);
        ɵɵadvance();
        ɵɵproperty("name", ctx.icon || "caret-alt-down")("svgIcon", ctx.svgIcon || ctx.caretAltDownIcon);
        ɵɵadvance(5);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", ctx.filterable)("subtitle", ctx.adaptiveSubtitle)("placeholder", ctx.placeholder)("searchBarValue", ctx.filter)("filterable", ctx.filterable);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedMessagesDirective2, NgIf, TemplateContextDirective, IconWrapperComponent, NgClass, NgTemplateOutlet, AdaptiveRendererComponent2, FilterInputDirective, EventsOutsideAngularDirective, TreeViewComponent, SelectDirective, ResizeSensorComponent],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoDropDownTree",
      providers: [DataService, SelectionService2, NavigationService2, DisabledItemsService, LocalizationService, {
        provide: L10N_PREFIX,
        useValue: "kendo.dropdowntree"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: DataBoundComponent,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }, {
        provide: ExpandableComponent,
        useExisting: forwardRef(() => DropDownTreeComponent)
      }],
      selector: "kendo-dropdowntree",
      template: `
        <ng-container kendoDropDownTreeLocalizedMessages
            i18n-noDataText="kendo.dropdowntree.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.dropdowntree.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-selectButtonText="kendo.dropdowntree.selectButtonText|The text set as aria-label on the select button"
            selectButtonText="Select"

            i18n-filterInputLabel="kendo.dropdowntree.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.dropdowntree.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.dropdowntree.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"

            i18n-filterInputPlaceholder="kendo.dropdowntree.filterInputPlaceholder|The text for the input's placeholder when filtering is enabled"
            filterInputPlaceholder="Filter"
        >
        </ng-container>
        <span
            [attr.id]="valueLabelId"
            class="k-input-inner"
            (click)="$event.preventDefault()"
        >
            <span class="k-input-value-text" *ngIf="valueTemplate || text || placeholder">
                <ng-template *ngIf="valueTemplate"
                    [templateContext]="{
                        templateRef: valueTemplate.templateRef,
                        $implicit: dataItem
                    }">
                </ng-template>
                <ng-template [ngIf]="!valueTemplate"> {{ text || placeholder }} </ng-template>
            </span>
        </span>
        <span
            *ngIf="!loading && !readonly && clearButton && text?.length && !disabled"
            class="k-clear-value"
            [style.visibility]="clearButtonVisiblity"
            aria-hidden="true"
            [attr.title]="messageFor('clearTitle')"
            (click)="clearValue($event)"
        >
            <kendo-icon-wrapper
                name="x"
                [svgIcon]="xIcon"
            >
            </kendo-icon-wrapper>
        </span>
        <span *ngIf="loading" class="k-i-loading k-input-loading-icon k-icon"></span>
        <button
            tabindex="-1"
            type="button"
            aria-hidden="true"
            class="k-input-button k-button k-icon-button"
            [ngClass]="selectButtonClasses"
            [attr.aria-label]="messageFor('selectButtonText')"
            [attr.disabled]="disabled ? '' : null"
        >
            <kendo-icon-wrapper
                [name]="icon || 'caret-alt-down'"
                innerCssClass="k-button-icon"
                [svgIcon]="svgIcon || caretAltDownIcon"
            >
            </kendo-icon-wrapper>
        </button>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="filterable"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="handleFilterInputChange($event)"
            [placeholder]="placeholder"
            [searchBarValue]="filter"
            [filterable]="filterable">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <span
                *ngIf="filterable && !isActionSheetExpanded"
                class="k-list-filter"
            >
                <span
                    class="k-textbox k-input"
                    [ngClass]="filterInputClasses"
                >
                    <span class="k-input-prefix">
                        <kendo-icon-wrapper
                            class="k-icon"
                            name="search"
                            [svgIcon]="searchIcon"
                        >
                        </kendo-icon-wrapper>
                    </span>
                    <input
                        #filterInput
                        (input)="handleFilterInputChange($event.target)"
                        [filterInput]="filterable && !touchEnabled"
                        (keydown.arrowdown)="handleKeydown($event, filterInput)"
                        (keydown.alt.arrowup)="handleKeydown($event, filterInput)"
                        (keydown.escape)="handleKeydown($event, filterInput)"
                        [attr.aria-label]="messageFor('filterInputLabel')"
                        [value]="filter"
                        class="k-input-inner"
                        role="textbox"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
            </span>
            <!--header template-->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }">
            </ng-template>
            <kendo-treeview
                #treeview
                [attr.id]="treeViewId"
                *ngIf="data.length !== 0 && !allNodesHidden"
                [size]="windowSize !== 'large' ? 'large' : size"
                [nodes]="data"
                [style.maxHeight.px]="listHeight"
                [animate]="false"
                [(selectedKeys)]="selectedKeys"
                [selectBy]="selectBy"
                [textField]="textField"
                kendoTreeViewSelectable
                [children]="children"
                [hasChildren]="hasChildren"
                [loadOnDemand]="loadOnDemand"
                [isExpanded]="isNodeExpanded"
                [isDisabled]="itemDisabled"
                [nodeTemplate]="nodeTemplate"
                [filter]="filter"
                [isVisible]="isNodeVisible"
                (focusout)="handleBlur($event)"
                (keydown)="handleKeydown($event)"
                (selectionChange)="onSelectionChange($event)"
                (expand)="nodeExpand.emit($event)"
                (collapse)="nodeCollapse.emit($event)"
                (childrenLoaded)="onChildrenLoaded()"
            >
            </kendo-treeview>
            <!--footer template-->
            <ng-template
                *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate?.templateRef
                }">
            </ng-template>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="data.length === 0 || allNodesHidden">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      imports: [LocalizedMessagesDirective2, NgIf, TemplateContextDirective, IconWrapperComponent, NgClass, NgTemplateOutlet, AdaptiveRendererComponent2, FilterInputDirective, EventsOutsideAngularDirective, TreeViewComponent, SelectDirective, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: NavigationService2
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: LocalizationService
    }, {
      type: AdaptiveService
    }];
  }, {
    icon: [{
      type: Input
    }],
    svgIcon: [{
      type: Input
    }],
    adaptiveRendererComponent: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-dropdowntree"]
    }, {
      type: HostBinding,
      args: ["class.k-picker"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    hostAriaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaHasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isAriaExpanded: [{
      type: HostBinding,
      args: ["attr.aria-expanded"]
    }],
    hostAriaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplate: [{
      type: ContentChild,
      args: [NodeTemplateDirective2, {
        static: false
      }]
    }],
    valueTemplate: [{
      type: ContentChild,
      args: [ValueTemplateDirective, {
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    treeview: [{
      type: ViewChild,
      args: ["treeview", {
        static: false
      }]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput", {
        static: false
      }]
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    nodeExpand: [{
      type: Output
    }],
    nodeCollapse: [{
      type: Output
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }],
    loading: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    fetchChildren: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    dataItem: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    valuePrimitive: [{
      type: Input
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    isNodeExpanded: [{
      type: Input
    }],
    isNodeVisible: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }]
  });
})();
var nodeIndex2 = (item) => (item || {}).key;
var buildTreeItem2 = (dataItem, valueField, currentLevelIndex) => {
  if (!isPresent5(dataItem)) {
    return null;
  }
  return {
    dataItem,
    key: valueFrom({
      dataItem,
      level: currentLevelIndex
    }, valueField) + "_" + currentLevelIndex
  };
};
var MultiSelectTreeLookupService = class _MultiSelectTreeLookupService {
  map = /* @__PURE__ */ new Map();
  reset() {
    this.map.clear();
  }
  registerChildren(index, children) {
    const item = this.item(index);
    if (!item) {
      return;
    }
    item.children = children;
  }
  item(index) {
    return this.map.get(index) || null;
  }
  registerItem(item, parent) {
    const currentLookup = {
      children: [],
      item,
      parent: this.item(nodeIndex2(parent))
    };
    this.map.set(item.key, currentLookup);
  }
  itemLookup(index) {
    const item = this.item(index);
    if (!item) {
      return null;
    }
    return {
      children: this.mapChildren(item.children),
      item: item.item,
      parent: item.parent
    };
  }
  mapChildren(children = []) {
    return children.map((c) => {
      const {
        item,
        parent,
        children: children2
      } = this.item(c.key);
      return {
        children: this.mapChildren(children2),
        item,
        parent
      };
    });
  }
  static ɵfac = function MultiSelectTreeLookupService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeLookupService)();
  };
  static ɵprov = ɵɵdefineInjectable({
    token: _MultiSelectTreeLookupService,
    factory: _MultiSelectTreeLookupService.ɵfac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeLookupService, [{
    type: Injectable
  }], null, null);
})();
var BaseCheckDirective = class _BaseCheckDirective {
  /**
   * @hidden
   * The flag is needed in order to determine how to construct the items map keys.
   * If `true`, then the key consists of the item's value and level (depth),
   * else the key consists of the item's value and 0 (no leveling required)
   */
  isHeterogeneous;
  addItem(item) {
    if (this.isItemChecked(item)) {
      return;
    }
    const level = getHierarchicalItemLevel(item.index);
    const key = this.getKey(item, level);
    const candidate = __spreadProps(__spreadValues({}, item), {
      level,
      key
    });
    this.checkedItems.push(candidate);
    this.checkedKeys.add(key);
  }
  removeItem(item) {
    if (!this.isItemChecked(item)) {
      return;
    }
    const level = getHierarchicalItemLevel(item.index);
    const key = this.getKey(item, level);
    const candidate = __spreadProps(__spreadValues({}, item), {
      level,
      key
    });
    this.checkedItems = this.checkedItems.filter((item2) => {
      const valueMatch = valueFrom(item2, this.valueField) === valueFrom(candidate, this.valueField);
      const levelMatch = item2.level === candidate.level;
      return this.isHeterogeneous ? !(valueMatch && levelMatch) : !valueMatch;
    });
    this.checkedKeys.delete(key);
  }
  isItemChecked(item) {
    const level = item.index.split("_").length - 1;
    item.level = level;
    const key = this.getKey(item, level);
    return this.checkedKeys.has(key);
  }
  updateItems() {
    this.checkedItems = this.checkedItems || [];
    this.checkedKeys = new Set(this.checkedItems.map((item) => item.key));
  }
  /**
   * Add the item's depth to its value so you can have duplicate values on different levels.
   *
   * @param item - The checked key.
   * @returns { string } - A string key consisting of the item's `valueField` value and its depth (depth is 0 if data is homogeneous).
   */
  getKey(item, level) {
    return valueFrom(item, this.valueField) + "_" + (this.isHeterogeneous ? level : 0);
  }
  static ɵfac = function BaseCheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseCheckDirective)();
  };
  static ɵdir = ɵɵdefineDirective({
    type: _BaseCheckDirective,
    inputs: {
      valueField: "valueField",
      checkedItems: "checkedItems",
      isHeterogeneous: "isHeterogeneous"
    }
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseCheckDirective, [{
    type: Directive
  }], null, {
    valueField: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    isHeterogeneous: [{
      type: Input
    }]
  });
})();
var CheckDirective2 = class _CheckDirective extends BaseCheckDirective {
  treeView;
  /**
   * Specifies whether items are checked on click and if checking a node also checks its children.
   * The `checkChildren` property also controls parent item checking (checking all child items automatically checks the parent).
   */
  checkable;
  /**
   * Sets the item key or keys to compare data items.
   */
  valueField;
  /**
   * Sets the collection that stores all checked items.
   */
  checkedItems;
  /**
   * Fires when the `checkedItems` collection updates.
   */
  checkedItemsChange = new EventEmitter();
  /**
   * Holds a `Set` with only the checked item keys. Updates this set each time the `checkedItems` value or content changes and uses it for fast look-up to check if an item is checked.
   */
  checkedKeys = /* @__PURE__ */ new Set();
  subscriptions = new Subscription();
  clickSubscription;
  constructor(treeView) {
    super();
    this.treeView = treeView;
    this.subscriptions.add(this.treeView.checkedChange.subscribe(this.handleCheckedChange.bind(this)));
    this.treeView.isChecked = this.getCheckedState.bind(this);
  }
  ngOnChanges(changes) {
    if (isPresent5(changes["checkable"])) {
      this.toggleCheckOnClick();
    }
    if (isPresent5(changes["checkedItems"])) {
      this.updateItems();
    }
  }
  ngOnDestroy() {
    this.subscriptions.unsubscribe();
    this.unsubscribeClick();
  }
  getCheckedState(dataItem, index) {
    if (this.isItemChecked({
      dataItem,
      index
    })) {
      return "checked";
    } else if (this.checkable.checkChildren && this.isItemIndeterminate(this.treeView.itemLookup(index))) {
      return "indeterminate";
    } else {
      return "none";
    }
  }
  handleCheckedChange(node) {
    this.checkNode(node);
    const checkParents = this.checkable.checkChildren;
    if (checkParents) {
      this.checkParents(node.parent);
    }
    this.checkedItemsChange.emit(this.checkedItems.slice());
  }
  toggleCheckOnClick() {
    this.unsubscribeClick();
    if (this.checkable.checkOnClick) {
      this.clickSubscription = this.treeView.nodeClick.pipe(filter((event) => event.type === "click")).subscribe((event) => {
        const lookup = this.treeView.itemLookup(event.item.index);
        this.handleCheckedChange(lookup);
      });
    }
  }
  unsubscribeClick() {
    if (this.clickSubscription) {
      this.clickSubscription.unsubscribe();
      this.clickSubscription = null;
    }
  }
  checkNode(lookup) {
    if (this.treeView.isDisabled(lookup.item.dataItem, lookup.item.index)) {
      return;
    }
    const target = lookup.item;
    const pendingCheck = [target];
    if (this.checkable.checkChildren) {
      const filter2 = (item) => this.treeView.isVisible(item.dataItem, item.index) && !this.treeView.isDisabled(item.dataItem, item.index);
      fetchDescendentNodes(lookup, filter2).forEach((lookup2) => pendingCheck.push(lookup2.item));
    }
    const shouldCheck = !this.isItemChecked(target);
    pendingCheck.forEach((item) => {
      if (shouldCheck) {
        this.addItem(item);
      } else {
        this.removeItem(item);
      }
    });
  }
  checkParents(parent) {
    let currentParent = parent;
    while (currentParent) {
      const allChildrenSelected = currentParent.children.every((item) => this.isItemChecked(item));
      if (allChildrenSelected) {
        this.addItem(currentParent.item);
      } else {
        this.removeItem(currentParent.item);
      }
      currentParent = currentParent.parent;
    }
  }
  isItemIndeterminate(lookup) {
    const children = lookup.children;
    if (!Array.isArray(children) || children.length === 0) {
      return false;
    }
    let index = 0;
    let child = children[index];
    while (isPresent5(child)) {
      if (this.isItemChecked(child.item) || this.isItemIndeterminate(child)) {
        return true;
      }
      index += 1;
      child = children[index];
    }
    return false;
  }
  static ɵfac = function CheckDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckDirective)(ɵɵdirectiveInject(TreeViewComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckDirective,
    selectors: [["", "kendoMultiSelectTreeCheckable", ""]],
    inputs: {
      checkable: "checkable",
      valueField: "valueField",
      checkedItems: "checkedItems"
    },
    outputs: {
      checkedItemsChange: "checkedItemsChange"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckDirective2, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeCheckable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: TreeViewComponent
    }];
  }, {
    checkable: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    checkedItemsChange: [{
      type: Output
    }]
  });
})();
var CheckAllDirective = class _CheckAllDirective extends BaseCheckDirective {
  element;
  zone;
  cdr;
  renderer;
  lastAction;
  treeview;
  /**
   * Sets the collection that stores all checked items.
   */
  checkedItems;
  /**
   * Sets the item key or keys to compare data items.
   */
  valueField;
  focused;
  /**
   * Fires when the `checkedItems` collection updates.
   */
  checkedItemsChange = new EventEmitter();
  /**
   * Holds a `Set` with only the checked item keys. Updates this set each time the `checkedItems` value or content changes and uses it for fast look-up to check if an item is checked.
   */
  checkedKeys = /* @__PURE__ */ new Set();
  currentCheckedState;
  currentIndeterminateState;
  handleChange(event) {
    this.currentCheckedState = event.checked;
    this.currentIndeterminateState = this.isIndeterminate;
    this.treeview.nodes.forEach((_value, index) => {
      const itemIndex = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex);
      this.checkNode(itemLookup);
    });
    this.checkedItemsChange.emit(this.checkedItems.slice());
  }
  get isIndeterminate() {
    const isIndeterminate = this.treeview.nodes.some((_node, index) => {
      const itemIndex = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex);
      return this.someChecked(itemLookup);
    });
    return this.isChecked ? false : isIndeterminate;
  }
  get isChecked() {
    const isChecked2 = this.treeview.nodes.every((_node, index) => {
      const itemIndex = String(index);
      const itemLookup = this.treeview.itemLookup(itemIndex);
      return this.allChecked(itemLookup);
    });
    return isChecked2;
  }
  constructor(element, zone, cdr, renderer) {
    super();
    this.element = element;
    this.zone = zone;
    this.cdr = cdr;
    this.renderer = renderer;
  }
  ngOnChanges(changes) {
    if (isPresent5(changes["checkedItems"])) {
      this.updateItems();
      this.renderer.setProperty(this.element.nativeElement, "checked", this.isChecked);
      this.renderer.setProperty(this.element.nativeElement, "indeterminate", this.isIndeterminate);
    }
  }
  ngOnInit() {
    if (this.focused) {
      this.nextTick(() => this.element.nativeElement.focus());
    }
  }
  nextTick(fn) {
    this.zone.runOutsideAngular(() => setTimeout(fn));
  }
  checkNode(itemLookup) {
    if (this.treeview.isDisabled(itemLookup.item.dataItem, itemLookup.item.index)) {
      return;
    }
    const pendingCheck = [];
    const filter2 = (item) => this.treeview.isVisible(item.dataItem, item.index) && !this.treeview.isDisabled(item.dataItem, item.index);
    pendingCheck.push(itemLookup.item);
    fetchDescendentNodes(itemLookup, filter2).forEach((lookup) => pendingCheck.push(lookup.item));
    pendingCheck.forEach((item) => {
      if (this.currentIndeterminateState) {
        if (this.lastAction === "check") {
          this.addItem(item);
        } else {
          this.removeItem(item);
        }
        return;
      }
      if (this.currentCheckedState) {
        this.addItem(item);
      } else {
        this.removeItem(item);
      }
    });
  }
  allChecked(lookup) {
    const children = lookup && lookup.children;
    if (!Array.isArray(children)) {
      return;
    }
    const childrenChecked = children.every((child) => {
      if (child.children.length) {
        return this.isItemChecked(child.item) && this.allChecked(child);
      }
      return this.isItemChecked(child.item);
    });
    return childrenChecked && this.isItemChecked(lookup.item);
  }
  someChecked(lookup) {
    const children = lookup && lookup.children;
    if (!Array.isArray(children)) {
      return;
    }
    const childrenChecked = children.some((child) => {
      if (child.children.length) {
        return this.isItemChecked(child.item) || this.someChecked(child);
      }
      return this.isItemChecked(child.item);
    });
    return childrenChecked || this.isItemChecked(lookup.item);
  }
  static ɵfac = function CheckAllDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CheckAllDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Renderer2));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _CheckAllDirective,
    selectors: [["", "checkAll", ""]],
    hostBindings: function CheckAllDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        ɵɵlistener("change", function CheckAllDirective_change_HostBindingHandler($event) {
          return ctx.handleChange($event.target);
        });
      }
    },
    inputs: {
      lastAction: "lastAction",
      treeview: "treeview",
      checkedItems: "checkedItems",
      valueField: "valueField",
      focused: [0, "checkAll", "focused"]
    },
    outputs: {
      checkedItemsChange: "checkedItemsChange"
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckAllDirective, [{
    type: Directive,
    args: [{
      // eslint-disable-next-line
      selector: "[checkAll]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: Renderer2
    }];
  }, {
    lastAction: [{
      type: Input
    }],
    treeview: [{
      type: Input
    }],
    checkedItems: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    focused: [{
      type: Input,
      args: ["checkAll"]
    }],
    checkedItemsChange: [{
      type: Output
    }],
    handleChange: [{
      type: HostListener,
      args: ["change", ["$event.target"]]
    }]
  });
})();
var DEFAULT_POPUP_SETTINGS = {
  animate: true
};
var DEFAULT_CHECKABLE_SETTINGS = {
  checkChildren: true,
  checkOnClick: true
};
var hasChildren2 = () => false;
var fetchChildren = () => of([]);
var itemDisabled = () => false;
var isNodeVisible = () => true;
var DEFAULT_SIZE2 = "medium";
var DEFAULT_ROUNDED2 = "medium";
var DEFAULT_FILL_MODE2 = "solid";
var MultiSelectTreeComponent = class _MultiSelectTreeComponent {
  injector;
  wrapper;
  popupService;
  renderer;
  navigationService;
  _zone;
  localization;
  cdr;
  lookup;
  adaptiveService;
  /**
   * @hidden
   */
  touchEnabled = touchEnabled;
  /**
   * @hidden
   */
  animationDuration = animationDuration2;
  /**
   * @hidden
   */
  searchIcon = searchIcon;
  /**
   * @hidden
   */
  xIcon = xIcon;
  hostClasses = true;
  get isDisabled() {
    return this.disabled || null;
  }
  treeViewId = `k-${guid()}`;
  get hostAriaAutocomplete() {
    return this.filterable ? "list" : null;
  }
  get isLoading() {
    return this.loading;
  }
  get hostAriaInvalid() {
    return this.formControl?.invalid ? true : null;
  }
  get isBusy() {
    return this.loading ? "true" : null;
  }
  get id() {
    return this.focusableId;
  }
  direction;
  get hostTabIndex() {
    return this.tabindex;
  }
  role = "combobox";
  ariaHasPopup = "tree";
  get isReadonly() {
    return this.readonly ? "" : null;
  }
  get ariaDescribedBy() {
    return this.tagListId;
  }
  get ariaActiveDescendant() {
    return this.focusedTagId;
  }
  /**
   * @hidden
   */
  get formControl() {
    const ngControl = this.injector.get(NgControl, null);
    return ngControl?.control || null;
  }
  /**
   * @hidden
   */
  onFilterChange(text) {
    if (this.filterable) {
      this.filter = text;
      this.filterChange.emit(text);
    }
  }
  /**
   * Controls the adaptive mode behavior of the component.
   * Set to `auto` to enable automatic adaptive rendering on small screens.
   *
   * @default 'none'
   */
  adaptiveMode = "none";
  /**
   * Sets the title text for the ActionSheet in adaptive mode on small screens.
   * Uses the component label by default if not set.
   *
   * @default ''
   */
  adaptiveTitle = "";
  /**
   * Sets the subtitle text for the ActionSheet in adaptive mode on small screens.
   * No subtitle appears by default.
   */
  adaptiveSubtitle;
  /**
   * @hidden
   */
  get isAdaptiveModeEnabled() {
    return this.adaptiveMode === "auto";
  }
  /**
  * @hidden
  */
  windowSize = "large";
  /**
   * @hidden
   */
  get isActionSheetExpanded() {
    return this.actionSheet?.expanded;
  }
  /**
   * @hidden
   */
  handleKeydown(event, input) {
    if (event.target === this.filterInput?.nativeElement && (event.keyCode === Keys.ArrowLeft || event.keyCode === Keys.ArrowRight)) {
      return;
    }
    if (input) {
      event.stopImmediatePropagation();
    }
    const deleteTag = this.isWrapperActive && event.keyCode === Keys.Backspace && this.tags.length > 0;
    if (deleteTag) {
      this.handleBackspace();
      return;
    }
    if (this.disabled || this.readonly) {
      return;
    }
    if (!this.isFilterActive && isLetter(event.key) && !this.actionSheetSearchBar?.onFocus) {
      this.printableCharacters.next(event.key);
    }
    const eventData = event;
    const action = this.navigationService.process({
      originalEvent: eventData,
      openOnSpace: !this.isOpen,
      closeOnSpace: false
    });
    if (action === NavigationAction.Open) {
      eventData.preventDefault();
    }
    if (this.isOpen && action === NavigationAction.Enter) {
      const spaceKeyDownEvent = new KeyboardEvent("keydown", {
        "key": " ",
        "code": "Space",
        "keyCode": 32,
        "which": 32
      });
      this.treeview?.element.nativeElement.dispatchEvent(spaceKeyDownEvent);
    }
  }
  /**
   * @hidden
   */
  adaptiveRendererComponent;
  /**
   * @hidden
   */
  get actionSheet() {
    return this.adaptiveRendererComponent?.actionSheet;
  }
  /**
   * @hidden
   */
  get actionSheetSearchBar() {
    return this.adaptiveRendererComponent?.actionSheetSearchBar;
  }
  /**
   * @hidden
   */
  get isAdaptive() {
    return this.isAdaptiveModeEnabled && this.windowSize !== "large";
  }
  headerTemplate;
  footerTemplate;
  nodeTemplate;
  noDataTemplate;
  tagTemplate;
  groupTagTemplate;
  popupTemplate;
  container;
  set treeview(treeview) {
    this._treeview = treeview;
    if (treeview) {
      if (this.isFocused && !this.filterable && !this.checkAll || this.touchEnabled) {
        treeview.focus();
      }
      Promise.resolve(null).then(() => this.treeview.animate = true);
    }
  }
  get treeview() {
    return this._treeview;
  }
  filterInput;
  checkAllInput;
  /**
   * Sets the tab index for keyboard navigation.
   * Use `-1` to remove the component from the tab sequence.
   *
   * @default 0
   */
  set tabindex(value) {
    const providedTabIndex = parseNumber(value);
    const defaultTabIndex = 0;
    this._tabindex = !isNaN(providedTabIndex) ? providedTabIndex : defaultTabIndex;
  }
  get tabindex() {
    return this.disabled ? -1 : this._tabindex;
  }
  /**
   * Sets the visual size of the component.
   *
   * @default 'medium'
   */
  set size(size) {
    const newSize = size ? size : DEFAULT_SIZE2;
    this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    if (size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", newSize));
    }
    this._size = newSize;
  }
  get size() {
    return this._size;
  }
  /**
   * Sets the border radius style of the component.
   *
   * @default 'medium'
   */
  set rounded(rounded) {
    const newRounded = rounded ? rounded : DEFAULT_ROUNDED2;
    this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    if (rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
    }
    this._rounded = newRounded;
  }
  get rounded() {
    return this._rounded;
  }
  /**
   * Sets the fill style for the component background and borders.
   *
   * @default 'solid'
   */
  set fillMode(fillMode) {
    const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE2;
    this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    if (fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", newFillMode));
    }
    this._fillMode = newFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  /**
   * Configures the popup container settings: animation, dimensions, styling and positioning.
   */
  set popupSettings(settings) {
    this._popupSettings = Object.assign({}, DEFAULT_POPUP_SETTINGS, settings);
    this.cdr.detectChanges();
  }
  get popupSettings() {
    return this._popupSettings;
  }
  /**
   * Configures the checkbox behavior for the MultiSelecTree nodes.
   * Use `checkableSettings` to control parent-child selection relationships and click interactions.
   *
   * @default '{ checkChildren: true, checkOnClick: true }'
   */
  set checkableSettings(settings) {
    this._checkableSettings = Object.assign({}, DEFAULT_CHECKABLE_SETTINGS, settings);
  }
  get checkableSettings() {
    return this._checkableSettings;
  }
  /**
   * Sets the hierarchical data source for the tree structure.
   * Provide an array of objects that contain the tree data and structure.
   */
  set data(data) {
    this._nodes = data;
    this.setState();
    if (this.isContentInit) {
      this.registerLookupItems(data);
    }
  }
  get data() {
    return this._nodes;
  }
  /**
   * Sets the selected values in the component.
   * Accepts primitive values if `valuePrimitive` is `true`, or objects if `false`.
   */
  set value(value) {
    this._value = value ? value : [];
    this.setState();
  }
  get value() {
    return this._value;
  }
  /**
   * Sets the data items that correspond to the selected values.
   * Required when using primitive values to resolve the full data objects.
   */
  set dataItems(items) {
    this._dataItems = (items || []).map((dataItem, index) => {
      if (hasProps(dataItem, ["dataItem", "index", "level"])) {
        return dataItem;
      }
      const level = this.valueDepth[index] || 0;
      const key = valueFrom({
        dataItem,
        level
      }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0);
      return {
        dataItem,
        index: null,
        level,
        key
      };
    });
    this.setState();
  }
  get dataItems() {
    return this._dataItems || this.value.map((value, index) => {
      const level = this.valueDepth[index] || 0;
      const key = valueFrom({
        dataItem: value,
        level
      }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0);
      return {
        dataItem: value,
        index: null,
        level,
        key
      };
    });
  }
  /**
   * Specifies which data field provides the display text for tree nodes.
   * > The `textField` property can be set to point to a nested property value - e.g. `category.name`.
   */
  textField;
  /**
   * Specifies which data field provides the unique values for tree nodes.
   * > The `valueField` property can be set to point to a nested property value - e.g. `category.id`.
   */
  valueField;
  /**
   * Sets the levels in the data set where the values can be found when `valueField` is an Array.
   * The field serves to correctly allocate a data item used when the MultiSelectTree is initialized with a value.
   *
   * @default []
   */
  valueDepth = [];
  /**
   * Controls the loading state visual indicator.
   * Shows a loading spinner when set to `true`.
   *
   * @default false
   */
  loading;
  /**
   * Sets the placeholder text shown when no items are selected.
   * Helps guide users on what action to take.
   *
   * @default ''
   */
  placeholder = "";
  /**
   * Sets the maximum height of the options list in the popup.
   * Controls vertical scrolling when content exceeds this height.
   *
   * @default 200
   */
  set listHeight(_listHeight) {
    this._listHeight = _listHeight;
  }
  get listHeight() {
    if (this.isAdaptive) {
      return;
    }
    return this._listHeight;
  }
  _listHeight = 200;
  /**
   * Controls whether the component accepts user input.
   * Prevents all user interactions when set to `true`.
   *
   * @default false
   */
  disabled = false;
  /**
   * Sets the component to read-only mode.
   * Displays current selections but prevents changes.
   *
   * @default false
   */
  readonly = false;
  /**
   * Determines the data type of selected values.
   * Set to `true` for primitive values, false for complex objects.
   *
   * @default false
   */
  valuePrimitive = false;
  /**
   * Controls when child nodes load from the data source.
   * Set to `true` to load children only when parent nodes expand.
   *
   * @default false
   */
  loadOnDemand = false;
  /**
   * Sets the unique identifier for the focusable element.
   * Used internally for accessibility and label association.
   */
  focusableId = `k-${guid()}`;
  /**
   * Shows a clear button to reset all selections.
   * Appears on hover when selections exist and the component is not disabled.
   *
   * @default true
   */
  clearButton = true;
  /**
   * Enables the built-in filter input for searching tree nodes.
   * Shows a search box above the tree when enabled.
   *
   * @default false
   */
  filterable = false;
  /**
   * Shows a checkbox to select or deselect all visible tree nodes.
   * Appears above the tree when checkboxes are enabled.
   *
   * @default false
   */
  checkAll = false;
  /**
   * Determines if a tree node contains child nodes.
   * Return `true` if the node has children, false otherwise.
   */
  hasChildren = hasChildren2;
  /**
   * Function that provides child nodes for a parent node.
   * Return an Observable of child objects for the given parent.
   */
  fetchChildren = fetchChildren;
  /**
   * Determines if a specific node is expanded. The function is executed for each data item.
   */
  isNodeExpanded;
  /**
   * Determines if a tree node should be hidden.
   */
  isNodeVisible = isNodeVisible;
  /**
   * Determines if a tree node is disabled. The function is executed for each data item.
   */
  itemDisabled = itemDisabled;
  /**
   * @param { Any[] } dataItems - The selected data items from the list.
   * @returns { Any[] } - The tags that will be rendered by the component.
   * Transforms the provided array of data items into an array of tags.
   */
  tagMapper = (tags) => tags || [];
  /**
   * Fires when the component receives focus.
   */
  onFocus = new EventEmitter();
  /**
   * Fires when the component gets blurred.
   */
  onBlur = new EventEmitter();
  /**
   * Fires when the popup is about to open. ([See example]({% slug openstate_multiselecttree %})).
   * This event is preventable. When cancelled, the popup remains closed.
   */
  open = new EventEmitter();
  /**
   * Fires after the popup opens completely.
   * Use this event to perform actions when the popup becomes visible.
   */
  opened = new EventEmitter();
  /**
   * Fires before the popup closes.
   * Cancel this event to prevent the popup from closing.
   */
  close = new EventEmitter();
  /**
   * Fires after the popup closes completely.
   * Use this event to perform cleanup actions when the popup becomes hidden.
   */
  closed = new EventEmitter();
  /**
   * Fires when a tree node is expanded.
   * Use this event to respond to node expansion actions.
   */
  nodeExpand = new EventEmitter();
  /**
   * Fires when a user collapses a tree node.
   * Use this event to respond to node collapse actions.
   */
  nodeCollapse = new EventEmitter();
  /**
   * Fires when the selected value changes.
   * Use this event to respond to selection changes.
   */
  valueChange = new EventEmitter();
  /**
   * Fires before a tag is removed.
   * Cancel this event to prevent tag removal.
   */
  removeTag = new EventEmitter();
  /**
   * Fires when the filter input value changes.
   * Use this event to implement custom filtering logic.
   */
  filterChange = new EventEmitter();
  /**
   * @hidden
   */
  get focusedTagId() {
    if (!isPresent5(this.focusedTagIndex) || this.isOpen) {
      return null;
    }
    return this.tagPrefix + "-" + this.focusedTagIndex;
  }
  set isFocused(isFocused) {
    this.renderer[isFocused ? "addClass" : "removeClass"](this.wrapper.nativeElement, "k-focus");
    this._isFocused = isFocused;
  }
  get isFocused() {
    return this._isFocused;
  }
  /**
   * Returns the current open state. Returns `true` if the popup or actionSheet is open.
   */
  get isOpen() {
    return isTruthy(isPresent5(this.popupRef) || this.isActionSheetExpanded);
  }
  get width() {
    const wrapperWidth = this.wrapper.nativeElement.offsetWidth;
    const width = this.popupSettings.width || wrapperWidth;
    const minWidth = isNaN(wrapperWidth) ? wrapperWidth : `${wrapperWidth}px`;
    const maxWidth = isNaN(width) ? width : `${width}px`;
    return {
      min: minWidth,
      max: maxWidth
    };
  }
  get height() {
    const popupHeight = this.popupSettings.height;
    return isPresent5(popupHeight) ? `${popupHeight}px` : "auto";
  }
  get appendTo() {
    const {
      appendTo
    } = this.popupSettings;
    if (!appendTo || appendTo === "root") {
      return void 0;
    }
    return appendTo === "component" ? this.container : appendTo;
  }
  /**
   * @hidden
   */
  get popupContainerClasses() {
    const containerClasses = ["k-multiselecttree-popup"];
    if (this.popupSettings.popupClass) {
      containerClasses.push(this.popupSettings.popupClass);
    }
    return containerClasses;
  }
  /**
   * @hidden
   *
   * Alias for `data`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives.
   */
  set nodes(nodes) {
    this.data = nodes;
  }
  get nodes() {
    return this.data;
  }
  /**
   * @hidden
   *
   * Alias for `fetchChildren`. Used for compatibility with the `DataBoundComponent` interface.
   * Required for the data-binding directives
   */
  set children(callback) {
    this.fetchChildren = callback;
  }
  get children() {
    return this.fetchChildren;
  }
  /**
   * @hidden
   *
   * Alias for `nodeExpand`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get expand() {
    return this.nodeExpand;
  }
  /**
   * @hidden
   *
   * Alias for `nodeCollapse`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  get collapse() {
    return this.nodeCollapse;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeExpanded`. Used for compatibility with the `ExpandableComponent` interface.
   * Required for the expand-directive.
   */
  set isExpanded(callback) {
    this.isNodeExpanded = callback;
  }
  get isExpanded() {
    return this.isNodeExpanded;
  }
  /**
   * @hidden
   *
   * Alias for `isNodeVisible`. Used for compatibility with the `DataBoundComponent` interface.
   * The `DataBoundComponent` interface is used in the data-binding directives.
   */
  set isVisible(callback) {
    this.isNodeVisible = callback;
  }
  get isVisible() {
    return this.isNodeVisible;
  }
  get isTagFocused() {
    return !this.isOpen && this.focusedTagIndex !== void 0;
  }
  get isTreeViewActive() {
    return this.treeview && this.treeview.isActive;
  }
  get isWrapperActive() {
    return document.activeElement === this.wrapper.nativeElement;
  }
  get isFilterActive() {
    return this.filterInput && document.activeElement === this.filterInput.nativeElement;
  }
  get isCheckAllActive() {
    return this.checkAllInput && document.activeElement === this.checkAllInput.nativeElement;
  }
  /**
   * @hidden
   */
  onResize() {
    const currentWindowSize = this.adaptiveService.size;
    if (this.isAdaptiveModeEnabled && this.windowSize !== currentWindowSize) {
      if (this.isOpen) {
        this.togglePopup(false);
      }
      this.windowSize = currentWindowSize;
    }
    if (this.isOpen && !this.isActionSheetExpanded) {
      const popupWrapper = this.popupRef.popupElement;
      const {
        min,
        max
      } = this.width;
      popupWrapper.style.minWidth = min;
      popupWrapper.style.width = max;
    }
  }
  /**
   * @hidden
   */
  filterStateChange = new EventEmitter();
  /**
   * @hidden
   */
  filter = "";
  /**
   * @hidden
   */
  checkedItems = [];
  /**
   * @hidden
   * The flag is needed in order to determine how to construct the items map keys.
   * If `true`, then the key consists of the item's value and level (depth),
   * else the key consists of the item's value and 0 (no leveling required)
   */
  isHeterogeneous;
  /**
   * @hidden
   */
  showAfter = 0;
  /**
   * @hidden
   */
  allNodesHidden = false;
  tagListId = `k-${guid()}`;
  tagPrefix = "tag-" + guid();
  popupRef;
  tags;
  focusedTagIndex = void 0;
  disabledIndices;
  _nodes;
  _value = [];
  _tabindex = 0;
  _popupSettings = DEFAULT_POPUP_SETTINGS;
  _checkableSettings = DEFAULT_CHECKABLE_SETTINGS;
  _isFocused = false;
  _treeview;
  _dataItems;
  _size = "medium";
  _rounded = "medium";
  _fillMode = "solid";
  _searchableNodes = [];
  _typedValue = "";
  printableCharacters = new Subject();
  subs = new Subscription();
  // Keep an instance of the last focused node for when the popup close is prevented
  // in order to be able to properly restore the focus
  lastNodeOnFocus;
  // Used as check to avoid unnecessary 'registerLookupItems()' calls upon initialization
  isContentInit;
  constructor(injector, wrapper, popupService, renderer, navigationService, _zone, localization, cdr, lookup, adaptiveService) {
    this.injector = injector;
    this.wrapper = wrapper;
    this.popupService = popupService;
    this.renderer = renderer;
    this.navigationService = navigationService;
    this._zone = _zone;
    this.localization = localization;
    this.cdr = cdr;
    this.lookup = lookup;
    this.adaptiveService = adaptiveService;
    this.direction = localization.rtl ? "rtl" : "ltr";
    this.subscribeEvents();
    this.subscribeFocusEvents();
  }
  ngOnInit() {
    this.subs.add(this.printableCharacters.pipe(tap((char) => {
      this._typedValue += char;
      const itemToFocus = this._searchableNodes.find((node) => {
        return node.text.toLowerCase().startsWith(this._typedValue);
      });
      this.treeview.focus(itemToFocus?.index);
    }), debounceTime(1e3)).subscribe(() => {
      this._typedValue = "";
    }));
    this.renderer.removeAttribute(this.wrapper.nativeElement, "tabindex");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", String(this.isOpen));
    this.subs.add(this.localization.changes.subscribe(({
      rtl
    }) => {
      this.direction = rtl ? "rtl" : "ltr";
      this.cdr.markForCheck();
    }));
    this.setComponentClasses();
  }
  ngAfterViewInit() {
    this.windowSize = this.adaptiveService.size;
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "click", this.handleClick.bind(this)));
    this.subs.add(this.renderer.listen(this.wrapper.nativeElement, "keydown", this.handleKeydown.bind(this)));
  }
  /**
   * @hidden
   */
  ngOnDestroy() {
    this.destroyPopup();
    this.unsubscribeEvents();
  }
  /**
   * @hidden
   */
  ngOnChanges(changes) {
    if (anyChanged(["textField", "valueField", "valuePrimitive"], changes, false)) {
      this.isHeterogeneous = this.valueField && isArray2(this.valueField);
      this.setState();
    }
    if (anyChanged(["valueDepth", "value", "dataItems"], changes, false)) {
      if (changes["value"] && !changes["dataItems"] && !this.valuePrimitive) {
        this.dataItems = this.value;
      } else {
        this.dataItems = this.dataItems.map((item, index) => __spreadProps(__spreadValues({}, item), {
          key: valueFrom({
            dataItem: item.dataItem,
            index: null,
            level: this.valueDepth[index] || 0
          }, this.valueField) + "_" + (this.isHeterogeneous ? this.valueDepth[index] : 0),
          level: this.valueDepth[index] || 0
        }));
      }
    }
    if (anyChanged(["data", "children", "hasChildren", "loadOnDemand", "valueField"], changes, true) && !this.loadOnDemand) {
      this.lookup.reset();
      this.registerLookupItems(this.data);
    }
  }
  /**
   * @hidden
   */
  ngAfterContentChecked() {
    this.verifySettings();
    if (this.data?.length > 0 && this.popupRef) {
      this.allNodesHidden = this.areNodesHidden(this.data);
    }
  }
  ngAfterContentInit() {
    this.isContentInit = true;
    this.registerLookupItems(this.data);
  }
  /**
   * @hidden
   *
   * Used by the kendo-floatinglabel component to determine if the floating label
   * should be rendered inside the input when the component is not focused.
   */
  isEmpty() {
    return !this.placeholder && (!isPresent5(this.value) || this.value.length === 0);
  }
  /**
   * Sets focus to the component.
   * Call this method to programmatically focus the MultiSelectTree.
   */
  focus() {
    if (!this.disabled) {
      this.wrapper.nativeElement.focus();
    }
  }
  /**
   * Removes focus from the component.
   * Call this method to programmatically blur the MultiSelectTree.
   */
  blur() {
    if (!this.disabled) {
      this.wrapper.nativeElement.blur();
    }
  }
  /**
   * Sets focus to a specific tree item by index.
   * Provide the item index in format like '1_1' to focus that item.
   * The item must be expanded and enabled to receive focus.
   */
  focusItemAt(index) {
    if (this.treeview) {
      const lookup = this.treeview.itemLookup(index);
      const isItemDisabled = !isPresent5(lookup) || this.treeview.isDisabled(lookup.item.dataItem, lookup.item.index);
      if (!isItemDisabled) {
        this.treeview.focus(index);
      }
    }
  }
  /**
   * Clears all selected values from the component.
   * This method does not trigger the valueChange event.
   */
  reset() {
    this.value = [];
    this.dataItems = [];
    this.valueDepth = [];
  }
  /**
   * Opens or closes the popup programmatically.
   * Pass `true` to open, false to close, or omit the parameter to toggle.
   * This method does not trigger open or close events.
   */
  toggle(open) {
    Promise.resolve(null).then(() => {
      const shouldOpen = isPresent5(open) ? open : !isPresent5(this.popupRef);
      this.destroyPopup();
      if (shouldOpen) {
        this.createPopup();
      }
    });
  }
  /**
   * @hidden
   */
  handleFocus(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    if (!this.isFocused) {
      this.isFocused = true;
      if (hasObservers(this.onFocus)) {
        this._zone.run(() => {
          this.onFocus.emit();
        });
      }
      if (this.isOpen && this.treeview) {
        if (this.lastNodeOnFocus) {
          this.lastNodeOnFocus.setAttribute("tabindex", "0");
        }
        this.treeview.focus();
      }
    }
  }
  /**
   * @hidden
   */
  handleBlur(e) {
    if (!this.isActionSheetExpanded) {
      const relatedTarget = e && e.relatedTarget;
      if (this.wrapper.nativeElement.contains(relatedTarget) || this.isOpen && this.popupRef.popupElement.contains(relatedTarget)) {
        return;
      }
      this.isFocused = false;
      this.togglePopup(false);
      this.cdr.markForCheck();
      if (hasObservers(this.onBlur) || isUntouched2(this.wrapper.nativeElement) || this.formControl?.updateOn === "blur") {
        this._zone.run(() => {
          this.onBlur.emit();
          this.onTouchedCallback();
        });
      }
    }
  }
  /**
   * @hidden
   */
  handleNodeClick(node) {
    if (!this.isFocused) {
      const parent = node.originalEvent.target.parentElement.parentElement;
      this.lastNodeOnFocus = parent;
      this.focus();
    }
  }
  /**
   * @hidden
   */
  togglePopup(open) {
    const isDisabled2 = this.disabled || this.readonly;
    const sameState = this.isOpen === open;
    this._zone.run(() => {
      this.focusedTagIndex = void 0;
    });
    if (isDisabled2 || sameState) {
      return;
    }
    const togglePrevented = this.triggerPopupEvents(open);
    if (!togglePrevented) {
      if (open) {
        this.createPopup();
      } else {
        this.destroyPopup();
      }
    } else {
      this.removeTreeViewFromTabOrder();
    }
  }
  /**
   * @hidden
   */
  messageFor(key) {
    return this.localization.get(key);
  }
  lastAction = "check";
  /**
   * @hidden
   */
  handleCheckedItemsChange(items) {
    this.valueDepth = items.map((item) => item.level);
    this.lastAction = items.length > this.dataItems.length ? "check" : "uncheck";
    this.dataItems = items.slice();
    this.updateValue(this.dataItems);
  }
  /**
   * @hidden
   */
  handleRemoveTag({
    tag,
    index
  }) {
    if (this.disabled || this.readonly) {
      return;
    }
    const eventArgs = new RemoveTagEvent(tag);
    this.removeTag.emit(eventArgs);
    if (eventArgs.isDefaultPrevented()) {
      return;
    }
    if (tag instanceof Array) {
      this.dataItems = this.dataItems.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));
      this.valueDepth = this.valueDepth.filter((_item, i) => i < this.showAfter || this.disabledIndices.has(i));
    } else if (this.loadOnDemand) {
      this.dataItems = this.dataItems.filter((_item, i) => i !== index || this.disabledIndices.has(i));
      this.valueDepth = this.valueDepth.filter((_item, i) => i !== index || this.disabledIndices.has(i));
    } else {
      const dataItem = this.dataItems.find((item) => item.tagPositionIndex === index);
      const itemKey = dataItem.key;
      const lookup = this.lookup.itemLookup(itemKey);
      const pendingCheck = [lookup.item];
      if (this.checkableSettings.checkChildren) {
        fetchDescendentNodes(lookup).forEach((lookup2) => pendingCheck.push(lookup2.item));
        pendingCheck.push(...this.removeParents(lookup.parent));
      }
      const keysToRemove = pendingCheck.map((item) => item.key);
      const valueDepthIndices = [];
      this.dataItems = this.dataItems.filter((_item, i) => {
        const shouldStay = !keysToRemove.includes(_item.key) || this.disabledIndices.has(i);
        if (!shouldStay) {
          valueDepthIndices.push(i);
        }
        return shouldStay;
      });
      this.valueDepth = this.valueDepth.filter((_item, i) => {
        return !valueDepthIndices.includes(i) || this.disabledIndices.has(i);
      });
    }
    this.updateValue(this.dataItems);
    if (!this.isFocused) {
      this.focus();
    }
  }
  /**
   * @hidden
   */
  handleTagMapperChange(showAfter) {
    this.showAfter = parseNumber(showAfter);
    this.setTags();
  }
  /**
   * @hidden
   */
  clearAll(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
    this.focus();
    this.value = this.value.filter((_item, index) => this.disabledIndices.has(index));
    this.dataItems = this.dataItems.filter((_item, index) => this.disabledIndices.has(index));
    this.valueDepth = this.valueDepth.filter((_depth, index) => this.disabledIndices.has(index));
    this.emitValueChange(this.value);
  }
  /**
   * @hidden
   */
  writeValue(value) {
    if (!this.valuePrimitive && isPresent5(value)) {
      this.dataItems = value;
    }
    if (!isPresent5(value) && isPresent5(this.value)) {
      this.dataItems = null;
    }
    this.value = value || [];
  }
  /**
   * @hidden
   */
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  /**
   * @hidden
   */
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  /**
   * @hidden
   */
  setDisabledState(isDisabled2) {
    this.disabled = isDisabled2;
    this.cdr.markForCheck();
  }
  /**
   * @hidden
   */
  handleFilterInputChange(input) {
    this.filter = input.value;
    this.filterChange.next(input.value);
  }
  /**
   * @hidden
   */
  get filterInputClasses() {
    return `${this.size ? getSizeClass2("input", this.size) : ""} ${this.fillMode ? "k-input-" + this.fillMode : ""} ${this.rounded ? getRoundedClass(this.rounded) : ""}`;
  }
  /**
   * @hidden
   */
  get checkAllCheckboxClasses() {
    return `${this.size ? getSizeClass2("checkbox", this.size) : ""}`;
  }
  /**
   * @hidden
   */
  toggleCheckAll() {
    this.checkAllInput.nativeElement.focus();
    this.checkAllInput.nativeElement.click();
  }
  onTouchedCallback = noop6;
  onChangeCallback = noop6;
  verifySettings() {
    if (!isDevMode()) {
      return;
    }
    if (!isPresent5(this.valueField) || !isPresent5(this.textField)) {
      throw new Error(MultiSelectTreeMessages.textAndValue);
    }
    if (!isArray2(this.value)) {
      throw new Error(MultiSelectTreeMessages.array);
    }
    if (this.value.length > 0) {
      if (this.valuePrimitive && this.value.some((item) => isObject(item))) {
        throw new Error(MultiSelectTreeMessages.primitive);
      }
      const isEveryDataItemObject = this.dataItems.every((item) => isObject(item.dataItem));
      if (this.valuePrimitive && !isArray2(this.dataItems)) {
        throw new Error(MultiSelectTreeMessages.dataItems);
      }
      if (this.valuePrimitive && !isEveryDataItemObject) {
        throw new Error(MultiSelectTreeMessages.dataItems);
      }
      if (this.valuePrimitive && this.dataItems.length !== this.value.length) {
        throw new Error(MultiSelectTreeMessages.dataItemsLength);
      }
      if (!this.valuePrimitive && !isObjectArray(this.value)) {
        throw new Error(MultiSelectTreeMessages.object);
      }
      if ((isArray2(this.valueField) || isArray2(this.textField)) && !isArray2(this.valueDepth)) {
        throw new Error(MultiSelectTreeMessages.valueDepth);
      }
      if ((isArray2(this.valueField) || isArray2(this.textField)) && this.valueDepth.length === 0) {
        throw new Error(MultiSelectTreeMessages.valueDepth);
      }
      if ((isArray2(this.valueField) || isArray2(this.textField)) && this.valueDepth.length !== this.value.length) {
        throw new Error(MultiSelectTreeMessages.valueDepthLength);
      }
    }
  }
  areNodesHidden(nodes) {
    return nodes.every((node, index) => !this.isVisible(node, String(index)));
  }
  emitValueChange(value) {
    this.onChangeCallback(value);
    this.valueChange.emit(value);
  }
  triggerPopupEvents(open) {
    const eventArgs = new PreventableEvent3();
    if (hasObservers(this.open) || hasObservers(this.close)) {
      this._zone.run(() => {
        if (open) {
          this.open.emit(eventArgs);
        } else {
          this.close.emit(eventArgs);
        }
      });
    }
    return eventArgs.isDefaultPrevented();
  }
  createPopup() {
    this.windowSize = this.adaptiveService.size;
    if (this.isAdaptive) {
      this.openActionSheet();
      this.cdr.detectChanges();
      return;
    }
    const horizontalAlign = this.direction === "rtl" ? "right" : "left";
    const anchorPosition = {
      horizontal: horizontalAlign,
      vertical: "bottom"
    };
    const popupPosition = {
      horizontal: horizontalAlign,
      vertical: "top"
    };
    const appendToComponent = typeof this.popupSettings.appendTo === "string" && this.popupSettings.appendTo === "component";
    this.popupRef = this.popupService.open({
      anchor: this.wrapper,
      appendTo: this.appendTo,
      anchorAlign: anchorPosition,
      animate: this.popupSettings.animate,
      content: this.popupTemplate,
      popupAlign: popupPosition,
      positionMode: appendToComponent ? "fixed" : "absolute",
      popupClass: this.popupContainerClasses
    });
    const popupWrapper = this.popupRef.popupElement;
    const {
      min,
      max
    } = this.width;
    if (!this.appendTo) {
      this.renderer.setAttribute(popupWrapper, "role", "region");
      this.renderer.setAttribute(popupWrapper, "aria-label", this.messageFor("popupLabel"));
    }
    popupWrapper.style.minWidth = min;
    popupWrapper.style.width = max;
    popupWrapper.style.height = this.height;
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.treeViewId);
    this.renderer.setAttribute(popupWrapper, "dir", this.direction);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.popupRef.popupOpen.subscribe(() => {
      this.cdr.detectChanges();
      this.opened.emit();
      this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
    });
    this.popupRef.popupClose.subscribe(() => {
      if (hasObservers(this.closed)) {
        this._zone.run(() => {
          this.closed.emit();
        });
      }
    });
  }
  destroyPopup() {
    if (this.isActionSheetExpanded) {
      this.closeActionSheet();
    }
    if (this.popupRef) {
      this.popupRef.close();
      this.popupRef = null;
      this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
      this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
      this.clearFilter();
    }
  }
  clearFilter() {
    if (this.filter !== "") {
      this.filter = "";
      this.allNodesHidden = false;
      if (hasObservers(this.filterChange)) {
        this._zone.run(() => {
          this.filterChange.emit("");
        });
      }
    }
  }
  handleClick(e) {
    if (this.popupRef && this.popupRef.popupElement.contains(e.target) || this.isActionSheetExpanded) {
      return;
    }
    this.togglePopup(!this.isOpen);
  }
  subscribeEvents() {
    [this.navigationService.open.subscribe((event) => {
      event.originalEvent.preventDefault();
      this.togglePopup(true);
    }), this.navigationService.enter.pipe(tap((event) => event.originalEvent.preventDefault())).subscribe(() => this.togglePopup(true)), merge(this.navigationService.close, this.navigationService.esc).subscribe((event) => {
      event.originalEvent.preventDefault();
      this.focus();
      this.togglePopup(false);
    }), this.navigationService.tab.subscribe(this.handleTabKey.bind(this)), this.navigationService.up.subscribe(this.handleUpKey.bind(this)), this.navigationService.down.subscribe(this.handleDownKey.bind(this)), this.navigationService.left.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === "rtl" ? this.handleRightKey.bind(this) : this.handleLeftKey.bind(this)), this.navigationService.right.pipe(filter(() => !this.isTreeViewActive)).subscribe(this.direction === "rtl" ? this.handleLeftKey.bind(this) : this.handleRightKey.bind(this)), this.navigationService.home.pipe(filter(() => !this.isOpen)).subscribe(this.handleHome.bind(this)), this.navigationService.end.pipe(filter(() => !this.isOpen)).subscribe(this.handleEnd.bind(this)), this.navigationService.backspace.pipe(filter(() => this.isTagFocused)).subscribe(this.handleBackspace.bind(this)), this.navigationService.delete.pipe(filter(() => this.isTagFocused)).subscribe(this.handleDelete.bind(this))].forEach((sub) => this.subs.add(sub));
  }
  subscribeFocusEvents() {
    if (isDocumentAvailable()) {
      this.handleFocus = this.handleFocus.bind(this);
      this.handleDocumentBlur = this.handleDocumentBlur.bind(this);
      this._zone.runOutsideAngular(() => {
        const useCapture = true;
        document.addEventListener("focus", this.handleFocus, useCapture);
        document.addEventListener("blur", this.handleDocumentBlur, useCapture);
      });
    }
  }
  unSubscribeFocusEvents() {
    if (isDocumentAvailable()) {
      const useCapture = true;
      document.removeEventListener("focus", this.handleFocus, useCapture);
      document.removeEventListener("blur", this.handleDocumentBlur, useCapture);
    }
  }
  handleDocumentBlur(event) {
    if (event.target !== this.wrapper.nativeElement) {
      return;
    }
    event.stopImmediatePropagation();
    this.handleBlur(event);
  }
  handleTabKey() {
    if (!this.isActionSheetExpanded) {
      this.focus();
    }
    if (this.isOpen) {
      this.treeview.blur();
      this.removeTreeViewFromTabOrder();
    }
  }
  handleUpKey(event) {
    if (!this.treeview) {
      return;
    }
    event.originalEvent.preventDefault();
    if (this.isWrapperActive) {
      return;
    }
    const isFirstNodeActive = this.treeview["navigationService"]["activeIndex"] === "0";
    if (this.filterable && this.isFilterActive) {
      this.focus();
    } else if (this.checkAll && !this.isCheckAllActive && isFirstNodeActive) {
      this.checkAllInput.nativeElement.focus();
    } else if (this.isCheckAllActive || isFirstNodeActive) {
      if (this.filterable) {
        this.isActionSheetExpanded ? this.actionSheetSearchBar.focus() : this.filterInput.nativeElement.focus();
      } else if (!this.isActionSheetExpanded) {
        this.focus();
      }
    }
  }
  handleDownKey(event) {
    if (!this.treeview) {
      return;
    }
    event.originalEvent.preventDefault();
    if (this.filterable && this.isWrapperActive) {
      this.filterInput.nativeElement.focus();
    } else if (this.checkAll && (this.isWrapperActive || this.isFilterActive)) {
      this.checkAllInput.nativeElement.focus();
    } else if (!this.treeview.isActive) {
      this.treeview.focus();
    }
    this.focusedTagIndex = void 0;
  }
  handleRightKey(event) {
    event.originalEvent.preventDefault();
    const last = this.tags.length - 1;
    if (this.focusedTagIndex === last) {
      this.focusedTagIndex = void 0;
    } else if (this.focusedTagIndex < last) {
      this.focusedTagIndex++;
    } else if (!this.focusedTagIndex) {
      this.focusedTagIndex = 0;
    }
  }
  handleLeftKey(event) {
    event.originalEvent.preventDefault();
    if (this.focusedTagIndex === void 0 || this.focusedTagIndex < 0) {
      this.focusedTagIndex = this.tags.length - 1;
    } else if (this.focusedTagIndex !== 0) {
      this.focusedTagIndex--;
    }
  }
  handleEnd(event) {
    event.originalEvent.preventDefault();
    this.focusedTagIndex = this.tags.length - 1;
  }
  handleHome(event) {
    event.originalEvent.preventDefault();
    this.focusedTagIndex = 0;
  }
  handleBackspace() {
    if (this.focusedTagIndex !== void 0) {
      this.handleDelete();
    } else {
      const tag = this.tags[this.tags.length - 1];
      const index = this.tags.length - 1;
      this.handleRemoveTag({
        tag,
        index
      });
    }
  }
  handleDelete() {
    const tag = this.tags[this.focusedTagIndex];
    const index = this.focusedTagIndex;
    this.handleRemoveTag({
      tag,
      index
    });
    if (this.focusedTagIndex === this.tags.length) {
      this.focusedTagIndex = void 0;
    }
  }
  unsubscribeEvents() {
    this.subs.unsubscribe();
    this.unSubscribeFocusEvents();
  }
  /**
   * Remove the `TreeView` from the tab order, otherwise a focus loop between the page elements will occur
   * and the user will not be able to tab to the rest of the browser elements
   */
  removeTreeViewFromTabOrder() {
    const nodes = this.treeview.element.nativeElement.querySelectorAll("li");
    nodes.forEach((item) => {
      if (item.getAttribute("tabindex") === "0") {
        this.lastNodeOnFocus = item;
        this.lastNodeOnFocus.setAttribute("tabindex", "-1");
      }
    });
  }
  setState() {
    if (isPresent5(this.dataItems) && isPresent5(this.valueField)) {
      this.setTags();
      this.checkedItems = this.dataItems.slice();
    }
    this.cdr.markForCheck();
  }
  setTags() {
    const source = this.dataItems.map((item) => item.dataItem);
    this.tags = this.tagMapper(source);
    this.disabledIndices = this.disabledItemsMapper();
    const tagIndexMap = new Map(this.tags.map((tag, index) => [JSON.stringify(tag), index]));
    this.dataItems.forEach((item) => {
      const serializedDataItem = JSON.stringify(item.dataItem);
      item.tagPositionIndex = tagIndexMap.has(serializedDataItem) ? tagIndexMap.get(serializedDataItem) : null;
    });
  }
  updateValue(value) {
    const newValue = this.valuePrimitive ? value.map((item) => valueFrom(item, this.valueField)) : value.map((item) => item.dataItem);
    this.value = newValue;
    this.emitValueChange(this.value);
  }
  /**
   * @hidden
   */
  onChildrenLoaded() {
    setTimeout(() => {
      if (this.popupRef) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.popupRef.popupElement);
      }
      if (this.isActionSheetExpanded) {
        this._searchableNodes = getSearchableItems(this.treeViewId, this.actionSheet.element.nativeElement);
      }
    });
  }
  /**
   * @hidden
   *
   * Determines which of the provided tags should be disabled and stores their position indices
   */
  disabledItemsMapper() {
    return new Set(this.dataItems.reduce((indices, item, index) => {
      if (this.itemDisabled(item.dataItem, item.index)) {
        indices.push(index);
      }
      return indices;
    }, []));
  }
  setComponentClasses() {
    if (this.size !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getSizeClass2("input", this.size));
    }
    if (this.rounded !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
    }
    if (this.fillMode !== "none") {
      this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass("input", this.fillMode));
    }
  }
  removeParents(parent) {
    let currentParent = parent;
    const nodes = [];
    while (currentParent) {
      nodes.push(currentParent.item);
      currentParent = currentParent.parent;
    }
    return nodes;
  }
  /**
   * Creates an internal map of the available tree items to be used as a reference
   * to retrieve the item's children/parent and determine the checked sate
   */
  registerLookupItems(data, parentItem = null, levelIndex = 0) {
    if (!isPresent5(data) || data.length === 0) {
      return;
    }
    const parentIndex = nodeIndex2(parentItem);
    const treeItems = data.map((node) => buildTreeItem2(node, this.valueField, levelIndex));
    if (isPresent5(parentItem)) {
      this.lookup.registerChildren(parentIndex, treeItems);
    }
    treeItems.forEach((item) => {
      this.lookup.registerItem(item, parentItem);
      if (!this.loadOnDemand) {
        this.registerChildLookupItems(item, levelIndex);
      }
    });
  }
  registerChildLookupItems(item, levelIndex) {
    if (this.hasChildren(item.dataItem)) {
      this.children(item.dataItem).subscribe((children) => {
        const index = this.isHeterogeneous ? levelIndex + 1 : 0;
        this.registerLookupItems(children, item, index);
      });
    }
  }
  closeActionSheet() {
    this.wrapper.nativeElement.focus();
    this.actionSheet.toggle(false);
    this.renderer.removeAttribute(this.wrapper.nativeElement, "aria-controls");
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "false");
    this.clearFilter();
    this.closed.emit();
  }
  openActionSheet() {
    this.actionSheet.toggle(true);
    this.adaptiveTitle = setActionSheetTitle(this.wrapper, this.adaptiveTitle);
    this.cdr.detectChanges();
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-controls", this.treeViewId);
    this.renderer.setAttribute(this.wrapper.nativeElement, "aria-expanded", "true");
    this.cdr.detectChanges();
    this.opened.emit();
  }
  static ɵfac = function MultiSelectTreeComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeComponent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PopupService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NavigationService2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(LocalizationService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MultiSelectTreeLookupService), ɵɵdirectiveInject(AdaptiveService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _MultiSelectTreeComponent,
    selectors: [["kendo-multiselecttree"]],
    contentQueries: function MultiSelectTreeComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, HeaderTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, FooterTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, NodeTemplateDirective2, 5);
        ɵɵcontentQuery(dirIndex, NoDataTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, TagTemplateDirective, 5);
        ɵɵcontentQuery(dirIndex, GroupTagTemplateDirective, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.footerTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.noDataTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tagTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupTagTemplate = _t.first);
      }
    },
    viewQuery: function MultiSelectTreeComponent_Query(rf, ctx) {
      if (rf & 1) {
        ɵɵviewQuery(AdaptiveRendererComponent2, 5);
        ɵɵviewQuery(_c132, 7);
        ɵɵviewQuery(_c122, 7, ViewContainerRef);
        ɵɵviewQuery(_c262, 5);
        ɵɵviewQuery(_c272, 5);
        ɵɵviewQuery(_c292, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.adaptiveRendererComponent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.popupTemplate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.container = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeview = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkAllInput = _t.first);
      }
    },
    hostVars: 22,
    hostBindings: function MultiSelectTreeComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx.isDisabled)("aria-autocomplete", ctx.hostAriaAutocomplete)("aria-invalid", ctx.hostAriaInvalid)("aria-busy", ctx.isBusy)("id", ctx.id)("dir", ctx.direction)("tabindex", ctx.hostTabIndex)("role", ctx.role)("aria-haspopup", ctx.ariaHasPopup)("readonly", ctx.isReadonly)("aria-describedby", ctx.ariaDescribedBy)("aria-activedescendant", ctx.ariaActiveDescendant);
        ɵɵclassProp("k-multiselecttree", ctx.hostClasses)("k-input", ctx.hostClasses)("k-disabled", ctx.isDisabled)("k-loading", ctx.isLoading)("k-readonly", ctx.readonly);
      }
    },
    inputs: {
      adaptiveMode: "adaptiveMode",
      adaptiveTitle: "adaptiveTitle",
      adaptiveSubtitle: "adaptiveSubtitle",
      tabindex: "tabindex",
      size: "size",
      rounded: "rounded",
      fillMode: "fillMode",
      popupSettings: "popupSettings",
      checkableSettings: "checkableSettings",
      data: "data",
      value: "value",
      dataItems: "dataItems",
      textField: "textField",
      valueField: "valueField",
      valueDepth: "valueDepth",
      loading: "loading",
      placeholder: "placeholder",
      listHeight: "listHeight",
      disabled: "disabled",
      readonly: "readonly",
      valuePrimitive: "valuePrimitive",
      loadOnDemand: "loadOnDemand",
      focusableId: "focusableId",
      clearButton: "clearButton",
      filterable: "filterable",
      checkAll: "checkAll",
      hasChildren: "hasChildren",
      fetchChildren: "fetchChildren",
      isNodeExpanded: "isNodeExpanded",
      isNodeVisible: "isNodeVisible",
      itemDisabled: "itemDisabled",
      tagMapper: "tagMapper"
    },
    outputs: {
      onFocus: "focus",
      onBlur: "blur",
      open: "open",
      opened: "opened",
      close: "close",
      closed: "closed",
      nodeExpand: "nodeExpand",
      nodeCollapse: "nodeCollapse",
      valueChange: "valueChange",
      removeTag: "removeTag",
      filterChange: "filterChange"
    },
    exportAs: ["kendoMultiSelectTree"],
    standalone: true,
    features: [ɵɵProvidersFeature([LocalizationService, NavigationService2, DataService, DisabledItemsService, SelectionService2, MultiSelectTreeLookupService, {
      provide: L10N_PREFIX,
      useValue: "kendo.multiselecttree"
    }, {
      multi: true,
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: DataBoundComponent,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: ExpandableComponent,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }, {
      provide: KendoInput,
      useExisting: forwardRef(() => _MultiSelectTreeComponent)
    }]), ɵɵNgOnChangesFeature, ɵɵStandaloneFeature],
    decls: 14,
    vars: 25,
    consts: () => {
      let i18n_30;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30 = goog.getMsg("NO DATA FOUND");
        i18n_30 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_30;
      } else {
        i18n_30 = $localize`:kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items:NO DATA FOUND`;
      }
      let i18n_31;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_31 = goog.getMsg("clear");
        i18n_31 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_31;
      } else {
        i18n_31 = $localize`:kendo.multiselecttree.clearTitle|The title of the clear button:clear`;
      }
      let i18n_32;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_32 = goog.getMsg("Check all");
        i18n_32 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_32;
      } else {
        i18n_32 = $localize`:kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox:Check all`;
      }
      let i18n_33;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_33 = goog.getMsg("Filter");
        i18n_33 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_33;
      } else {
        i18n_33 = $localize`:kendo.multiselecttree.filterInputLabel|The text set as aria-label on the filter input:Filter`;
      }
      let i18n_34;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_34 = goog.getMsg("Options list");
        i18n_34 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_34;
      } else {
        i18n_34 = $localize`:kendo.multiselecttree.popupLabel|The label of the popup element that contains the list of options when its role is 'region':Options list`;
      }
      let i18n_35;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_35 = goog.getMsg("Close");
        i18n_35 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_35;
      } else {
        i18n_35 = $localize`:kendo.multiselecttree.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode:Close`;
      }
      let i18n_36;
      if (typeof ngI18nClosureMode !== "undefined" && ngI18nClosureMode) {
        const MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_36 = goog.getMsg("Filter");
        i18n_36 = MSG__HOME_ABDUL_PERSONAL_PORTFOLIO_TRACKER_UI_FRONTED_NODE_MODULES__PROGRESS_KENDO_ANGULAR_DROPDOWNS_FESM2022_PROGRESS_KENDO_ANGULAR_DROPDOWNS_MJS_36;
      } else {
        i18n_36 = $localize`:kendo.multiselecttree.filterInputPlaceholder|The text for the input's placeholder when filtering is enabled:Filter`;
      }
      return [["popupTemplate", ""], ["container", ""], ["sharedPopupActionSheetTemplate", ""], ["treeview", ""], ["filterInput", ""], ["checkAllInput", ""], ["kendoMultiSelectTreeLocalizedMessages", "", "noDataText", i18n_30, "clearTitle", i18n_31, "checkAllText", i18n_32, "filterInputLabel", i18n_33, "popupLabel", i18n_34, "adaptiveCloseButtonTitle", i18n_35, "filterInputPlaceholder", i18n_36], [1, "k-input-values", 3, "removeTag", "size", "rounded", "fillMode", "id", "tags", "focused", "textField", "valueField", "valueDepth", "disabled", "tagPrefix", "template", "groupTemplate", "disabledIndices"], [1, "k-input-inner"], ["class", "k-input-value-text", 4, "ngIf"], ["class", "k-clear-value", "role", "button", "tabindex", "-1", 3, "click", 4, "ngIf"], ["class", "k-icon k-i-loading k-input-loading-icon", 4, "ngIf"], [3, "closePopup", "textInputChange", "sharedPopupActionSheetTemplate", "title", "showTextInput", "subtitle", "searchBarValue", "placeholder", "filterable"], [3, "resize", 4, "ngIf"], [1, "k-input-value-text"], ["role", "button", "tabindex", "-1", 1, "k-clear-value", 3, "click"], ["name", "x", 1, "k-icon", 3, "svgIcon"], [1, "k-icon", "k-i-loading", "k-input-loading-icon"], [4, "ngTemplateOutlet"], ["class", "k-list-filter", 4, "ngIf"], [4, "ngIf"], ["class", "k-check-all", 4, "ngIf"], ["kendoMultiSelectTreeCheckable", "", 3, "keydown", "nodeClick", "expand", "collapse", "checkedItemsChange", "childrenLoaded", "size", "nodes", "animate", "isHeterogeneous", "checkable", "checkedItems", "valueField", "textField", "children", "hasChildren", "isExpanded", "isDisabled", "nodeTemplate", "loadOnDemand", "filter", "isVisible", "kendoEventsOutsideAngular", "scope"], ["class", "k-no-data", 4, "ngIf"], [1, "k-list-filter"], [1, "k-textbox", "k-input", 3, "ngClass"], [1, "k-input-prefix"], ["name", "search", 1, "k-icon", 3, "svgIcon"], ["role", "searchbox", "tabindex", "0", "aria-disabled", "false", "aria-readonly", "false", 1, "k-input-inner", 3, "input", "keydown", "filterInput", "value", "kendoEventsOutsideAngular", "scope"], [3, "templateContext"], [1, "k-check-all"], [1, "k-checkbox-wrap"], ["type", "checkbox", "role", "checkbox", "tabindex", "0", "aria-disabled", "false", "aria-readonly", "false", 1, "k-checkbox", 3, "checkedItemsChange", "keydown", "checkAll", "ngClass", "treeview", "checkedItems", "valueField", "lastAction", "kendoEventsOutsideAngular", "scope"], [1, "k-checkbox-label", 3, "click", "mousedown"], [1, "k-no-data"], [3, "ngIf", "templateContext"], [3, "ngIf"], [3, "resize"]];
    },
    template: function MultiSelectTreeComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementContainer(0, 6);
        ɵɵelementStart(1, "kendo-taglist", 7);
        ɵɵlistener("removeTag", function MultiSelectTreeComponent_Template_kendo_taglist_removeTag_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.handleRemoveTag($event));
        });
        ɵɵelementEnd();
        ɵɵelementStart(2, "span", 8);
        ɵɵtemplate(3, MultiSelectTreeComponent_span_3_Template, 2, 1, "span", 9);
        ɵɵelementEnd();
        ɵɵtemplate(4, MultiSelectTreeComponent_span_4_Template, 2, 2, "span", 10)(5, MultiSelectTreeComponent_span_5_Template, 1, 0, "span", 11)(6, MultiSelectTreeComponent_ng_template_6_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementContainer(8, null, 1);
        ɵɵelementStart(10, "kendo-adaptive-renderer", 12);
        ɵɵlistener("closePopup", function MultiSelectTreeComponent_Template_kendo_adaptive_renderer_closePopup_10_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.togglePopup(false));
        })("textInputChange", function MultiSelectTreeComponent_Template_kendo_adaptive_renderer_textInputChange_10_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx.onFilterChange($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(11, MultiSelectTreeComponent_ng_template_11_Template, 7, 28, "ng-template", null, 2, ɵɵtemplateRefExtractor)(13, MultiSelectTreeComponent_kendo_resize_sensor_13_Template, 1, 0, "kendo-resize-sensor", 13);
      }
      if (rf & 2) {
        const sharedPopupActionSheetTemplate_r4 = ɵɵreference(12);
        ɵɵadvance();
        ɵɵproperty("size", ctx.size)("rounded", ctx.rounded)("fillMode", ctx.fillMode)("id", ctx.tagListId)("tags", ctx.tags)("focused", ctx.focusedTagIndex)("textField", ctx.textField)("valueField", ctx.valueField)("valueDepth", ctx.valueDepth)("disabled", ctx.disabled)("tagPrefix", ctx.tagPrefix)("template", ctx.tagTemplate)("groupTemplate", ctx.groupTagTemplate)("disabledIndices", ctx.disabledIndices);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", !ctx.tags || !ctx.tags.length);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx.disabled && !ctx.loading && !ctx.readonly && ctx.clearButton && (ctx.tags == null ? null : ctx.tags.length));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx.loading);
        ɵɵadvance(5);
        ɵɵproperty("sharedPopupActionSheetTemplate", sharedPopupActionSheetTemplate_r4)("title", ctx.adaptiveTitle)("showTextInput", ctx.filterable)("subtitle", ctx.adaptiveSubtitle)("searchBarValue", ctx.filter)("placeholder", ctx.placeholder)("filterable", ctx.filterable);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx.isOpen || ctx.isAdaptiveModeEnabled);
      }
    },
    dependencies: [LocalizedMessagesDirective2, TagListComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, AdaptiveRendererComponent2, NgClass, FilterInputDirective, EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, TreeViewComponent, CheckDirective2, ResizeSensorComponent],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeComponent, [{
    type: Component,
    args: [{
      exportAs: "kendoMultiSelectTree",
      providers: [LocalizationService, NavigationService2, DataService, DisabledItemsService, SelectionService2, MultiSelectTreeLookupService, {
        provide: L10N_PREFIX,
        useValue: "kendo.multiselecttree"
      }, {
        multi: true,
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: DataBoundComponent,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: ExpandableComponent,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }, {
        provide: KendoInput,
        useExisting: forwardRef(() => MultiSelectTreeComponent)
      }],
      selector: "kendo-multiselecttree",
      template: `
        <ng-container kendoMultiSelectTreeLocalizedMessages
            i18n-noDataText="kendo.multiselecttree.noDataText|The text displayed in the popup when there are no items"
            noDataText="NO DATA FOUND"

            i18n-clearTitle="kendo.multiselecttree.clearTitle|The title of the clear button"
            clearTitle="clear"

            i18n-checkAllText="kendo.multiselecttree.checkAllText|The text displayed for the check-all checkbox"
            checkAllText="Check all"

            i18n-filterInputLabel="kendo.multiselecttree.filterInputLabel|The text set as aria-label on the filter input"
            filterInputLabel="Filter"

            i18n-popupLabel="kendo.multiselecttree.popupLabel|The label of the popup element that contains the list of options when its role is 'region'"
            popupLabel="Options list"

            i18n-adaptiveCloseButtonTitle="kendo.multiselecttree.adaptiveCloseButtonTitle|The title of the Close button of the ActionSheet that is rendered instead of the Popup when using small screen devices in adaptive mode"
            adaptiveCloseButtonTitle="Close"

            i18n-filterInputPlaceholder="kendo.multiselecttree.filterInputPlaceholder|The text for the input's placeholder when filtering is enabled"
            filterInputPlaceholder="Filter"
        >
        </ng-container>
        <kendo-taglist
            class="k-input-values"
            [size]="size"
            [rounded]="rounded"
            [fillMode]="fillMode"
            [id]="tagListId"
            [tags]="tags"
            [focused]="focusedTagIndex"
            [textField]="textField"
            [valueField]="valueField"
            [valueDepth]="valueDepth"
            [disabled]="disabled"
            [tagPrefix]="tagPrefix"
            [template]="tagTemplate"
            [groupTemplate]="groupTagTemplate"
            [disabledIndices]="disabledIndices"
            (removeTag)="handleRemoveTag($event)"
        >
        </kendo-taglist>
        <span class="k-input-inner">
            <span
                *ngIf="!tags || !tags.length"
                class="k-input-value-text"
            >
                {{ placeholder }}
            </span>
        </span>
        <span
            *ngIf="!disabled && !loading && !readonly && clearButton && tags?.length"
            class="k-clear-value"
            [attr.title]="messageFor('clearTitle')"
            role="button"
            tabindex="-1"
            (click)="clearAll($event)"
        >
            <kendo-icon-wrapper
                class="k-icon"
                name="x"
                [svgIcon]="xIcon"
            >
            </kendo-icon-wrapper>
        </span>
        <span
            *ngIf="loading"
            class="k-icon k-i-loading k-input-loading-icon"
        >
        </span>
        <ng-template #popupTemplate>
            <ng-container *ngTemplateOutlet="sharedPopupActionSheetTemplate"></ng-container>
        </ng-template>
        <ng-container #container></ng-container>

        <kendo-adaptive-renderer
            [sharedPopupActionSheetTemplate]="sharedPopupActionSheetTemplate"
            [title]="adaptiveTitle"
            [showTextInput]="filterable"
            [subtitle]="adaptiveSubtitle"
            (closePopup)="togglePopup(false)"
            (textInputChange)="onFilterChange($event)"
            [searchBarValue]="filter"
            [placeholder]="placeholder"
            [filterable]="filterable">
        </kendo-adaptive-renderer>

        <ng-template #sharedPopupActionSheetTemplate>
            <div
                *ngIf="filterable && !isActionSheetExpanded"
                class="k-list-filter"
                >
                <span
                    class="k-textbox k-input"
                    [ngClass]="filterInputClasses"
                >
                    <span class="k-input-prefix">
                        <kendo-icon-wrapper
                            class="k-icon"
                            name="search"
                            [svgIcon]="searchIcon"
                        >
                        </kendo-icon-wrapper>
                    </span>
                    <input
                        #filterInput
                        (input)="handleFilterInputChange($event.target)"
                        [filterInput]="filterable && !touchEnabled"
                        [attr.aria-label]="messageFor('filterInputLabel')"
                        (keydown)="handleKeydown($event, filterInput)"
                        [value]="filter"
                        class="k-input-inner"
                        role="searchbox"
                        tabindex="0"
                        aria-disabled="false"
                        aria-readonly="false"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
            </div>
            <!--header template-->
            <ng-template
                *ngIf="headerTemplate"
                [templateContext]="{
                    templateRef: headerTemplate?.templateRef
                }">
            </ng-template>
            <div *ngIf="checkAll" class="k-check-all">
                <span class="k-checkbox-wrap">
                    <input
                        #checkAllInput
                        [checkAll]="!filterable && !touchEnabled"
                        type="checkbox"
                        class="k-checkbox"
                        [ngClass]="checkAllCheckboxClasses"
                        role="checkbox"
                        tabindex="0"
                        aria-disabled="false"
                        aria-readonly="false"
                        [treeview]="treeview"
                        [checkedItems]="checkedItems"
                        [valueField]="valueField"
                        [lastAction]="lastAction"
                        (checkedItemsChange)="handleCheckedItemsChange($event)"
                        (keydown)="handleKeydown($event)"
                        [kendoEventsOutsideAngular]="{
                            blur: handleBlur
                        }"
                        [scope]="this"
                    >
                </span>
                <span
                    class="k-checkbox-label"
                    (click)="toggleCheckAll()"
                    (mousedown)="$event.preventDefault()"
                >
                    {{ messageFor('checkAllText') }}
                </span>
            </div>
            <kendo-treeview
                #treeview
                [size]="windowSize !== 'large' ? 'large' : size"
                [attr.id]="treeViewId"
                [nodes]="data"
                [style.maxHeight.px]="listHeight"
                [animate]="false"
                kendoMultiSelectTreeCheckable
                [isHeterogeneous]="isHeterogeneous"
                [checkable]="checkableSettings"
                [checkedItems]="checkedItems"
                [valueField]="valueField"
                [textField]="textField"
                [children]="children"
                [hasChildren]="hasChildren"
                [isExpanded]="isNodeExpanded"
                [isDisabled]="itemDisabled"
                [nodeTemplate]="nodeTemplate"
                [loadOnDemand]="loadOnDemand"
                [filter]="filter"
                [isVisible]="isNodeVisible"
                (keydown)="handleKeydown($event)"
                (nodeClick)="handleNodeClick($event)"
                (expand)="nodeExpand.emit($event)"
                (collapse)="nodeCollapse.emit($event)"
                (checkedItemsChange)="handleCheckedItemsChange($event)"
                [kendoEventsOutsideAngular]="{
                    focusout: handleBlur
                }"
                [scope]="this"
                (childrenLoaded)="onChildrenLoaded()"
            >
            </kendo-treeview>
            <!--footer template-->
            <ng-template
                *ngIf="footerTemplate"
                [templateContext]="{
                    templateRef: footerTemplate?.templateRef
                }">
            </ng-template>
            <!--no-data template-->
            <div class="k-no-data" *ngIf="!data || data?.length === 0 || allNodesHidden">
                <ng-template [ngIf]="noDataTemplate"
                    [templateContext]="{
                        templateRef: noDataTemplate?.templateRef
                    }">
                </ng-template>
                <ng-template [ngIf]="!noDataTemplate">
                    <div>{{ messageFor('noDataText') }}</div>
                </ng-template>
            </div>
        </ng-template>

        <kendo-resize-sensor *ngIf="isOpen || isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
    `,
      standalone: true,
      imports: [LocalizedMessagesDirective2, TagListComponent, NgIf, IconWrapperComponent, NgTemplateOutlet, AdaptiveRendererComponent2, NgClass, FilterInputDirective, EventsOutsideAngularDirective, TemplateContextDirective, CheckAllDirective, TreeViewComponent, CheckDirective2, ResizeSensorComponent]
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: PopupService
    }, {
      type: Renderer2
    }, {
      type: NavigationService2
    }, {
      type: NgZone
    }, {
      type: LocalizationService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MultiSelectTreeLookupService
    }, {
      type: AdaptiveService
    }];
  }, {
    hostClasses: [{
      type: HostBinding,
      args: ["class.k-multiselecttree"]
    }, {
      type: HostBinding,
      args: ["class.k-input"]
    }],
    isDisabled: [{
      type: HostBinding,
      args: ["class.k-disabled"]
    }, {
      type: HostBinding,
      args: ["attr.aria-disabled"]
    }],
    hostAriaAutocomplete: [{
      type: HostBinding,
      args: ["attr.aria-autocomplete"]
    }],
    isLoading: [{
      type: HostBinding,
      args: ["class.k-loading"]
    }],
    hostAriaInvalid: [{
      type: HostBinding,
      args: ["attr.aria-invalid"]
    }],
    isBusy: [{
      type: HostBinding,
      args: ["attr.aria-busy"]
    }],
    id: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    direction: [{
      type: HostBinding,
      args: ["attr.dir"]
    }],
    hostTabIndex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    role: [{
      type: HostBinding,
      args: ["attr.role"]
    }],
    ariaHasPopup: [{
      type: HostBinding,
      args: ["attr.aria-haspopup"]
    }],
    isReadonly: [{
      type: HostBinding,
      args: ["attr.readonly"]
    }],
    ariaDescribedBy: [{
      type: HostBinding,
      args: ["attr.aria-describedby"]
    }],
    ariaActiveDescendant: [{
      type: HostBinding,
      args: ["attr.aria-activedescendant"]
    }],
    adaptiveMode: [{
      type: Input
    }],
    adaptiveTitle: [{
      type: Input
    }],
    adaptiveSubtitle: [{
      type: Input
    }],
    adaptiveRendererComponent: [{
      type: ViewChild,
      args: [AdaptiveRendererComponent2]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: [HeaderTemplateDirective, {
        static: false
      }]
    }],
    footerTemplate: [{
      type: ContentChild,
      args: [FooterTemplateDirective, {
        static: false
      }]
    }],
    nodeTemplate: [{
      type: ContentChild,
      args: [NodeTemplateDirective2, {
        static: false
      }]
    }],
    noDataTemplate: [{
      type: ContentChild,
      args: [NoDataTemplateDirective, {
        static: false
      }]
    }],
    tagTemplate: [{
      type: ContentChild,
      args: [TagTemplateDirective, {
        static: false
      }]
    }],
    groupTagTemplate: [{
      type: ContentChild,
      args: [GroupTagTemplateDirective, {
        static: false
      }]
    }],
    popupTemplate: [{
      type: ViewChild,
      args: ["popupTemplate", {
        static: true
      }]
    }],
    container: [{
      type: ViewChild,
      args: ["container", {
        read: ViewContainerRef,
        static: true
      }]
    }],
    treeview: [{
      type: ViewChild,
      args: ["treeview", {
        static: false
      }]
    }],
    filterInput: [{
      type: ViewChild,
      args: ["filterInput", {
        static: false
      }]
    }],
    checkAllInput: [{
      type: ViewChild,
      args: ["checkAllInput", {
        static: false
      }]
    }],
    tabindex: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    rounded: [{
      type: Input
    }],
    fillMode: [{
      type: Input
    }],
    popupSettings: [{
      type: Input
    }],
    checkableSettings: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    dataItems: [{
      type: Input
    }],
    textField: [{
      type: Input
    }],
    valueField: [{
      type: Input
    }],
    valueDepth: [{
      type: Input
    }],
    loading: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    listHeight: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["class.k-readonly"]
    }],
    valuePrimitive: [{
      type: Input
    }],
    loadOnDemand: [{
      type: Input
    }],
    focusableId: [{
      type: Input
    }],
    clearButton: [{
      type: Input
    }],
    filterable: [{
      type: Input
    }],
    checkAll: [{
      type: Input
    }],
    hasChildren: [{
      type: Input
    }],
    fetchChildren: [{
      type: Input
    }],
    isNodeExpanded: [{
      type: Input
    }],
    isNodeVisible: [{
      type: Input
    }],
    itemDisabled: [{
      type: Input
    }],
    tagMapper: [{
      type: Input
    }],
    onFocus: [{
      type: Output,
      args: ["focus"]
    }],
    onBlur: [{
      type: Output,
      args: ["blur"]
    }],
    open: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    close: [{
      type: Output
    }],
    closed: [{
      type: Output
    }],
    nodeExpand: [{
      type: Output
    }],
    nodeCollapse: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    removeTag: [{
      type: Output
    }],
    filterChange: [{
      type: Output
    }]
  });
})();
var DropDownTreeFlatBindingDirective = class _DropDownTreeFlatBindingDirective extends FlatDataBindingDirective {
  dropDownTree;
  /**
   * Sets the nodes to display in the DropDownTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * Sets the unique field that identifies a node.
   */
  idField;
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.dropDownTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function DropDownTreeFlatBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeFlatBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreeFlatBindingDirective,
    selectors: [["", "kendoDropDownTreeFlatBinding", ""]],
    inputs: {
      nodes: [0, "kendoDropDownTreeFlatBinding", "nodes"],
      idField: [0, "valueField", "idField"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeFlatBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeFlatBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoDropDownTreeFlatBinding"]
    }],
    idField: [{
      type: Input,
      args: ["valueField"]
    }]
  });
})();
var DropDownTreeHierarchyBindingDirective = class _DropDownTreeHierarchyBindingDirective extends HierarchyBindingDirective {
  dropDownTree;
  /**
   * Sets the nodes to display in the DropDownTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.dropDownTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function DropDownTreeHierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreeHierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreeHierarchyBindingDirective,
    selectors: [["", "kendoDropDownTreeHierarchyBinding", ""]],
    inputs: {
      nodes: [0, "kendoDropDownTreeHierarchyBinding", "nodes"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreeHierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoDropDownTreeHierarchyBinding"]
    }]
  });
})();
var MultiSelectTreeFlatBindingDirective = class _MultiSelectTreeFlatBindingDirective extends FlatDataBindingDirective {
  multiSelectTree;
  /**
   * Sets the nodes to display in the MultiSelectTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * Sets the unique field that identifies a node.
   */
  idField;
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(multiSelectTree) {
    super(multiSelectTree);
    this.multiSelectTree = multiSelectTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.multiSelectTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function MultiSelectTreeFlatBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeFlatBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeFlatBindingDirective,
    selectors: [["", "kendoMultiSelectTreeFlatBinding", ""]],
    inputs: {
      nodes: [0, "kendoMultiSelectTreeFlatBinding", "nodes"],
      idField: [0, "valueField", "idField"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeFlatBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeFlatBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoMultiSelectTreeFlatBinding"]
    }],
    idField: [{
      type: Input,
      args: ["valueField"]
    }]
  });
})();
var MultiSelectTreeHierarchyBindingDirective = class _MultiSelectTreeHierarchyBindingDirective extends HierarchyBindingDirective {
  multiSelectTree;
  /**
   * Sets the nodes to display in the MultiSelectTree.
   */
  set nodes(nodes) {
    this._nodes = nodes;
  }
  get nodes() {
    return this._nodes;
  }
  /**
   * @hidden
   */
  set filter(term) {
    super.filter = term;
  }
  constructor(multiSelectTree) {
    super(multiSelectTree);
    this.multiSelectTree = multiSelectTree;
  }
  ngOnChanges(changes) {
    if (isChanged("nodes", changes, false)) {
      this.multiSelectTree.nodes = changes["nodes"].currentValue;
      super.nodes = changes["nodes"].currentValue;
    }
    super.ngOnChanges(changes);
  }
  static ɵfac = function MultiSelectTreeHierarchyBindingDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeHierarchyBindingDirective)(ɵɵdirectiveInject(DataBoundComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeHierarchyBindingDirective,
    selectors: [["", "kendoMultiSelectTreeHierarchyBinding", ""]],
    inputs: {
      nodes: [0, "kendoMultiSelectTreeHierarchyBinding", "nodes"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeHierarchyBindingDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeHierarchyBinding]",
      standalone: true
    }]
  }], function() {
    return [{
      type: DataBoundComponent
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["kendoMultiSelectTreeHierarchyBinding"]
    }]
  });
})();
var DropDownTreesExpandDirective = class _DropDownTreesExpandDirective extends ExpandDirective {
  dropDownTree;
  /**
   * @hidden
   *
   * Ensures a user-defined `isNodeExpanded` callback will not be overriden by the default directive setup.
   * Implemented as a value setter in the base directive, this just overrides the input name.
   */
  set isExpanded(value) {
    this.dropDownTree.isExpanded = value;
  }
  constructor(dropDownTree) {
    super(dropDownTree);
    this.dropDownTree = dropDownTree;
  }
  static ɵfac = function DropDownTreesExpandDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreesExpandDirective)(ɵɵdirectiveInject(ExpandableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _DropDownTreesExpandDirective,
    selectors: [["", "kendoDropDownTreeExpandable", ""], ["", "kendoMultiSelectTreeExpandable", ""]],
    inputs: {
      isExpanded: [0, "isNodeExpanded", "isExpanded"]
    },
    standalone: true,
    features: [ɵɵInheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreesExpandDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownTreeExpandable], [kendoMultiSelectTreeExpandable]",
      standalone: true
    }]
  }], function() {
    return [{
      type: ExpandableComponent
    }];
  }, {
    isExpanded: [{
      type: Input,
      args: ["isNodeExpanded"]
    }]
  });
})();
var DEFAULT_FILTER_SETTINGS2 = {
  caseSensitive: false,
  operator: "startsWith"
};
var FilterDirective = class _FilterDirective {
  component;
  /**
   * The initial data that will be used as a source array for the filtering operations.
   */
  set data(data) {
    this._data = data || [];
  }
  get data() {
    return this._data;
  }
  /**
   * The configuration object which sets the behavior of the `kendoDropDownFilter` directive.
   * If no [DropDownFilterSettings]({% slug api_dropdowns_dropdownfiltersettings %}) object is provided to this input, the directive will use the default interface settings.
   */
  rawSettings;
  /**
   * @hidden
   *
   * Sets whether the filtering functionality is enabled on component init.
   */
  filterable = true;
  _data = [];
  filterChangeSubscription;
  constructor(component) {
    this.component = component;
  }
  ngOnInit() {
    this.component.filterable = this.filterable;
    this.filterChangeSubscription = this.component.filterChange.subscribe(this.handleFilterChange.bind(this));
  }
  ngOnDestroy() {
    if (isPresent5(this.filterChangeSubscription)) {
      this.filterChangeSubscription.unsubscribe();
    }
  }
  handleFilterChange(query) {
    this.component.data = this.data.filter((item) => this.matchesAnyField(item, query));
  }
  matchesAnyField(item, query) {
    const normalizedQuery = this.normalizeValue(query);
    const {
      fields
    } = this.filterSettings;
    if (fields.length === 0) {
      return this.checkItem(item, normalizedQuery);
    }
    return fields.some((field) => this.checkItem(getter2(item, field), normalizedQuery));
  }
  checkItem(target, query) {
    target = this.normalizeValue(target);
    if (this.filterSettings.operator === "contains") {
      return target.indexOf(query) !== -1;
    } else {
      return target.startsWith(query);
    }
  }
  normalizeValue(value) {
    const normalizedValue = isPresent5(value) ? value.toString() : "";
    return this.filterSettings.caseSensitive ? normalizedValue : normalizedValue.toLowerCase();
  }
  getFilterFields(providedFields) {
    if (!this.component.textField && !this.component.valueField) {
      return [];
    }
    if (isArray2(providedFields) && providedFields.length > 0) {
      return providedFields;
    } else {
      const textField = this.component.textField || this.component.valueField;
      return [textField];
    }
  }
  get filterSettings() {
    const settings = this.rawSettings;
    const providedFields = isPresent5(settings) && typeof settings === "object" ? settings.fields : [];
    return Object.assign({}, DEFAULT_FILTER_SETTINGS2, settings, {
      fields: this.getFilterFields(providedFields)
    });
  }
  static ɵfac = function FilterDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FilterDirective)(ɵɵdirectiveInject(FilterableComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _FilterDirective,
    selectors: [["", "kendoDropDownFilter", ""]],
    inputs: {
      data: "data",
      rawSettings: [0, "kendoDropDownFilter", "rawSettings"],
      filterable: "filterable"
    },
    standalone: true
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FilterDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoDropDownFilter]",
      standalone: true
    }]
  }], function() {
    return [{
      type: FilterableComponent
    }];
  }, {
    data: [{
      type: Input
    }],
    rawSettings: [{
      type: Input,
      args: ["kendoDropDownFilter"]
    }],
    filterable: [{
      type: Input
    }]
  });
})();
var CustomMessagesComponent2 = class _CustomMessagesComponent extends Messages2 {
  service;
  constructor(service) {
    super();
    this.service = service;
  }
  get override() {
    return true;
  }
  static ɵfac = function CustomMessagesComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CustomMessagesComponent)(ɵɵdirectiveInject(LocalizationService));
  };
  static ɵcmp = ɵɵdefineComponent({
    type: _CustomMessagesComponent,
    selectors: [["kendo-dropdownlist-messages"], ["kendo-combobox-messages"], ["kendo-multicolumncombobox-messages"], ["kendo-autocomplete-messages"], ["kendo-multiselect-messages"], ["kendo-dropdowntree-messages"], ["kendo-multiselecttree-messages"]],
    standalone: true,
    features: [ɵɵProvidersFeature([{
      provide: Messages2,
      useExisting: forwardRef(() => _CustomMessagesComponent)
    }]), ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
    decls: 0,
    vars: 0,
    template: function CustomMessagesComponent_Template(rf, ctx) {
    },
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomMessagesComponent2, [{
    type: Component,
    args: [{
      providers: [{
        provide: Messages2,
        useExisting: forwardRef(() => CustomMessagesComponent2)
      }],
      selector: "kendo-dropdownlist-messages,kendo-combobox-messages,kendo-multicolumncombobox-messages,kendo-autocomplete-messages,kendo-multiselect-messages,kendo-dropdowntree-messages,kendo-multiselecttree-messages",
      template: ``,
      standalone: true
    }]
  }], function() {
    return [{
      type: LocalizationService
    }];
  }, null);
})();
var SummaryTagDirective = class _SummaryTagDirective {
  multiSelectComponent;
  /**
   * Sets the number of selected items after which the summary tag appears.
   *
   * @default 0
   */
  showAfter = 0;
  constructor(multiSelectComponent) {
    this.multiSelectComponent = multiSelectComponent;
    this.createTagMapper();
  }
  ngOnChanges(changes) {
    if (isPresent5(changes.showAfter)) {
      this.createTagMapper();
      this.multiSelectComponent.onTagMapperChange();
    }
  }
  createTagMapper() {
    const showAfter = parseNumber(this.showAfter);
    this.multiSelectComponent.tagMapper = (tags) => {
      if (tags.length > showAfter) {
        const result = tags.slice(0, showAfter);
        result.push(tags.slice(showAfter, tags.length));
        return result;
      } else {
        return tags;
      }
    };
  }
  static ɵfac = function SummaryTagDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SummaryTagDirective)(ɵɵdirectiveInject(MultiSelectComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _SummaryTagDirective,
    selectors: [["", "kendoMultiSelectSummaryTag", ""]],
    inputs: {
      showAfter: [0, "kendoMultiSelectSummaryTag", "showAfter"]
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SummaryTagDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectSummaryTag]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiSelectComponent
    }];
  }, {
    showAfter: [{
      type: Input,
      args: ["kendoMultiSelectSummaryTag"]
    }]
  });
})();
var MultiSelectTreeSummaryTagDirective = class _MultiSelectTreeSummaryTagDirective {
  multiSelectTreeComponent;
  /**
   * Sets the number of data items that need to be selected before the summary tag appears.
   *
   * @default 0
   */
  showAfter = 0;
  constructor(multiSelectTreeComponent) {
    this.multiSelectTreeComponent = multiSelectTreeComponent;
    this.createTagMapper();
  }
  ngOnChanges(changes) {
    if (isPresent5(changes.showAfter)) {
      this.createTagMapper();
      this.multiSelectTreeComponent.handleTagMapperChange(this.showAfter);
    }
  }
  createTagMapper() {
    const showAfter = parseNumber(this.showAfter);
    this.multiSelectTreeComponent.tagMapper = (tags) => {
      if (tags.length > showAfter) {
        return [...tags.slice(0, showAfter), tags.slice(showAfter)];
      } else {
        return tags;
      }
    };
  }
  static ɵfac = function MultiSelectTreeSummaryTagDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectTreeSummaryTagDirective)(ɵɵdirectiveInject(MultiSelectTreeComponent));
  };
  static ɵdir = ɵɵdefineDirective({
    type: _MultiSelectTreeSummaryTagDirective,
    selectors: [["", "kendoMultiSelectTreeSummaryTag", ""]],
    inputs: {
      showAfter: [0, "kendoMultiSelectTreeSummaryTag", "showAfter"]
    },
    standalone: true,
    features: [ɵɵNgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectTreeSummaryTagDirective, [{
    type: Directive,
    args: [{
      selector: "[kendoMultiSelectTreeSummaryTag]",
      standalone: true
    }]
  }], function() {
    return [{
      type: MultiSelectTreeComponent
    }];
  }, {
    showAfter: [{
      type: Input,
      args: ["kendoMultiSelectTreeSummaryTag"]
    }]
  });
})();
var KENDO_AUTOCOMPLETE = [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];
var KENDO_COMBOBOX = [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];
var KENDO_MULTICOLUMNCOMBOBOX = [MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective];
var KENDO_DROPDOWNLIST = [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2];
var KENDO_MULTISELECT = [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent];
var KENDO_DROPDOWNTREE = [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2];
var KENDO_MULTISELECTTREE = [MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2];
var KENDO_DROPDOWNS = [...KENDO_AUTOCOMPLETE, ...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_DROPDOWNLIST, ...KENDO_MULTISELECT, ...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE];
var DropDownTreesModule = class _DropDownTreesModule {
  static ɵfac = function DropDownTreesModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownTreesModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownTreesModule,
    imports: [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2],
    exports: [DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [DropDownTreeComponent, MultiSelectTreeComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownTreesModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE],
      exports: [...KENDO_DROPDOWNTREE, ...KENDO_MULTISELECTTREE],
      providers: [IconsService, PopupService, ResizeBatchService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var DropDownsModule = class _DropDownsModule {
  static ɵfac = function DropDownsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownsModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownsModule,
    imports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective],
    exports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, DropDownTreeComponent, DropDownTreeFlatBindingDirective, DropDownTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, MultiSelectTreeComponent, MultiSelectTreeFlatBindingDirective, MultiSelectTreeHierarchyBindingDirective, DropDownTreesExpandDirective, NodeTemplateDirective2, MultiSelectTreeSummaryTagDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, FooterTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, CustomMessagesComponent2, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService],
    imports: [AutoCompleteComponent, SeparatorComponent, ComboBoxComponent, SeparatorComponent, MultiColumnComboBoxComponent, SeparatorComponent, DropDownListComponent, MultiSelectComponent, SeparatorComponent, DropDownTreeComponent, MultiSelectTreeComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownsModule, [{
    type: NgModule,
    args: [{
      exports: [...KENDO_DROPDOWNS, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      imports: [...KENDO_DROPDOWNS, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [PopupService, ResizeBatchService, IconsService, DialogContainerService, DialogService, WindowService, WindowContainerService, AdaptiveService]
    }]
  }], null, null);
})();
var MultiSelectModule = class _MultiSelectModule {
  static ɵfac = function MultiSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MultiSelectModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _MultiSelectModule,
    imports: [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [MultiSelectComponent, SummaryTagDirective, CustomItemTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, GroupTagTemplateDirective, TagTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [MultiSelectComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiSelectModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_MULTISELECT, ...KENDO_ADORNMENTS],
      exports: [...KENDO_MULTISELECT, ...KENDO_ADORNMENTS],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var AutoCompleteModule = class _AutoCompleteModule {
  static ɵfac = function AutoCompleteModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AutoCompleteModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _AutoCompleteModule,
    imports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent],
    exports: [AutoCompleteComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [AutoCompleteComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AutoCompleteModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_AUTOCOMPLETE, ...KENDO_ADORNMENTS],
      exports: [...KENDO_AUTOCOMPLETE, ...KENDO_ADORNMENTS],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var ComboBoxModule = class _ComboBoxModule {
  static ɵfac = function ComboBoxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ComboBoxModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _ComboBoxModule,
    imports: [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective],
    exports: [ComboBoxComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, MultiColumnComboBoxComponent, ComboBoxColumnComponent, ColumnHeaderTemplateDirective, ColumnCellTemplateDirective, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2, SuffixTemplateDirective, PrefixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective, PrefixTemplateDirective, SuffixTemplateDirective, SeparatorComponent, ToggleButtonTabStopDirective]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [ComboBoxComponent, SeparatorComponent, MultiColumnComboBoxComponent, SeparatorComponent, SeparatorComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboBoxModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      exports: [...KENDO_COMBOBOX, ...KENDO_MULTICOLUMNCOMBOBOX, ...KENDO_ADORNMENTS, ...KENDO_TOGGLEBUTTONTABSTOP],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
var DropDownListModule = class _DropDownListModule {
  static ɵfac = function DropDownListModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DropDownListModule)();
  };
  static ɵmod = ɵɵdefineNgModule({
    type: _DropDownListModule,
    imports: [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2],
    exports: [DropDownListComponent, FixedGroupTemplateDirective, FooterTemplateDirective, GroupTemplateDirective, HeaderTemplateDirective, ItemTemplateDirective, ValueTemplateDirective, NoDataTemplateDirective, FilterDirective, CustomMessagesComponent2]
  });
  static ɵinj = ɵɵdefineInjector({
    providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService],
    imports: [DropDownListComponent]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropDownListModule, [{
    type: NgModule,
    args: [{
      imports: [...KENDO_DROPDOWNLIST],
      exports: [...KENDO_DROPDOWNLIST],
      providers: [PopupService, ResizeBatchService, IconsService, AdaptiveService]
    }]
  }], null, null);
})();
export {
  AdaptiveRendererComponent2 as AdaptiveRendererComponent,
  AutoCompleteComponent,
  AutoCompleteModule,
  CheckAllDirective,
  CheckDirective2 as CheckDirective,
  ColumnCellTemplateDirective,
  ColumnHeaderTemplateDirective,
  ComboBoxColumnComponent,
  ComboBoxComponent,
  ComboBoxModule,
  CustomItemTemplateDirective,
  CustomMessagesComponent2 as CustomMessagesComponent,
  DropDownListComponent,
  DropDownListModule,
  DropDownTreeComponent,
  DropDownTreeFlatBindingDirective,
  DropDownTreeHierarchyBindingDirective,
  DropDownTreesExpandDirective,
  DropDownTreesModule,
  DropDownsModule,
  FilterDirective,
  FilterInputDirective,
  FilterableComponent,
  FixedGroupTemplateDirective,
  FooterTemplateDirective,
  GroupTagTemplateDirective,
  GroupTemplateDirective,
  HeaderTemplateDirective,
  ItemTemplateDirective,
  KENDO_AUTOCOMPLETE,
  KENDO_COMBOBOX,
  KENDO_DROPDOWNLIST,
  KENDO_DROPDOWNS,
  KENDO_DROPDOWNTREE,
  KENDO_MULTICOLUMNCOMBOBOX,
  KENDO_MULTISELECT,
  KENDO_MULTISELECTTREE,
  ListComponent,
  ListItemDirective,
  LocalizedMessagesDirective2 as LocalizedMessagesDirective,
  MultiColumnComboBoxComponent,
  MultiSelectComponent,
  MultiSelectModule,
  MultiSelectTreeComponent,
  MultiSelectTreeFlatBindingDirective,
  MultiSelectTreeHierarchyBindingDirective,
  MultiSelectTreeSummaryTagDirective,
  NoDataTemplateDirective,
  NodeTemplateDirective2 as NodeTemplateDirective,
  PrefixTemplateDirective,
  PreventableEvent3 as PreventableEvent,
  RemoveTagEvent,
  SearchBarComponent,
  SelectableDirective,
  SeparatorComponent,
  SuffixTemplateDirective,
  SummaryTagDirective,
  TagListComponent,
  TagTemplateDirective,
  ToggleButtonTabStopDirective,
  ValueTemplateDirective
};
//# sourceMappingURL=@progress_kendo-angular-dropdowns.js.map
