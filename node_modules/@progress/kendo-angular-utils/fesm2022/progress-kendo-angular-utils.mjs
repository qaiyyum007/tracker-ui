/**-----------------------------------------------------------------------------------------
* Copyright © 2025 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import * as i0 from '@angular/core';
import { Directive, HostBinding, Input, Injectable, Component, isDevMode, EventEmitter, Output, ContentChildren, NgModule, InjectionToken, Optional, Inject } from '@angular/core';
import { validatePackage } from '@progress/kendo-licensing';
import { dispatchDragAndDrop, getScrollableParent, autoScroll } from '@progress/kendo-draggable-common';
import { PreventableEvent, contains, isDocumentAvailable, parseCSSClassNames, isPresent as isPresent$1, areObjectsEqual } from '@progress/kendo-angular-common';
import { NgTemplateOutlet } from '@angular/common';
import { Subject, BehaviorSubject, Subscription, fromEvent } from 'rxjs';
import { map, tap, filter } from 'rxjs/operators';

/**
 * Represents the Kendo UI DragHandle directive for Angular.
 * Use this directive to specify an element inside a drag target as a handle for dragging instead of the drag target itself.
 *
 * ```html
 * <div kendoDragTarget>
 *  <button kendoDragHandle kendoButton>
 *   Drag me
 *  </button>
 * </div>
 * ```
 */
class DragHandleDirective {
    element;
    touchActionStyle = 'none';
    /**
     * Sets the cursor style of the drag handle. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
     *
     * @default 'move'
     */
    cursorStyle = 'move';
    constructor(element) {
        this.element = element;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragHandleDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DragHandleDirective, isStandalone: true, selector: "[kendoDragHandle]", inputs: { cursorStyle: "cursorStyle" }, host: { properties: { "style.touch-action": "this.touchActionStyle", "style.cursor": "this.cursorStyle" } }, exportAs: ["kendoDragHandle"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragHandleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDragHandle]',
                    exportAs: 'kendoDragHandle',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { touchActionStyle: [{
                type: HostBinding,
                args: ['style.touch-action']
            }], cursorStyle: [{
                type: HostBinding,
                args: ['style.cursor']
            }, {
                type: Input
            }] } });

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-utils',
    productName: 'Kendo UI for Angular',
    productCode: 'KENDOUIANGULAR',
    productCodes: ['KENDOUIANGULAR'],
    publishDate: 1751462971,
    version: '19.2.0',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/'
};

function isDocumentNode(container) {
    return container.nodeType === 9;
}
/**
 * @hidden
 */
const getAction = (event, draggable) => {
    return {
        event: event,
        payload: draggable
    };
};
/**
 * @hidden
 */
const dragTargetTransition = 'transform .3s ease-in-out';
/**
 * @hidden
 */
const isPresent = (value) => value !== null && value !== undefined;
/**
 * @hidden
 */
function closestBySelector(element, selector) {
    if (element.closest) {
        return element.closest(selector);
    }
    const matches = Element.prototype.matches ?
        (el, sel) => el.matches(sel)
        : (el, sel) => el.msMatchesSelector(sel);
    let node = element;
    while (node && !isDocumentNode(node)) {
        if (matches(node, selector)) {
            return node;
        }
        node = node.parentNode;
    }
}
/**
 * @hidden
 */
const intersect = (element, candidates) => {
    let max = 0;
    let result = null;
    candidates.forEach((candidate) => {
        if (candidate && element) {
            const ration = getRatio(element, candidate);
            if (ration > max) {
                max = ration;
                result = candidate;
            }
        }
    });
    return result;
};
const getRatio = (element, target) => {
    const elementRect = element.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();
    const top = Math.max(targetRect.top, elementRect.top);
    const left = Math.max(targetRect.left, elementRect.left);
    const right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
    const bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
    const width = right - left;
    const height = bottom - top;
    if (left < right && top < bottom) {
        const targetArea = targetRect.width * targetRect.height;
        const entryArea = elementRect.width * elementRect.height;
        const intersectionArea = width * height;
        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
        return Number(intersectionRatio.toFixed(4));
    }
    return 0;
};
/**
 * @hidden
 */
const setElementStyles = (renderer, elem, styles) => {
    const props = Object.keys(styles);
    props.forEach(p => {
        renderer.setStyle(elem, p, styles[p]);
    });
};
/**
 * @hidden
 */
const noop = () => { };

/**
 * @hidden
 */
class DragStateService {
    constructor() {
        this.setCallbacks();
    }
    dragTarget = null;
    dropTarget = null;
    dragTargets = [];
    dropTargets = [];
    pressed = false;
    ignoreMouse = false;
    autoScroll = true;
    isScrolling = false;
    scrollableParent = null;
    autoScrollDirection = { horizontal: true, vertical: true };
    initialClientOffset = { x: 0, y: 0 };
    clientOffset = { x: 0, y: 0 };
    initialScrollOffset = { x: 0, y: 0 };
    scrollOffset = { x: 0, y: 0 };
    offset = { x: 0, y: 0 };
    pageOffset = { x: 0, y: 0 };
    velocity = { x: 0, y: 0 };
    dragTargetDirective;
    state;
    dragIndex = null;
    dropIndex = null;
    dragData;
    dragTargetId;
    callbacks = {};
    scrollInterval = null;
    handleDragAndDrop(action) {
        this.updateState();
        dispatchDragAndDrop(this.state, action, this.callbacks);
    }
    setPressed(pressed) {
        this.pressed = pressed;
    }
    setScrolling(isScrolling) {
        this.isScrolling = isScrolling;
        if (isScrolling) {
            const scrollableParent = getScrollableParent(document.elementFromPoint(this.clientOffset.x, this.clientOffset.y));
            window.clearInterval(this.scrollInterval);
            this.scrollInterval = window.setInterval(() => {
                autoScroll(scrollableParent, { x: this.velocity.x, y: this.velocity.y });
            }, 50);
        }
        else {
            if (this.scrollInterval) {
                window.clearInterval(this.scrollInterval);
                this.scrollInterval = null;
            }
        }
    }
    setVelocity(velocity) {
        this.velocity = velocity;
    }
    setOffset(offset) {
        this.offset = offset;
    }
    setClientOffset(clientOffset) {
        this.clientOffset = clientOffset;
    }
    setPageOffset(pageOffset) {
        this.pageOffset = pageOffset;
    }
    setInitialClientOffset(initialClientOffset) {
        this.initialClientOffset = initialClientOffset;
    }
    setScrollOffset(scrollOffset) {
        this.scrollOffset = scrollOffset;
    }
    setInitialScrollOffset(initialScrollOffset) {
        this.initialScrollOffset = initialScrollOffset;
    }
    get dragTargetPresent() {
        return isPresent(this.dragTarget?.element);
    }
    get dropTargetPresent() {
        return isPresent(this.dropTarget?.element);
    }
    updateState() {
        this.state = {
            drag: this.dragTarget,
            drop: this.dropTarget,
            drags: this.dragTargets,
            drops: this.dropTargets,
            pressed: this.pressed,
            ignoreMouse: this.ignoreMouse,
            autoScroll: this.autoScroll,
            isScrolling: this.isScrolling,
            scrollableParent: this.scrollableParent,
            autoScrollDirection: this.autoScrollDirection,
            initialClientOffset: this.initialClientOffset,
            clientOffset: this.clientOffset,
            initialScrollOffset: this.initialScrollOffset,
            scrollOffset: this.scrollOffset,
            offset: this.offset,
            pageOffset: this.pageOffset,
            velocity: this.velocity
        };
    }
    setCallbacks() {
        this.callbacks = {
            onVelocityChange: this.setVelocity.bind(this),
            onOffsetChange: this.setOffset.bind(this),
            onClientOffsetChange: this.setClientOffset.bind(this),
            onPageOffsetChange: this.setPageOffset.bind(this),
            onInitialClientOffsetChange: this.setInitialClientOffset.bind(this),
            onScrollOffsetChange: this.setScrollOffset.bind(this),
            onInitialScrollOffsetChange: this.setInitialScrollOffset.bind(this),
            onIsPressedChange: this.setPressed.bind(this),
            onIsScrollingChange: this.setScrolling.bind(this)
        };
    }
    ngOnDestroy() {
        if (this.scrollInterval) {
            window.clearInterval(this.scrollInterval);
            this.scrollInterval = null;
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragStateService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragStateService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragStateService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

/**
 * @hidden
 */
class HintComponent {
    element;
    template;
    directive;
    targetIndex;
    contextData;
    customContext;
    pointerEvents = 'none';
    constructor(element) {
        this.element = element;
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HintComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.2.12", type: HintComponent, isStandalone: true, selector: "kendo-draghint", inputs: { template: "template", directive: "directive", targetIndex: "targetIndex", contextData: "contextData", customContext: "customContext" }, host: { properties: { "style.pointer-events": "this.pointerEvents" } }, ngImport: i0, template: `
        <ng-container
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="customContext || { $implicit: this.directive, index: this.targetIndex, data: this.contextData }">
        </ng-container>
    `, isInline: true, dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }] });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: HintComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'kendo-draghint',
                    template: `
        <ng-container
            [ngTemplateOutlet]="template"
            [ngTemplateOutletContext]="customContext || { $implicit: this.directive, index: this.targetIndex, data: this.contextData }">
        </ng-container>
    `,
                    standalone: true,
                    imports: [NgTemplateOutlet]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { template: [{
                type: Input
            }], directive: [{
                type: Input
            }], targetIndex: [{
                type: Input
            }], contextData: [{
                type: Input
            }], customContext: [{
                type: Input
            }], pointerEvents: [{
                type: HostBinding,
                args: ['style.pointer-events']
            }] } });

/**
 * Arguments for the press event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetPressEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dragTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

/**
 * Arguments for the dragReady event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetDragReadyEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `dragStart` event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetDragStartEvent extends PreventableEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dragTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Arguments for the dragEnd event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetDragEndEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dragTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

/**
 * Arguments for the drag event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetDragEvent extends PreventableEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The hint element of the `DragTarget`.
     */
    hintElement;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dragTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        super();
        Object.assign(this, args);
    }
}

/**
 * Arguments for the release event of the `DragTarget` and `DragTargetContainer`.
 */
class DragTargetReleaseEvent {
    /**
     * The information related to the current drag event.
     * This is the normalized drag event that contains details about the drag operation.
     */
    dragEvent;
    /**
     * The DOM element being dragged.
     */
    dragTarget;
    /**
     * The identifier passed to the `dragTargetId` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragTargetId;
    /**
     * The index of the current drag target in the collection of drag targets. Applies to `DragTargetContainer` directive.
     */
    dragTargetIndex;
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DragTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dragTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

let isDragStartPrevented$1 = false;
let isDragPrevented$1 = false;
/**
 * Represents the [Kendo UI DragTargetContainer directive for Angular]({% slug api_utils_dragtargetcontainerdirective %}).
 * Use this directive to make multiple elements draggable inside a container.
 *
 * @example
 * ```html
 * <ul kendoDragTargetContainer dragTargetFilter=".my-draggable">
 *   <li class="my-draggable"> Item 1</li>
 *   <li class="my-draggable"> Item 2</li>
 *   <li class="my-draggable"> Item 3</li>
 * </ul>
 * ```
 */
class DragTargetContainerDirective {
    wrapper;
    ngZone;
    renderer;
    service;
    viewContainer;
    cdr;
    /**
     * Defines whether a hint will be used for dragging. By default, the hint is a copy of the current drag target. [See example]({% slug drag_hint %}).
     *
     * @default false
     */
    hint = false;
    /**
     * Sets a selector for elements in the container to make them draggable. The possible values include any
     * DOM `selector`. [See example]({% slug drag_target_container %}).
     */
    set dragTargetFilter(value) {
        this._dragTargetFilter = value;
        if (!this.dragDisabled) {
            this.initializeDragTargets();
        }
    }
    get dragTargetFilter() {
        return this._dragTargetFilter;
    }
    /**
     * Sets a selector for elements inside each drag target to use as drag handles.
     */
    dragHandle;
    /**
     * Sets the delay in milliseconds before dragging begins. [See example](slug:drag_target_container#toc-events).
     *
     * @default 0
     */
    dragDelay = 0;
    /**
     * Sets the number of pixels the pointer must move before dragging starts. [See example]({% slug minimum_distance %}).
     *
     * @default 0
     */
    threshold = 0;
    /**
     * Sets a unique identifier for each drag target.
     * It exposes the current drag target HTML element and its index in the collection of drag targets as arguments.
     */
    set dragTargetId(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`dragTargetId must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._dragTargetId = fn;
    }
    get dragTargetId() {
        return this._dragTargetId;
    }
    /**
     * Sets a callback function to return custom data for `DropTarget` events.
     * It exposes the current `DragTarget` HTML element, its `dragTargetId`, and its index in the collection of drag targets as arguments.
     */
    set dragData(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._dragData = fn;
    }
    get dragData() {
        return this._dragData;
    }
    /**
     * Disables dragging of drag targets in the container when set to `true`.
     *
     * @default false
     */
    set dragDisabled(value) {
        this._dragDisabled = value;
        if (value) {
            this.clearPreviousTargets();
            this.removeListeners();
            if (isPresent(this.hintElem)) {
                this.destroyHint();
            }
        }
        else {
            if (isPresent(this.wrapper) || isPresent(this.currentDragTarget)) {
                this.subscribe();
            }
            this.initializeDragTargets();
        }
    }
    get dragDisabled() {
        return this._dragDisabled;
    }
    /**
     * Sets whether to use the default dragging behavior or handle it manually.
     *
     * @default 'auto'
     */
    mode = 'auto';
    /**
     * Sets the cursor style of the drag targets. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
     *
     * @default 'move'
     */
    cursorStyle = 'move';
    /**
     * @hidden
     */
    hintContext;
    /**
     * Fires when a drag target's `dragDelay` has passed and the user can drag the element.
     */
    onDragReady = new EventEmitter();
    /**
     * Fires when the user presses a drag target element.
     */
    onPress = new EventEmitter();
    /**
     * Fires when dragging of a drag target element begins.
     */
    onDragStart = new EventEmitter();
    /**
     * Fires while the user drags a drag target element.
     */
    onDrag = new EventEmitter();
    /**
     * Fires when the user releases a drag target element after pressing it.
     */
    onRelease = new EventEmitter();
    /**
     * Fires when dragging of a drag target ends and the element is released.
     */
    onDragEnd = new EventEmitter();
    /**
     * Notifies the `DragTargetContainer` that its content has changed.
     */
    notify() {
        this.cdr.detectChanges();
        this.initializeDragTargets();
    }
    currentDragTarget = null;
    dragTimeout = null;
    pressed = false;
    dragStarted = false;
    hintComponent = null;
    defaultHint = null;
    currentDragTargetElement = null;
    scrollableParent = null;
    previousDragTargets = [];
    initialPosition = { x: 0, y: 0 };
    position = { x: 0, y: 0 };
    positionsMap = new Map();
    _dragTargetFilter = null;
    _dragDisabled = false;
    _dragData = () => null;
    _dragTargetId = () => null;
    prevUserSelect;
    get allDragTargets() {
        return this.queryHost(this.dragTargetFilter);
    }
    get dragHandles() {
        return this.isHandleSelectorValid ? this.queryHost(this.dragHandle) : null;
    }
    get hintTemplate() {
        return isPresent(this.hint) && typeof this.hint === 'object' ? this.hint.hintTemplate : null;
    }
    constructor(wrapper, ngZone, renderer, service, viewContainer, cdr) {
        this.wrapper = wrapper;
        this.ngZone = ngZone;
        this.renderer = renderer;
        this.service = service;
        this.viewContainer = viewContainer;
        this.cdr = cdr;
        validatePackage(packageMetadata);
    }
    ngAfterViewInit() {
        const isTargetPresent = isPresent(this.wrapper) || isPresent(this.currentDragTarget);
        if (!this.dragDisabled && isTargetPresent) {
            this.subscribe();
        }
        !this.dragDisabled && this.initializeDragTargets();
    }
    ngOnDestroy() {
        this.removeListeners();
    }
    onPointerDown(event) {
        const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
        if (this.dragTargetFilter === '' || !isPresent(filterElement)) {
            return;
        }
        if (isPresent(this.dragHandles) && !this.isDragHandle(event.target)) {
            return;
        }
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
        this.subscribe();
    }
    onTouchStart(event) {
        const filterElement = closestBySelector(event.target, this.isHandleSelectorValid ? this.dragHandle : this.dragTargetFilter);
        if (this.dragTargetFilter === '' || !isPresent(filterElement)) {
            return;
        }
        if (isPresent(this.dragHandles) && !this.isDragHandle(event.target)) {
            return;
        }
        event.preventDefault();
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
        this.subscribe();
    }
    onPointerMove(event) {
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
    }
    onTouchMove(event) {
        event.preventDefault();
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
    }
    onPointerUp(event) {
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
        this.subscribe();
    }
    onContextMenu(event) {
        event.preventDefault();
        const action = getAction(event, this.currentDragTarget);
        this.service.handleDragAndDrop(action);
        this.subscribe();
    }
    handlePress(event) {
        if (this.dragDelay > 0) {
            this.dragTimeout = window.setTimeout(() => {
                this.pressed = true;
                this.emitZoneAwareEvent('onDragReady', event);
            }, this.dragDelay);
        }
        else {
            this.pressed = true;
        }
        const eventTarget = event.originalEvent.target;
        this.currentDragTargetElement = closestBySelector(eventTarget, this.dragTargetFilter);
        this.currentDragTarget.element = this.currentDragTargetElement;
        this.service.dragIndex = this.getDragIndex();
        this.scrollableParent = this.hintTemplate ? document.body : this.currentDragTargetElement ? getScrollableParent(this.currentDragTargetElement) : null;
        this.prevUserSelect = this.currentDragTargetElement.style.userSelect;
        this.renderer.setStyle(this.currentDragTargetElement, 'user-select', 'none');
        this.emitZoneAwareEvent('onPress', event);
    }
    handleDragStart(event) {
        if (!this.pressed) {
            if (this.dragTimeout) {
                window.clearTimeout(this.dragTimeout);
                this.dragTimeout = null;
            }
            return;
        }
        isDragStartPrevented$1 = this.emitZoneAwareEvent('onDragStart', event).isDefaultPrevented();
        if (isDragStartPrevented$1) {
            return;
        }
        this.position = this.positionsMap.has(this.currentDragTargetElement) ? this.positionsMap.get(this.currentDragTargetElement) : { x: 0, y: 0 };
        if (this.hint) {
            this.createHint();
            if (this.mode === 'auto') {
                this.renderer.setStyle(this.currentDragTargetElement, 'opacity', '0.7');
            }
        }
        else {
            this.initialPosition = { x: event.clientX - this.position.x, y: event.clientY - this.position.y };
        }
        this.dragStarted = this.threshold === 0;
        this.service.dragTarget = this.currentDragTarget;
        const targetIdArgs = { dragTarget: this.currentDragTargetElement, dragTargetIndex: this.service.dragIndex };
        this.service.dragTargetId = this.dragTargetId(targetIdArgs);
        const targetDataArgs = Object.assign({ dragTargetId: this.service.dragTargetId }, targetIdArgs);
        this.service.dragData = this.dragData(targetDataArgs);
    }
    handleDrag(event) {
        if (!this.pressed || isDragStartPrevented$1) {
            return;
        }
        const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
        this.position = this.calculatePosition(elem, event);
        const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
        if (!this.dragStarted && thresholdNotReached) {
            return;
        }
        if (!this.dragStarted && this.threshold > 0) {
            this.dragStarted = true;
        }
        isDragPrevented$1 = this.emitZoneAwareEvent('onDrag', event).isDefaultPrevented();
        if (isDragPrevented$1) {
            return;
        }
        if (this.mode === 'auto') {
            this.performDrag();
        }
        else {
            this.dragStarted = true;
        }
    }
    handleRelease(event) {
        if (this.dragStarted) {
            this.positionsMap.set(this.currentDragTargetElement, this.position);
        }
        if (this.dragTimeout) {
            clearTimeout(this.dragTimeout);
            this.dragTimeout = null;
        }
        this.pressed = false;
        this.prevUserSelect ? this.renderer.setStyle(this.currentDragTargetElement, 'user-select', this.prevUserSelect) :
            this.renderer.removeStyle(this.currentDragTargetElement, 'user-select');
        this.prevUserSelect = null;
        this.emitZoneAwareEvent('onRelease', event);
    }
    handleDragEnd(event) {
        if (!this.dragStarted) {
            return;
        }
        if (this.mode === 'auto') {
            const isDroppedOverParentTarget = isPresent(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
            const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
            if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent(elem)) {
                this.renderer.removeStyle(elem, 'transform');
                setElementStyles(this.renderer, elem, {
                    transition: dragTargetTransition
                });
                this.positionsMap.delete(this.currentDragTargetElement);
            }
        }
        if (this.hint && isPresent(this.hintElem)) {
            this.destroyHint();
            if (this.mode === 'auto') {
                this.renderer.removeStyle(this.currentDragTargetElement, 'opacity');
            }
        }
        this.service.dragTarget = null;
        this.service.dragIndex = null;
        this.currentDragTarget.element = null;
        this.emitZoneAwareEvent('onDragEnd', event);
        if (isDragStartPrevented$1 || isDragPrevented$1) {
            return;
        }
        this.dragStarted = false;
    }
    get nativeElement() {
        return this.wrapper.nativeElement;
    }
    get hintElem() {
        return this.hintTemplate && isPresent(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
    }
    removeListeners() {
        if (isPresent(this.scrollableParent)) {
            this.scrollableParent.removeEventListener('scroll', this.onPointerMove);
        }
        const element = this.nativeElement;
        if (!isDocumentAvailable()) {
            return;
        }
        document.removeEventListener('pointermove', this.onPointerMove);
        document.removeEventListener('pointerup', this.onPointerUp, true);
        document.removeEventListener('pointercancel', this.onPointerUp);
        document.removeEventListener('contextmenu', this.onContextMenu);
        window.removeEventListener('touchmove', noop);
        element.removeEventListener('touchmove', this.onTouchMove);
        element.removeEventListener('touchend', this.onPointerUp);
        document.removeEventListener('mousemove', this.onPointerMove);
        document.removeEventListener('mouseup', this.onPointerUp);
        document.removeEventListener('touchcancel', this.onPointerUp);
        element.removeEventListener('pointerdown', this.onPointerDown);
        element.removeEventListener('mousedown', this.onPointerDown);
        element.removeEventListener('touchstart', this.onTouchStart);
    }
    get supportPointerEvent() {
        return Boolean(typeof window !== 'undefined' && window.PointerEvent);
    }
    subscribe() {
        this.ngZone.runOutsideAngular(() => {
            this.removeListeners();
            if (!(isDocumentAvailable() && isPresent(this.wrapper))) {
                return;
            }
            this.onPointerMove = this.onPointerMove.bind(this);
            this.onPointerUp = this.onPointerUp.bind(this);
            this.onTouchMove = this.onTouchMove.bind(this);
            this.onContextMenu = this.onContextMenu.bind(this);
            this.onPointerDown = this.onPointerDown.bind(this);
            this.onTouchStart = this.onTouchStart.bind(this);
            const element = this.nativeElement;
            if (this.supportPointerEvent) {
                if (isPresent(this.scrollableParent)) {
                    this.scrollableParent.addEventListener('scroll', this.onPointerMove, { passive: true });
                }
                element.addEventListener('pointerdown', this.onPointerDown, { passive: true });
                if (this.pressed) {
                    document.addEventListener('pointermove', this.onPointerMove);
                    document.addEventListener('pointerup', this.onPointerUp, true);
                    document.addEventListener('contextmenu', this.onContextMenu);
                    document.addEventListener('pointercancel', this.onPointerUp, { passive: true });
                }
            }
            else {
                window.addEventListener('touchmove', noop, { capture: false, passive: false });
                element.addEventListener('mousedown', this.onPointerDown, { passive: true });
                element.addEventListener('touchstart', this.onTouchStart, { passive: true });
                if (this.pressed) {
                    document.addEventListener('mousemove', this.onPointerMove, { passive: true });
                    document.addEventListener('mouseup', this.onPointerUp, { passive: true });
                    element.addEventListener('touchmove', this.onTouchMove, { passive: true });
                    element.addEventListener('touchend', this.onPointerUp, { passive: true });
                }
            }
        });
    }
    emitZoneAwareEvent(event, normalizedEvent) {
        const targetIdArgs = { dragTarget: this.currentDragTargetElement, dragTargetIndex: this.service.dragIndex };
        const eventProps = {
            dragTarget: this.currentDragTargetElement,
            dragEvent: normalizedEvent,
            dragTargetIndex: this.service.dragIndex,
            dragTargetId: this.dragTargetId(targetIdArgs)
        };
        if (this.hint && isPresent(this.hintElem)) {
            eventProps.hintElement = this.hintElem;
        }
        let eventArgs;
        switch (event) {
            case 'onDragReady':
                eventArgs = new DragTargetDragReadyEvent(eventProps);
                break;
            case 'onPress':
                eventArgs = new DragTargetPressEvent(eventProps);
                break;
            case 'onDragStart':
                eventArgs = new DragTargetDragStartEvent(eventProps);
                break;
            case 'onDrag':
                eventArgs = new DragTargetDragEvent(eventProps);
                break;
            case 'onRelease':
                eventArgs = new DragTargetReleaseEvent(eventProps);
                break;
            case 'onDragEnd':
                eventArgs = new DragTargetDragEndEvent(eventProps);
                break;
            default:
                break;
        }
        this.ngZone.run(() => {
            this[event].emit(eventArgs);
        });
        return eventArgs;
    }
    createHint() {
        if (!(isDocumentAvailable() && isPresent(this.wrapper))) {
            return;
        }
        if (isPresent(this.hint) && typeof this.hint === 'object') {
            if (isPresent(this.hint.hintTemplate)) {
                this.createCustomHint();
            }
            else {
                this.createDefaultHint();
            }
        }
        else {
            this.createDefaultHint();
        }
        this.currentDragTarget.hint = this.hintElem;
        if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {
            this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
        }
        else {
            document.body.appendChild(this.hintElem);
        }
    }
    createDefaultHint() {
        this.defaultHint = this.currentDragTargetElement.cloneNode(true);
        if (typeof this.hint === 'object') {
            if (isPresent(this.hint.hintClass)) {
                const hintClasses = parseCSSClassNames(this.hint.hintClass);
                hintClasses.forEach(className => this.renderer.addClass(this.defaultHint, className));
            }
        }
    }
    createCustomHint() {
        if (isPresent(this.hint.appendTo)) {
            this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
        }
        else {
            this.hintComponent = this.viewContainer.createComponent(HintComponent);
        }
        this.hintComponent.instance.template = this.hintTemplate;
        this.hintComponent.instance.directive = this;
        this.hintComponent.instance.targetIndex = this.service.dragIndex;
        const targetDataArgs = { dragTarget: this.currentDragTargetElement, dragTargetId: this.service.dragTargetId, dragTargetIndex: this.service.dragIndex };
        this.hintComponent.instance.contextData = this.dragData(targetDataArgs);
        this.hintComponent.instance.customContext = this.hintContext;
        this.hintComponent.changeDetectorRef.detectChanges();
    }
    destroyHint() {
        if (isPresent(this.hintTemplate)) {
            this.hintComponent.destroy();
            this.hintComponent.changeDetectorRef.detectChanges();
            this.hintComponent = null;
        }
        else {
            document.body.removeChild(this.defaultHint);
            this.defaultHint = null;
        }
        this.currentDragTarget.hint = null;
    }
    getDragIndex() {
        return this.allDragTargets.indexOf(this.currentDragTargetElement);
    }
    initializeDragTargets() {
        if (!isPresent(this.allDragTargets)) {
            if (this.previousDragTargets.length > 0) {
                this.clearPreviousTargets();
            }
            return;
        }
        this.allDragTargets.forEach(dragTargetEl => {
            const isDragTargetInitialized = this.service.dragTargets.find(dt => dt.element === dragTargetEl);
            if (!isDragTargetInitialized) {
                this.service.dragTargets.push({
                    element: dragTargetEl,
                    hint: null,
                    onPress: this.handlePress.bind(this),
                    onRelease: this.handleRelease.bind(this),
                    onDragStart: this.handleDragStart.bind(this),
                    onDrag: this.handleDrag.bind(this),
                    onDragEnd: this.handleDragEnd.bind(this)
                });
            }
        });
        if (this.previousDragTargets.length > 0) {
            const dragTargetsToRemove = this.previousDragTargets.filter(dt => !this.allDragTargets.includes(dt));
            dragTargetsToRemove.forEach(dragTarget => {
                const idx = this.service.dragTargets.findIndex(serviceDragTarget => serviceDragTarget.element === dragTarget);
                if (idx > -1) {
                    this.service.dragTargets.splice(idx, 1);
                }
            });
        }
        this.previousDragTargets = this.allDragTargets;
        this.currentDragTarget = {
            element: null,
            hint: null,
            onPress: this.handlePress.bind(this),
            onRelease: this.handleRelease.bind(this),
            onDragStart: this.handleDragStart.bind(this),
            onDrag: this.handleDrag.bind(this),
            onDragEnd: this.handleDragEnd.bind(this)
        };
        this.setTargetStyles();
    }
    isDragHandle(el) {
        return this.dragHandles.some(dh => contains(dh, el, true));
    }
    get isHandleSelectorValid() {
        return isPresent(this.dragHandle) && this.dragHandle !== '';
    }
    setTargetStyles() {
        if (!isDocumentAvailable()) {
            return;
        }
        if (isPresent(this.dragHandle) && this.dragHandle !== '') {
            if (isPresent(this.dragHandles) && this.dragHandles.length > 0) {
                this.dragHandles.forEach(handle => {
                    this.renderer.setStyle(handle, 'cursor', this.cursorStyle);
                    this.renderer.setStyle(handle, 'touch-action', 'none');
                });
            }
        }
        else {
            this.allDragTargets.forEach(target => {
                this.renderer.setStyle(target, 'cursor', this.cursorStyle);
                this.renderer.setStyle(target, 'touch-action', 'none');
            });
        }
    }
    queryHost(selector) {
        if (isPresent(selector) && selector !== "") {
            return Array.from(this.nativeElement.querySelectorAll(selector));
        }
    }
    clearPreviousTargets() {
        this.previousDragTargets.forEach(dragTarget => {
            const idx = this.service.dragTargets.findIndex(serviceDragTarget => serviceDragTarget.element === dragTarget);
            if (idx > -1) {
                this.service.dragTargets.splice(idx, 1);
            }
        });
        this.previousDragTargets = [];
    }
    performDrag() {
        const elem = this.hint ? this.hintElem : this.currentDragTargetElement;
        if (elem) {
            const styles = this.getStylesPerElement(elem);
            setElementStyles(this.renderer, elem, styles);
        }
    }
    calculatePosition(element, event) {
        let position = null;
        if (!isDocumentAvailable()) {
            return { x: 0, y: 0 };
        }
        if (element === this.hintElem) {
            position = { x: event.clientX + window.scrollX, y: event.clientY + window.scrollY };
        }
        else {
            position = { x: event.clientX - this.initialPosition.x + event.scrollX, y: event.clientY - this.initialPosition.y + event.scrollY };
        }
        return position;
    }
    getStylesPerElement(element) {
        if (element === this.hintElem) {
            return {
                top: `${this.position.y}px`,
                left: `${this.position.x}px`,
                transition: 'none',
                position: 'absolute',
                zIndex: 1999
            };
        }
        else {
            const transform = `translate(${this.position.x}px, ${this.position.y}px)`;
            return {
                transform: transform,
                transition: 'none'
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragTargetContainerDirective, deps: [{ token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: DragStateService }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DragTargetContainerDirective, isStandalone: true, selector: "[kendoDragTargetContainer]", inputs: { hint: "hint", dragTargetFilter: "dragTargetFilter", dragHandle: "dragHandle", dragDelay: "dragDelay", threshold: "threshold", dragTargetId: "dragTargetId", dragData: "dragData", dragDisabled: "dragDisabled", mode: "mode", cursorStyle: "cursorStyle", hintContext: "hintContext" }, outputs: { onDragReady: "onDragReady", onPress: "onPress", onDragStart: "onDragStart", onDrag: "onDrag", onRelease: "onRelease", onDragEnd: "onDragEnd" }, exportAs: ["kendoDragTargetContainer"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragTargetContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDragTargetContainer]',
                    exportAs: 'kendoDragTargetContainer',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: DragStateService }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { hint: [{
                type: Input
            }], dragTargetFilter: [{
                type: Input
            }], dragHandle: [{
                type: Input
            }], dragDelay: [{
                type: Input
            }], threshold: [{
                type: Input
            }], dragTargetId: [{
                type: Input
            }], dragData: [{
                type: Input
            }], dragDisabled: [{
                type: Input
            }], mode: [{
                type: Input
            }], cursorStyle: [{
                type: Input
            }], hintContext: [{
                type: Input
            }], onDragReady: [{
                type: Output
            }], onPress: [{
                type: Output
            }], onDragStart: [{
                type: Output
            }], onDrag: [{
                type: Output
            }], onRelease: [{
                type: Output
            }], onDragEnd: [{
                type: Output
            }] } });

let isDragStartPrevented = false;
let isDragPrevented = false;
/**
 * Represents the Kendo UI DragTarget directive for Angular.
 * Use this directive to make an element draggable.
 */
class DragTargetDirective {
    element;
    renderer;
    ngZone;
    service;
    viewContainer;
    get touchActionStyle() {
        return this.dragHandles.length > 0 ? null : 'none';
    }
    /**
     * Defines whether a hint will be used for dragging. By default, the hint is a copy of the drag target. ([see example]({% slug drag_hint %})).
     *
     * @default false
     */
    hint = false;
    /**
     * Sets the number of pixels the pointer must move before dragging starts. Applies when `manualDrag` is `false`. [See example]({% slug minimum_distance %}).
     *
     * @default 0
     */
    threshold = 0;
    /**
     * Sets the automatic container scrolling behavior when close to the edge. [See example]({% slug auto_scroll %}).
     *
     * @default true
     */
    autoScroll = true;
    /**
     * Sets a unique identifier for the drag target.
     */
    dragTargetId;
    /**
     * Sets the delay in milliseconds before dragging begins. [See example]({% slug drag_delay %}).
     *
     * @default 0
     */
    dragDelay = 0;
    /**
     * Restricts dragging to horizontal or vertical only. Applies when `mode` is `auto`. [See example]({% slug axis_lock %}).
     */
    restrictByAxis;
    /**
     * Specifies whether to use the default dragging behavior or handle it manually.
     *
     * @default 'auto'
     */
    mode = 'auto';
    /**
     * Defines a callback function used for attaching custom data to the drag target.
     * The data is available in the events of the respective [`DropTarget`]({% slug api_utils_droptargetdirective %}) or [`DropTargetContainer`]({% slug api_utils_droptargetcontainerdirective %}) directives.
     * The current DragTarget HTML element and its `dragTargetId` will be available as arguments.
     */
    set dragData(fn) {
        if (isDevMode && typeof fn !== 'function') {
            throw new Error(`dragData must be a function, but received ${JSON.stringify(fn)}.`);
        }
        this._dragData = fn;
    }
    get dragData() {
        return this._dragData;
    }
    /**
     * Sets the cursor style of the drag target. Accepts same values as the [CSS `cursor` property](https://developer.mozilla.org/en-US/docs/Web/CSS/cursor#values).
     *
     * @default 'move'
     */
    cursorStyle = 'move';
    /**
     * Fires when the user presses the drag target element.
     */
    onPress = new EventEmitter();
    /**
     * Fires when dragging of the drag target element begins.
     */
    onDragStart = new EventEmitter();
    /**
     * Fires while the user drags the drag target element.
     */
    onDrag = new EventEmitter();
    /**
     * Fires when the drag target's `dragDelay` has passed and the user can drag the element.
     */
    onDragReady = new EventEmitter();
    /**
     * Fires when `DragTarget` is released, either by dropping it on a drop target or by releasing the mouse button.
     */
    onRelease = new EventEmitter();
    /**
     * Fires when dragging of the drag target ends and the element is released.
     */
    onDragEnd = new EventEmitter();
    dragTarget = null;
    hintComponent = null;
    dragStarted = false;
    pressed = false;
    dragReady = false;
    dragTimeout = null;
    initialPosition = { x: 0, y: 0 };
    position = { x: 0, y: 0 };
    scrollableParent = null;
    defaultHint = null;
    _dragData = () => null;
    prevUserSelect;
    get hintTemplate() {
        return isPresent(this.hint) && typeof this.hint === 'object' ? this.hint.hintTemplate : null;
    }
    get nativeElement() {
        return this.element.nativeElement;
    }
    get hintElem() {
        return this.hintTemplate && isPresent(this.hintComponent) ? this.hintComponent.instance.element.nativeElement : this.defaultHint;
    }
    onPointerDown(event) {
        if (this.dragHandles.length && !this.isDragHandle(event.target)) {
            return;
        }
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
        this.service.autoScroll = typeof this.autoScroll === 'object' ? this.autoScroll.enabled !== false : this.autoScroll;
        this.service.scrollableParent = this.getAutoScrollContainer();
        this.service.autoScrollDirection = typeof this.autoScroll === 'object' ? this.autoScroll.direction : { horizontal: true, vertical: true };
        this.attachDomHandlers();
    }
    onTouchStart(event) {
        if (this.dragHandles.length && !this.isDragHandle(event.target)) {
            return;
        }
        event.preventDefault();
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
        this.service.autoScroll = typeof this.autoScroll === 'object' ? this.autoScroll.enabled !== false : this.autoScroll;
        this.service.scrollableParent = this.getAutoScrollContainer();
        this.service.autoScrollDirection = typeof this.autoScroll === 'object' ? this.autoScroll.direction : { horizontal: true, vertical: true };
        this.attachDomHandlers();
    }
    onPointerMove(event) {
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
    }
    onTouchMove(event) {
        event.preventDefault();
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
    }
    onPointerUp(event) {
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
        this.attachDomHandlers();
    }
    onContextMenu(event) {
        event.preventDefault();
        const action = getAction(event, this.dragTarget);
        this.service.handleDragAndDrop(action);
        this.attachDomHandlers();
    }
    dragHandles;
    constructor(element, renderer, ngZone, service, viewContainer) {
        this.element = element;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.service = service;
        this.viewContainer = viewContainer;
        validatePackage(packageMetadata);
    }
    ngOnInit() {
        this.initializeDragTarget();
    }
    ngAfterContentInit() {
        if (isPresent(this.element) || isPresent(this.dragTarget)) {
            this.attachDomHandlers();
            if (!this.dragHandles.length) {
                this.renderer.setStyle(this.nativeElement, 'cursor', this.cursorStyle);
            }
        }
        this.service.dragTargets.push(this.dragTarget);
    }
    ngOnDestroy() {
        this.removeListeners();
        const currentDragTargetIndex = this.service.dragTargets.indexOf(this.dragTarget);
        this.service.dragTargets.splice(currentDragTargetIndex, 1);
    }
    handlePress(event) {
        this.pressed = true;
        if (this.dragDelay > 0) {
            this.dragTimeout = window.setTimeout(() => {
                this.dragReady = true;
                this.emitZoneAwareEvent('onDragReady', event);
            }, this.dragDelay);
        }
        else {
            this.dragReady = true;
        }
        this.scrollableParent = this.dragTarget.element ? getScrollableParent(this.dragTarget.element) : null;
        this.prevUserSelect = this.dragTarget.element.style.userSelect;
        this.renderer.setStyle(this.dragTarget.element, 'user-select', 'none');
        this.emitZoneAwareEvent('onPress', event);
    }
    handleDragStart(event) {
        if (!this.pressed) {
            if (this.dragTimeout) {
                window.clearTimeout(this.dragTimeout);
                this.dragTimeout = null;
            }
            return;
        }
        if (!this.dragReady) {
            return;
        }
        isDragStartPrevented = this.emitZoneAwareEvent('onDragStart', event).isDefaultPrevented();
        if (isDragStartPrevented) {
            return;
        }
        if (this.hint) {
            this.createHint();
            if (this.mode === 'auto') {
                this.renderer.setStyle(this.nativeElement, 'opacity', '0.7');
            }
            this.initialPosition = { x: event.offsetX, y: event.offsetY };
        }
        else {
            this.initialPosition = { x: event.clientX - this.position.x, y: event.clientY - this.position.y };
        }
        this.dragStarted = this.threshold === 0;
        this.service.dragTarget = this.dragTarget;
        this.service.dragTargetDirective = this;
        this.service.dragData = this.dragData({ dragTarget: this.dragTarget.element, dragTargetId: this.dragTargetIdResult, dragTargetIndex: null });
    }
    handleDrag(event) {
        if (!this.pressed || !this.dragReady || isDragStartPrevented) {
            return;
        }
        const elem = this.hint ? this.hintElem : this.nativeElement;
        this.position = this.calculatePosition(elem, event);
        const thresholdNotReached = Math.abs(this.position.x) < this.threshold && Math.abs(this.position.y) < this.threshold;
        if (!this.dragStarted && thresholdNotReached) {
            return;
        }
        if (!this.dragStarted && this.threshold > 0) {
            this.dragStarted = true;
        }
        isDragPrevented = this.emitZoneAwareEvent('onDrag', event).isDefaultPrevented();
        if (isDragPrevented) {
            return;
        }
        if (this.mode === 'auto') {
            this.performDrag();
        }
        else {
            this.dragStarted = true;
        }
    }
    handleRelease(event) {
        if (this.dragTimeout) {
            clearTimeout(this.dragTimeout);
            this.dragTimeout = null;
        }
        this.pressed = false;
        this.dragReady = false;
        this.prevUserSelect ? this.renderer.setStyle(this.dragTarget.element, 'user-select', this.prevUserSelect) :
            this.renderer.removeStyle(this.dragTarget.element, 'user-select');
        this.prevUserSelect = null;
        this.emitZoneAwareEvent('onRelease', event);
    }
    handleDragEnd(event) {
        if (this.mode === 'auto') {
            const isDroppedOverParentTarget = isPresent(this.service.dropTarget) && !contains(this.service.dropTarget?.element, this.service.dragTarget?.element, true);
            const elem = this.hint ? this.hintElem : this.nativeElement;
            if (isDroppedOverParentTarget || this.service.dropTargets.length > 0 && isPresent(elem)) {
                this.renderer.removeStyle(elem, 'transform');
                setElementStyles(this.renderer, elem, {
                    transition: dragTargetTransition
                });
                this.position = { x: 0, y: 0 };
            }
        }
        if (this.hint && isPresent(this.hintElem)) {
            this.destroyHint();
            if (this.mode === 'auto') {
                this.renderer.removeStyle(this.nativeElement, 'opacity');
            }
        }
        this.service.dragTarget = null;
        this.service.dragTargetDirective = null;
        if (!this.dragStarted || isDragStartPrevented || isDragPrevented) {
            return;
        }
        this.emitZoneAwareEvent('onDragEnd', event);
        this.dragStarted = false;
    }
    initializeDragTarget() {
        this.dragTarget = {
            element: this.nativeElement,
            hint: null,
            onPress: this.handlePress.bind(this),
            onRelease: this.handleRelease.bind(this),
            onDragStart: this.handleDragStart.bind(this),
            onDrag: this.handleDrag.bind(this),
            onDragEnd: this.handleDragEnd.bind(this)
        };
    }
    get supportPointerEvent() {
        return Boolean(typeof window !== 'undefined' && window.PointerEvent);
    }
    removeListeners() {
        if (isPresent(this.scrollableParent)) {
            this.scrollableParent.removeEventListener('scroll', this.onPointerMove);
        }
        const element = this.nativeElement;
        if (!isDocumentAvailable()) {
            return;
        }
        document.removeEventListener('pointermove', this.onPointerMove);
        document.removeEventListener('pointerup', this.onPointerUp, true);
        document.removeEventListener('contextmenu', this.onContextMenu);
        document.removeEventListener('pointercancel', this.onPointerUp);
        window.removeEventListener('touchmove', noop);
        element.removeEventListener('touchmove', this.onTouchMove);
        element.removeEventListener('touchend', this.onPointerUp);
        document.removeEventListener('mousemove', this.onPointerMove);
        document.removeEventListener('mouseup', this.onPointerUp);
        document.removeEventListener('touchcancel', this.onPointerUp);
        element.removeEventListener('pointerdown', this.onPointerDown);
        element.removeEventListener('mousedown', this.onPointerDown);
        element.removeEventListener('touchstart', this.onTouchStart);
    }
    attachDomHandlers() {
        this.ngZone.runOutsideAngular(() => {
            this.removeListeners();
            if (!(isDocumentAvailable() && isPresent(this.element))) {
                return;
            }
            this.onPointerMove = this.onPointerMove.bind(this);
            this.onPointerUp = this.onPointerUp.bind(this);
            this.onTouchMove = this.onTouchMove.bind(this);
            this.onContextMenu = this.onContextMenu.bind(this);
            this.onPointerDown = this.onPointerDown.bind(this);
            this.onTouchStart = this.onTouchStart.bind(this);
            const element = this.nativeElement;
            if (this.supportPointerEvent) {
                if (isPresent(this.scrollableParent)) {
                    if (this.scrollableParent === document.getElementsByTagName('html')[0]) {
                        this.scrollableParent = window;
                    }
                    this.scrollableParent.addEventListener('scroll', this.onPointerMove, { passive: true });
                }
                element.addEventListener('pointerdown', this.onPointerDown, { passive: true });
                if (this.pressed) {
                    document.addEventListener('pointermove', this.onPointerMove);
                    document.addEventListener('pointerup', this.onPointerUp, true);
                    document.addEventListener('contextmenu', this.onContextMenu);
                    document.addEventListener('pointercancel', this.onPointerUp, { passive: true });
                }
            }
            else {
                window.addEventListener('touchmove', noop, { capture: false, passive: false });
                element.addEventListener('mousedown', this.onPointerDown, { passive: true });
                element.addEventListener('touchstart', this.onTouchStart, { passive: true });
                if (this.pressed) {
                    document.addEventListener('mousemove', this.onPointerMove, { passive: true });
                    document.addEventListener('mouseup', this.onPointerUp, { passive: true });
                    element.addEventListener('touchmove', this.onTouchMove, { passive: true });
                    element.addEventListener('touchend', this.onPointerUp, { passive: true });
                }
            }
        });
    }
    isDragHandle(el) {
        return this.dragHandles.toArray().some(dh => contains(dh.element.nativeElement, el, true));
    }
    getAutoScrollContainer() {
        return typeof this.autoScroll === 'object' &&
            this.autoScroll.boundaryElementRef &&
            this.autoScroll.boundaryElementRef.nativeElement ?
            this.autoScroll.boundaryElementRef.nativeElement : null;
    }
    createHint() {
        if (!(isDocumentAvailable() && isPresent(this.element))) {
            return;
        }
        if (isPresent(this.hint) && typeof this.hint === 'object') {
            if (isPresent(this.hint.hintTemplate)) {
                this.createCustomHint();
            }
            else {
                this.createDefaultHint();
            }
        }
        else {
            this.createDefaultHint();
        }
        this.dragTarget.hint = this.hintElem;
        if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {
            this.hint.appendTo.element.nativeElement.appendChild(this.hintElem);
        }
        else {
            document.body.appendChild(this.hintElem);
        }
    }
    createDefaultHint() {
        this.defaultHint = this.nativeElement.cloneNode(true);
        if (typeof this.hint === 'object') {
            if (isPresent(this.hint.hintClass)) {
                const hintClasses = parseCSSClassNames(this.hint.hintClass);
                hintClasses.forEach(className => this.renderer.addClass(this.defaultHint, className));
            }
        }
    }
    createCustomHint() {
        if (isPresent(this.hint.appendTo)) {
            this.hintComponent = this.hint.appendTo.createComponent(HintComponent);
        }
        else {
            this.hintComponent = this.viewContainer.createComponent(HintComponent);
        }
        this.hintComponent.instance.template = this.hintTemplate;
        this.hintComponent.instance.directive = this;
        this.hintComponent.changeDetectorRef.detectChanges();
    }
    destroyHint() {
        if (isPresent(this.hintTemplate)) {
            this.hintComponent.destroy();
            this.hintComponent.changeDetectorRef.detectChanges();
            this.hintComponent = null;
        }
        else {
            if (typeof this.hint === 'object' && isPresent(this.hint.appendTo)) {
                this.hint.appendTo.element.nativeElement.removeChild(this.defaultHint);
            }
            else {
                document.body.removeChild(this.defaultHint);
            }
            this.defaultHint = null;
        }
        this.dragTarget.hint = null;
    }
    emitZoneAwareEvent(event, normalizedEvent) {
        const eventProps = {
            dragTarget: this.nativeElement,
            dragEvent: normalizedEvent
        };
        if (this.hint && isPresent(this.hintElem)) {
            eventProps.hintElement = this.hintElem;
        }
        if (this.dragTargetId && this.dragTargetId !== '') {
            eventProps.dragTargetId = this.dragTargetIdResult;
        }
        let eventArgs;
        switch (event) {
            case 'onDragReady':
                eventArgs = new DragTargetDragReadyEvent(eventProps);
                break;
            case 'onPress':
                eventArgs = new DragTargetPressEvent(eventProps);
                break;
            case 'onDragStart':
                eventArgs = new DragTargetDragStartEvent(eventProps);
                break;
            case 'onDrag':
                eventArgs = new DragTargetDragEvent(eventProps);
                break;
            case 'onRelease':
                eventArgs = new DragTargetReleaseEvent(eventProps);
                break;
            case 'onDragEnd':
                eventArgs = new DragTargetDragEndEvent(eventProps);
                break;
            default:
                break;
        }
        this.ngZone.run(() => {
            this[event].emit(eventArgs);
        });
        return eventArgs;
    }
    get dragTargetIdResult() {
        if (this.dragTargetId && this.dragTargetId !== '') {
            return typeof this.dragTargetId === 'string' ? this.dragTargetId : this.dragTargetId({ dragTarget: this.dragTarget.element, dragTargetIndex: null });
        }
    }
    performDrag() {
        const elem = this.hint ? this.hintElem : this.nativeElement;
        if (elem) {
            const styles = this.getStylesPerElement(elem);
            setElementStyles(this.renderer, elem, styles);
        }
    }
    calculatePosition(element, event) {
        let position = null;
        if (element === this.hintElem) {
            position = { x: event.clientX + window.scrollX, y: event.clientY + window.scrollY };
        }
        else {
            position = { x: event.clientX - this.initialPosition.x + event.scrollX, y: event.clientY - this.initialPosition.y + event.scrollY };
        }
        if (this.restrictByAxis === 'horizontal') {
            position.y = 0;
        }
        else if (this.restrictByAxis === 'vertical') {
            position.x = 0;
        }
        return position;
    }
    getStylesPerElement(element) {
        if (element === this.hintElem) {
            const hintCoordinates = { x: this.position.x - this.initialPosition.x, y: this.position.y - this.initialPosition.y };
            return {
                top: `${hintCoordinates.y}px`,
                left: `${hintCoordinates.x}px`,
                transition: 'none',
                position: 'absolute',
                zIndex: 1999
            };
        }
        else {
            const transform = `translate(${this.position.x}px, ${this.position.y}px)`;
            return {
                transform: transform,
                transition: 'none'
            };
        }
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragTargetDirective, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: i0.NgZone }, { token: DragStateService }, { token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DragTargetDirective, isStandalone: true, selector: "[kendoDragTarget]", inputs: { hint: "hint", threshold: "threshold", autoScroll: "autoScroll", dragTargetId: "dragTargetId", dragDelay: "dragDelay", restrictByAxis: "restrictByAxis", mode: "mode", dragData: "dragData", cursorStyle: "cursorStyle" }, outputs: { onPress: "onPress", onDragStart: "onDragStart", onDrag: "onDrag", onDragReady: "onDragReady", onRelease: "onRelease", onDragEnd: "onDragEnd" }, host: { properties: { "style.touch-action": "this.touchActionStyle" } }, queries: [{ propertyName: "dragHandles", predicate: DragHandleDirective, descendants: true }], exportAs: ["kendoDragTarget"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragTargetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDragTarget]',
                    exportAs: 'kendoDragTarget',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: i0.NgZone }, { type: DragStateService }, { type: i0.ViewContainerRef }]; }, propDecorators: { touchActionStyle: [{
                type: HostBinding,
                args: ['style.touch-action']
            }], hint: [{
                type: Input
            }], threshold: [{
                type: Input
            }], autoScroll: [{
                type: Input
            }], dragTargetId: [{
                type: Input
            }], dragDelay: [{
                type: Input
            }], restrictByAxis: [{
                type: Input
            }], mode: [{
                type: Input
            }], dragData: [{
                type: Input
            }], cursorStyle: [{
                type: Input
            }], onPress: [{
                type: Output
            }], onDragStart: [{
                type: Output
            }], onDrag: [{
                type: Output
            }], onDragReady: [{
                type: Output
            }], onRelease: [{
                type: Output
            }], onDragEnd: [{
                type: Output
            }], dragHandles: [{
                type: ContentChildren,
                args: [DragHandleDirective, { descendants: true }]
            }] } });

/**
 * Arguments for the drag events of the `DropTarget` and `DropTargetContainer` directives.
 */
class DropTargetEvent {
    /**
     * The current drag target element.
     */
    dragTarget;
    /**
     * The current drop target element.
     */
    dropTarget;
    /**
     * The information related to the current drag event.
     */
    dragEvent;
    /**
     * The data passed to the `dragData` input property of the `DragTarget` or `DragTargetContainer` directive.
     */
    dragData;
    /**
     * The index of the current drop target in the collection of drop targets. Applies to `DropTargetContainer` directive.
     */
    dropTargetIndex;
    /**
     * The hint element of the `DragTarget`.
     */
    hintElement;
    /**
     * Left for backward compatibility for the DropTarget deprecated events.
     * @hidden
     */
    get normalizedEvent() {
        return this.dragEvent;
    }
    /**
     * Left for backward compatibility for the DropTarget deprecated events.
     * @hidden
     */
    get hostElement() {
        return this.dropTarget;
    }
    /**
     * @hidden
     */
    constructor(args) {
        Object.assign(this, args);
    }
}

/**
 * Represents the [Kendo UI DropTargetContainer directive for Angular]({% slug api_utils_droptargetcontainerdirective %}).
 * Use this directive to make multiple elements drop targets inside a container.
 *
 * @example
 * ```html
 * <div kendoDropTargetContainer dropTargetFilter=".my-droptarget">
 *   <div class="my-droptarget">
 *     Drop here
 *   </div>
 * </div>
 * ```
 */
class DropTargetContainerDirective {
    service;
    element;
    ngZone;
    cdr;
    /**
     * Sets a selector for elements in the container to make them drop targets. [See example]({% slug drop_target_container %}).
     */
    set dropTargetFilter(value) {
        this._dropTargetFilter = value;
        if (!this.dropDisabled) {
            this.initializeDropTargets();
        }
    }
    get dropTargetFilter() {
        return this._dropTargetFilter;
    }
    /**
     * Specifies whether the drop targets within the container will emit the corresponding events upon interaction with a drag target.
     */
    set dropDisabled(value) {
        this._dropDisabled = value;
        if (value) {
            this.clearPreviousTargets();
        }
        else {
            this.initializeDropTargets();
        }
    }
    get dropDisabled() {
        return this._dropDisabled;
    }
    /**
     * Fires when a drag target enters a drop target.
     */
    onDragEnter = new EventEmitter();
    /**
     * Fires when a drag target is dragged over a drop target.
     */
    onDragOver = new EventEmitter();
    /**
     * Fires when a drag target leaves a drop target.
     */
    onDragLeave = new EventEmitter();
    /**
     * Fires when a drag target is dropped over a drop target.
     */
    onDrop = new EventEmitter();
    /**
     * Notifies the `DropTargetContainer` that its content has changed.
     */
    notify() {
        this.cdr.detectChanges();
        this.initializeDropTargets();
    }
    constructor(service, element, ngZone, cdr) {
        this.service = service;
        this.element = element;
        this.ngZone = ngZone;
        this.cdr = cdr;
        validatePackage(packageMetadata);
    }
    currentDropTargetElement = null;
    previousDropTargets = [];
    _dropTargetFilter = null;
    _dropDisabled = false;
    get nativeElement() {
        return this.element.nativeElement;
    }
    ngAfterViewInit() {
        !this.dropDisabled && this.initializeDropTargets();
    }
    get allDropTargets() {
        if (isPresent(this.dropTargetFilter) && this.dropTargetFilter !== '') {
            return Array.from(this.nativeElement.querySelectorAll(this.dropTargetFilter));
        }
    }
    /**
     * @hidden
     */
    handleDragEnter(event) {
        if (!this.service.dragTargetPresent || this.service.dropTargetPresent) {
            return;
        }
        const currDragTargetElement = this.service.dragTarget.hint || this.service.dragTarget.element;
        const currDropTargetElem = intersect(currDragTargetElement, this.allDropTargets);
        const currDropTarget = this.service.dropTargets.find(dt => dt.element === currDropTargetElem);
        if (!isPresent(currDropTargetElem) || !isPresent(currDropTarget)) {
            return;
        }
        this.currentDropTargetElement = currDropTargetElem;
        this.service.dropTarget = currDropTarget;
        this.service.dropIndex = this.getDropIndex();
        this.emitZoneAwareEvent('onDragEnter', event);
    }
    /**
     * @hidden
     */
    handleDragLeave(event) {
        if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
            return;
        }
        this.emitZoneAwareEvent('onDragLeave', event);
        this.currentDropTargetElement = null;
        this.service.dropTarget = null;
        this.service.dropIndex = null;
    }
    /**
     * @hidden
     */
    handleDragOver(event) {
        if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
            return;
        }
        this.emitZoneAwareEvent('onDragOver', event);
    }
    /**
     * @hidden
     */
    handleDrop(event) {
        if (!this.service.dragTargetPresent || !this.service.dropTargetPresent) {
            return;
        }
        this.emitZoneAwareEvent('onDrop', event);
        this.currentDropTargetElement = null;
        this.service.dropTarget = null;
        this.service.dropIndex = null;
    }
    initializeDropTargets() {
        if (!isPresent(this.allDropTargets)) {
            if (this.previousDropTargets.length > 0) {
                this.clearPreviousTargets();
            }
            return;
        }
        this.allDropTargets.forEach(dropTargetEl => {
            const isDropTargetInitialized = this.service.dropTargets.find(dt => dt.element === dropTargetEl);
            if (!isDropTargetInitialized) {
                this.service.dropTargets.push({
                    element: dropTargetEl,
                    onDragEnter: this.handleDragEnter.bind(this),
                    onDragLeave: this.handleDragLeave.bind(this),
                    onDragOver: this.handleDragOver.bind(this),
                    onDrop: this.handleDrop.bind(this)
                });
            }
        });
        if (this.previousDropTargets.length > 0) {
            const dropTargetsToRemove = this.previousDropTargets.filter(dt => !this.allDropTargets.includes(dt));
            dropTargetsToRemove.forEach(dropTarget => {
                const idx = this.service.dropTargets.findIndex(serviceDropTarget => serviceDropTarget.element === dropTarget);
                if (idx > -1) {
                    this.service.dropTargets.splice(idx, 1);
                }
            });
        }
        this.previousDropTargets = this.allDropTargets;
    }
    emitZoneAwareEvent(event, normalizedEvent) {
        const eventProps = {
            dragTarget: this.service.dragTarget?.element,
            dropTarget: this.currentDropTargetElement,
            dragData: this.service.dragData,
            dragEvent: normalizedEvent,
            dropTargetIndex: this.service.dropIndex
        };
        if (isPresent(this.service.dragTarget?.hint)) {
            eventProps.hintElement = this.service.dragTarget.hint;
        }
        const eventArgs = new DropTargetEvent(eventProps);
        this.ngZone.run(() => {
            this[event].emit(eventArgs);
        });
    }
    getDropIndex() {
        return this.allDropTargets.indexOf(this.currentDropTargetElement);
    }
    clearPreviousTargets() {
        this.previousDropTargets.forEach(dropTarget => {
            const idx = this.service.dropTargets.findIndex(serviceDropTarget => serviceDropTarget.element === dropTarget);
            if (idx > -1) {
                this.service.dropTargets.splice(idx, 1);
            }
        });
        this.previousDropTargets = [];
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetContainerDirective, deps: [{ token: DragStateService }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DropTargetContainerDirective, isStandalone: true, selector: "[kendoDropTargetContainer]", inputs: { dropTargetFilter: "dropTargetFilter", dropDisabled: "dropDisabled" }, outputs: { onDragEnter: "onDragEnter", onDragOver: "onDragOver", onDragLeave: "onDragLeave", onDrop: "onDrop" }, exportAs: ["kendoDropTargetContainer"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetContainerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDropTargetContainer]',
                    exportAs: 'kendoDropTargetContainer',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: DragStateService }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { dropTargetFilter: [{
                type: Input
            }], dropDisabled: [{
                type: Input
            }], onDragEnter: [{
                type: Output
            }], onDragOver: [{
                type: Output
            }], onDragLeave: [{
                type: Output
            }], onDrop: [{
                type: Output
            }] } });

/**
 * Represents the Kendo UI DropTarget directive for Angular.
 * Use this directive to make an element a drop target for draggable items.
 *
 * ```html
 * <div kendoDropTarget>
 *   Drop here
 * </div>
 * ```
 *
 */
class DropTargetDirective {
    service;
    element;
    ngZone;
    /**
     * Fires when a drag target enters the drop target.
     */
    onDragEnter = new EventEmitter();
    /**
     * Fires when a drag target is dragged over the drop target.
     */
    onDragOver = new EventEmitter();
    /**
     * Fires when a drag target leaves the drop target.
     */
    onDragLeave = new EventEmitter();
    /**
     * Fires when a drag target is dropped over the drop target.
     */
    onDrop = new EventEmitter();
    constructor(service, element, ngZone) {
        this.service = service;
        this.element = element;
        this.ngZone = ngZone;
        validatePackage(packageMetadata);
    }
    dropTarget;
    ngOnInit() {
        this.initializeDropTarget();
        this.service.dropTargets.push(this.dropTarget);
    }
    ngOnDestroy() {
        const currentDropTargetIndex = this.service.dropTargets.indexOf(this.dropTarget);
        this.service.dropTargets.splice(currentDropTargetIndex, 1);
    }
    /**
     * @hidden
     */
    handleDragEnter(event) {
        if (!this.service.dragTarget) {
            return;
        }
        this.service.dropTarget = this.dropTarget;
        this.emitZoneAwareEvent('onDragEnter', event);
    }
    /**
     * @hidden
     */
    handleDragLeave(event) {
        this.service.dropTarget = null;
        if (!this.service.dragTarget) {
            return;
        }
        this.emitZoneAwareEvent('onDragLeave', event);
    }
    /**
     * @hidden
     */
    handleDragOver(event) {
        if (!this.service.dragTarget) {
            return;
        }
        this.emitZoneAwareEvent('onDragOver', event);
    }
    /**
     * @hidden
     */
    handleDrop(event) {
        this.emitZoneAwareEvent('onDrop', event);
        this.service.dropTarget = null;
    }
    initializeDropTarget() {
        this.dropTarget = {
            element: this.element.nativeElement,
            onDragEnter: this.handleDragEnter.bind(this),
            onDragLeave: this.handleDragLeave.bind(this),
            onDragOver: this.handleDragOver.bind(this),
            onDrop: this.handleDrop.bind(this)
        };
    }
    emitZoneAwareEvent(event, normalizedEvent) {
        const eventProps = {
            dropTarget: this.element.nativeElement,
            dragTarget: this.service.dragTarget?.element,
            dragEvent: normalizedEvent,
            dragData: this.service.dragData
        };
        if (isPresent(this.service.dragTarget?.hint)) {
            eventProps.hintElement = this.service.dragTarget.element;
        }
        const eventArgs = new DropTargetEvent(eventProps);
        this.ngZone.run(() => {
            this[event].emit(eventArgs);
        });
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetDirective, deps: [{ token: DragStateService }, { token: i0.ElementRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Directive });
    static ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: DropTargetDirective, isStandalone: true, selector: "[kendoDropTarget]", outputs: { onDragEnter: "onDragEnter", onDragOver: "onDragOver", onDragLeave: "onDragLeave", onDrop: "onDrop" }, exportAs: ["kendoDropTarget"], ngImport: i0 });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DropTargetDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[kendoDropTarget]',
                    exportAs: 'kendoDropTarget',
                    standalone: true
                }]
        }], ctorParameters: function () { return [{ type: DragStateService }, { type: i0.ElementRef }, { type: i0.NgZone }]; }, propDecorators: { onDragEnter: [{
                type: Output
            }], onDragOver: [{
                type: Output
            }], onDragLeave: [{
                type: Output
            }], onDrop: [{
                type: Output
            }] } });

/**
 * Use this utility array to access all Drag and Drop-related components and directives in a standalone Angular component.
 *
 * @example
 * ```typescript
 * import { Component } from '@angular/core';
 * import { KENDO_DRAGANDDROP } from '@progress/kendo-angular-utils';
 *
 * @Component({
 *   selector: 'my-app',
 *   standalone: true,
 *   imports: [KENDO_DRAGANDDROP],
 *   template: `
 *      <div kendoDragTarget>Drag me</div>
 *      <div kendoDropTarget>Drop here</div>
 *   `
 * })
 * export class AppComponent {}
 * ```
 */
const KENDO_DRAGANDDROP = [
    DragTargetDirective,
    DragHandleDirective,
    DropTargetDirective,
    DragTargetContainerDirective,
    DropTargetContainerDirective,
    HintComponent
];
/**
* Use this utility array to access all `@progress/kendo-angular-utils`-related components and directives in a standalone Angular component.
* > Currently, `KENDO_UTILS` includes only the `KENDO_DRAGANDDROP` utility array and their usage is equivalent.
*/
const KENDO_UTILS = [
    ...KENDO_DRAGANDDROP
];

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules'])
 * definition for the Utils components.
 *
 * @example
 * ```ts
 * import { UtilsModule } from '@progress/kendo-angular-utils';
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { NgModule } from '@angular/core';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, UtilsModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class UtilsModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UtilsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: UtilsModule, imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent], exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UtilsModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: UtilsModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_UTILS],
                    imports: [...KENDO_UTILS]
                }]
        }] });

// IMPORTANT: NgModule export kept for backwards compatibility
/**
 * Represents the [`NgModule`](link:site.data.urls.angular['ngmodules'])
 * definition for the Drag and Drop directives.
 *
 * @example
 * ```ts
 * import { DragAndDropModule } from '@progress/kendo-angular-utils';
 * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
 * import { NgModule } from '@angular/core';
 * import { AppComponent } from './app.component';
 *
 * @NgModule({
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, DragAndDropModule],
 *     bootstrap:    [AppComponent]
 * })
 * export class AppModule {}
 * ```
 */
class DragAndDropModule {
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropModule, imports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent], exports: [DragTargetDirective, DragHandleDirective, DropTargetDirective, DragTargetContainerDirective, DropTargetContainerDirective, HintComponent] });
    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropModule });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: DragAndDropModule, decorators: [{
            type: NgModule,
            args: [{
                    exports: [...KENDO_DRAGANDDROP],
                    imports: [...KENDO_DRAGANDDROP]
                }]
        }] });

/**
 * A service that lets you change the current adaptive settings dynamically. Use the public `notify` method to update the settings.
 */
class AdaptiveSettingsService {
    /**
     * @hidden
     */
    changes = new Subject();
    /**
     * Notifies subscribers that the adaptive settings have changed.
     *
     * @param adaptiveSettings - (Optional) A new value for the adaptive settings token.
     */
    notify(adaptiveSettings) {
        this.changes.next(adaptiveSettings);
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveSettingsService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveSettingsService });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveSettingsService, decorators: [{
            type: Injectable
        }] });

/**
 * A token that specifies the `AdaptiveSettings` for Kendo UI for Angular components.
 *
 * @example
 * ```ts
 * import { NgModule } from '@angular/core';
 *
 * @NgModule({
 *   ...,
 *   providers: [{ provide: ADAPTIVE_SETTINGS, useValue: { small: 400, medium: 600 } }]
 * })
 * export class AppModule {}
 * ```
 */
const ADAPTIVE_SETTINGS = new InjectionToken('Kendo UI Adaptive-Settings token');

const DEFAULT_ADAPTIVE_SETTINGS = {
    small: 500,
    medium: 768
};
/**
 * The service responsible for handling changes in adaptive settings. Add it to the providers array when using adaptive breakpoints in a standalone component.
 *
 * @example
 * ```ts
 * import { AdaptiveService } from '@progress/kendo-angular-utils';
 *
 * @Component({
 *   selector: 'my-component',
 *   standalone: true,
 *   providers: [AdaptiveService, { provide: ADAPTIVE_SETTINGS, useValue: { small: 300 } }],
 *   template: '...'
 * })
 * export class AppComponent {}
 * ```
 */
class AdaptiveService {
    _adaptiveSettings;
    zone;
    /**
     * Notifies subscribers of the initial adaptive settings, and upon each call to `notify`.
     * @hidden
     */
    changes = new BehaviorSubject(this.adaptiveSettings || { small: 500, medium: 700 });
    /**
     * Notifies subscribers when the window size changes to any of small, medium, or large depending on the set adaptive size breakpoints.
     * @hidden
     */
    sizeChanges = new BehaviorSubject(this.size);
    subs = new Subscription();
    previousSize;
    constructor(_adaptiveSettings, adaptiveSettingsService, zone) {
        this._adaptiveSettings = _adaptiveSettings;
        this.zone = zone;
        if (adaptiveSettingsService) {
            this.subs.add(adaptiveSettingsService.changes
                .pipe(map(adaptiveSettings => isPresent$1(adaptiveSettings) ? adaptiveSettings : this._adaptiveSettings), tap(adaptiveSettings => this._adaptiveSettings = adaptiveSettings))
                .subscribe(adaptiveSettings => this.changes.next(adaptiveSettings)));
        }
        if (isPresent$1(this.adaptiveSettings) && !areObjectsEqual(this.adaptiveSettings, DEFAULT_ADAPTIVE_SETTINGS)) {
            this.changes.next(this.adaptiveSettings);
        }
        if (isDocumentAvailable()) {
            this.zone.runOutsideAngular(() => {
                this.subs.add(fromEvent(window, 'resize')
                    .pipe(tap(() => !this.previousSize && (this.previousSize = this.size)), filter(() => this.previousSize !== this.size))
                    .subscribe(() => {
                    this.previousSize = this.size;
                    this.zone.run(() => {
                        this.sizeChanges.next(this.size);
                    });
                }));
            });
        }
    }
    /**
     * @hidden
     */
    get adaptiveSettings() {
        return this._adaptiveSettings;
    }
    /**
     * @hidden
     */
    get size() {
        if (!isDocumentAvailable()) {
            return;
        }
        const settings = Object.assign(DEFAULT_ADAPTIVE_SETTINGS, this.adaptiveSettings);
        if (window.innerWidth > settings.medium) {
            return 'large';
        }
        else if (window.innerWidth > settings.small) {
            return 'medium';
        }
        else {
            return 'small';
        }
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
    }
    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveService, deps: [{ token: ADAPTIVE_SETTINGS, optional: true }, { token: AdaptiveSettingsService, optional: true }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Injectable });
    static ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveService, providedIn: 'root' });
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: AdaptiveService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [ADAPTIVE_SETTINGS]
                }] }, { type: AdaptiveSettingsService, decorators: [{
                    type: Optional
                }] }, { type: i0.NgZone }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { ADAPTIVE_SETTINGS, AdaptiveService, AdaptiveSettingsService, DragAndDropModule, DragHandleDirective, DragTargetContainerDirective, DragTargetDirective, DragTargetDragEndEvent, DragTargetDragEvent, DragTargetDragReadyEvent, DragTargetDragStartEvent, DragTargetPressEvent, DragTargetReleaseEvent, DropTargetContainerDirective, DropTargetDirective, DropTargetEvent, HintComponent, KENDO_DRAGANDDROP, KENDO_UTILS, UtilsModule };

