/**-----------------------------------------------------------------------------------------
* Copyright Â© 2025 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.patchModules = exports.getNGVersion = exports.waitToLoadApp = exports.loadUrl = exports.kill = exports.execAsync = exports.exec = exports.printSpecificKeys = exports.checkStringInFile = exports.replaceAllStringInFile = exports.replaceStringInFile = exports.deleteFileIfExists = exports.copyFile = exports.copyFolder = exports.cleanFolder = exports.packSchematics = exports.schematicsPackagePath = exports.schematicsPackageName = exports.schematicsPath = exports.tempDir = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs"));
const path_1 = require("path");
const child_process_1 = require("child_process");
const util_1 = require("util");
const kendo_e2e_1 = require("@progress/kendo-e2e");
const fs_1 = require("fs");
const execSync = (0, util_1.promisify)(child_process_1.exec);
exports.tempDir = (0, path_1.resolve)('../tmp');
exports.schematicsPath = (0, path_1.resolve)("./dist/libs/schematics/");
exports.schematicsPackageName = 'progress-kendo-angular-schematics-0.0.0-PLACEHOLDER.tgz';
exports.schematicsPackagePath = (0, path_1.resolve)(`${exports.tempDir}/${exports.schematicsPackageName}`);
async function packSchematics() {
    await deleteFileIfExists(exports.schematicsPackageName, exports.schematicsPath);
    await deleteFileIfExists(exports.schematicsPackageName, exports.tempDir);
    const output = await exec('npm pack', exports.schematicsPath);
    if (!output.stdout.includes(exports.schematicsPackageName)) {
        console.warn(`Output: ${output}`);
        throw new Error('Failed to pack schematics.');
    }
    copyFile((0, path_1.resolve)(`${exports.schematicsPath}/${exports.schematicsPackageName}`), exports.schematicsPackagePath);
}
exports.packSchematics = packSchematics;
function cleanFolder(dir) {
    const resolvedDir = (0, path_1.resolve)(dir);
    if ((0, fs_1.existsSync)(resolvedDir)) {
        console.log(`Cleanup: ${resolvedDir}`);
        (0, fs_1.rmSync)(resolvedDir, { recursive: true, force: true });
    }
    console.log(`Create: ${resolvedDir}`);
    (0, fs_1.mkdirSync)(resolvedDir, { recursive: true });
}
exports.cleanFolder = cleanFolder;
function copyFolder(sourceFolder, targetFolder) {
    const src = (0, path_1.resolve)(sourceFolder);
    const target = (0, path_1.resolve)(targetFolder);
    if (!(0, fs_1.existsSync)(src)) {
        throw new Error(`Source folder does not exist: ${src}`);
    }
    // Ensuring the target folder is accessible before copying
    if (!(0, fs_1.existsSync)(target)) {
        const tempFile = (0, fs_1.openSync)(target, 'w');
        (0, fs_1.closeSync)(tempFile);
    }
    try {
        (0, fs_1.cpSync)(src, target, { recursive: true, dereference: true });
        console.log(`Copy ${src} to ${target}`);
    }
    catch (error) {
        console.error(`Error copying ${src} to ${target}:`, error);
        throw error;
    }
}
exports.copyFolder = copyFolder;
function copyFile(sourceFilePath, targetFilePath) {
    (0, fs_1.cpSync)(sourceFilePath, targetFilePath, { force: true });
    console.log(`File '${sourceFilePath}' copied to '${targetFilePath}' successfully.`);
}
exports.copyFile = copyFile;
async function deleteFileIfExists(fileName, filePath) {
    try {
        const fullPathToFile = (0, path_1.resolve)(filePath + '/' + fileName);
        await fs.promises.unlink(fullPathToFile);
        console.log(`File: '${fullPathToFile}' has been deleted.`);
    }
    catch (error) {
        console.warn(`Error deleting file: ${error.message}`);
    }
}
exports.deleteFileIfExists = deleteFileIfExists;
function replaceStringInFile(filePath, oldString, newString) {
    const absolutePath = (0, path_1.resolve)(filePath);
    const content = (0, fs_1.readFileSync)(absolutePath, 'utf8');
    (0, fs_1.writeFileSync)(absolutePath, content.replace(oldString, newString), 'utf8');
    console.log(`Replace: ${oldString}\nWith: ${newString}\nIn: ${absolutePath}`);
}
exports.replaceStringInFile = replaceStringInFile;
function replaceAllStringInFile(filePath, oldString, newString) {
    const absolutePath = (0, path_1.resolve)(filePath);
    const content = (0, fs_1.readFileSync)(absolutePath, 'utf8');
    const regex = new RegExp(oldString, 'g');
    (0, fs_1.writeFileSync)(absolutePath, content.replace(regex, newString), 'utf8');
    console.log(`Replace: ${oldString}\nWith: ${newString}\nIn: ${filePath}`);
}
exports.replaceAllStringInFile = replaceAllStringInFile;
function checkStringInFile(filePath, searchString) {
    const absolutePath = (0, path_1.resolve)(filePath);
    const content = (0, fs_1.readFileSync)(absolutePath, 'utf8');
    const found = content.includes(searchString);
    console.log(`Search for: ${searchString}\nIn: ${absolutePath}\nFound: ${found}`);
    return found;
}
exports.checkStringInFile = checkStringInFile;
function printSpecificKeys(filePath, specificKey) {
    const absolutePath = (0, path_1.resolve)(filePath);
    const content = fs.readFileSync(absolutePath, 'utf8');
    const json = JSON.parse(content);
    function printKeys(obj) {
        for (const key in obj) {
            if (key === specificKey) {
                console.log(`The key : value pair is: ${key}: ${obj[key]}`);
            }
            if (typeof obj[key] === 'object' && obj[key] !== null) {
                printKeys(obj[key]);
            }
        }
    }
    printKeys(json);
}
exports.printSpecificKeys = printSpecificKeys;
async function exec(cmd, wd) {
    const cwd = (0, path_1.resolve)(wd);
    console.log(`Execute: ${cmd}\nCwd: ${cwd}`);
    return await execSync(cmd, { cwd: cwd });
}
exports.exec = exec;
function execAsync(cmd, wd) {
    const cwd = (0, path_1.resolve)(wd);
    console.log(`Execute: ${cmd}\nCwd: ${cwd}`);
    return (0, child_process_1.exec)(cmd, { cwd: cwd });
}
exports.execAsync = execAsync;
function kill(process) {
    // FIXES PIPEWRAP open handle
    process.stdout.destroy();
    process.stderr.destroy();
    process.stdin.destroy();
    // FIXES PROCESSWRAP open handle
    process.kill(); // (Optional: Just if you want to kill the process)
    process.unref(); // Necessary: fixes PROCESSWRAP
}
exports.kill = kill;
async function loadUrl(browser, url) {
    await browser.wait(async () => {
        try {
            await browser.navigateTo(url);
            return true;
        }
        catch {
            return false;
        }
    }, { timeout: 90000, message: `Failed to load ${url}`, pollTimeout: 1000 });
}
exports.loadUrl = loadUrl;
async function waitToLoadApp(browser, appName) {
    const preNG17 = `//*[text()='${appName} app is running!']`;
    const postNG17 = `//*[text()='Hello, ${appName}']`;
    const label = kendo_e2e_1.By.xpath(`${preNG17} | ${postNG17}`);
    return await browser.isVisible(label, { timeout: 60000 });
}
exports.waitToLoadApp = waitToLoadApp;
function getNGVersion(appPath) {
    const content = (0, fs_1.readFileSync)((0, path_1.resolve)(`${appPath}/package.json`), 'utf-8');
    const json = JSON.parse(content);
    const coreVersion = json.dependencies['@angular/core'];
    return parseInt(coreVersion.split('.')[0].substring(1));
}
exports.getNGVersion = getNGVersion;
function patchModules(appPath, kendoPackage) {
    const absoluteAppPath = (0, path_1.resolve)(appPath);
    const rootModules = (0, path_1.resolve)(`${absoluteAppPath}/node_modules/@progress/kendo-angular-schematics`);
    const packageModules = (0, path_1.resolve)(`${absoluteAppPath}/node_modules/@progress/${kendoPackage}/node_modules/@progress/kendo-angular-schematics`);
    if ((0, fs_1.existsSync)((0, path_1.resolve)(packageModules))) {
        console.log(`Replace schematics at ${packageModules} node_modules.`);
        cleanFolder(packageModules);
        copyFolder(rootModules, packageModules);
    }
}
exports.patchModules = patchModules;
//# sourceMappingURL=utils.js.map