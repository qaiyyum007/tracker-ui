/**-----------------------------------------------------------------------------------------
* Copyright Â© 2025 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.templateTransformer = void 0;
const node_html_parser_1 = require("node-html-parser");
function templateTransformer(root, j, ...processFns) {
    root
        .find(j.ClassDeclaration)
        .forEach(classPath => {
        // Skip if no decorators
        const classNode = classPath.node;
        if (!classNode.decorators || !classNode.decorators.length)
            return;
        // Find Component decorator
        const componentDecorator = classNode.decorators.find((decorator) => {
            if (decorator.expression && decorator.expression.type === 'CallExpression') {
                const callee = decorator.expression.callee;
                // Handle direct Component identifier
                if (callee.type === 'Identifier' && callee.name === 'Component') {
                    return true;
                }
                // Handle angular.core.Component or similar
                if (callee.type === 'MemberExpression' &&
                    callee.property &&
                    callee.property.type === 'Identifier' &&
                    callee.property.name === 'Component') {
                    return true;
                }
            }
            return false;
        });
        if (!componentDecorator || !componentDecorator.expression)
            return;
        const expression = componentDecorator.expression;
        if (expression.type !== 'CallExpression' || !expression.arguments.length)
            return;
        const componentOptions = expression.arguments[0];
        if (componentOptions.type !== 'ObjectExpression')
            return;
        // Find template and templateUrl properties
        const props = componentOptions.properties || [];
        const templateProp = props.find((prop) => (prop.key.type === 'Identifier' && prop.key.name === 'template') ||
            (prop.key.type === 'StringLiteral' && prop.key.value === 'template'));
        //   const templateUrlProp = props.find((prop: any) =>
        //     (prop.key.type === 'Identifier' && prop.key.name === 'templateUrl') ||
        //     (prop.key.type === 'StringLiteral' && prop.key.value === 'templateUrl')
        //   );
        // Process inline template
        if (templateProp) {
            // Extract template based on node type
            let originalTemplate;
            if (templateProp.value.type === 'StringLiteral' || templateProp.value.type === 'Literal') {
                originalTemplate = templateProp.value.value;
            }
            else if (templateProp.value.type === 'TemplateLiteral') {
                // For template literals, join quasis
                if (templateProp.value.quasis && templateProp.value.quasis.length) {
                    originalTemplate = templateProp.value.quasis
                        .map((q) => q.value.cooked || q.value.raw)
                        .join('');
                }
                else {
                    console.warn('Could not process TemplateLiteral properly');
                    return;
                }
            }
            else {
                console.warn(`Unsupported template type: ${templateProp.value.type}`);
                return;
            }
            const root = (0, node_html_parser_1.parse)(originalTemplate);
            processFns.forEach(fn => {
                fn(root);
            });
            // Transform template using Angular compiler
            const transformedTemplate = root.toString();
            if (transformedTemplate !== originalTemplate) {
                // Update template property
                if (templateProp.value.type === 'TemplateLiteral') {
                    // For template literals, create a new template literal
                    templateProp.value = j.templateLiteral([j.templateElement({ cooked: transformedTemplate, raw: transformedTemplate }, true)], []);
                }
                else {
                    // For string literals, update the value
                    templateProp.value.value = transformedTemplate;
                }
            }
        }
    });
}
exports.templateTransformer = templateTransformer;
