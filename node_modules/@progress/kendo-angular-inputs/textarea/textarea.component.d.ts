/**-----------------------------------------------------------------------------------------
* Copyright © 2025 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { ElementRef, EventEmitter, NgZone, Renderer2, ChangeDetectorRef, Injector } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { SeparatorOrientation } from '@progress/kendo-angular-common';
import { LocalizationService } from '@progress/kendo-angular-l10n';
import { TextFieldsBase } from '../text-fields-common/text-fields-base';
import { TextAreaFlow } from './models/flow';
import { TextAreaResize } from './models/resize';
import { InputRounded, InputFillMode, InputSize } from '../common/models';
import { TextAreaAdornmentsOrientation } from './models/adornments-orientation';
import { TextAreaPrefixComponent } from './textarea-prefix.component';
import { TextAreaSuffixComponent } from './textarea-suffix.component';
import * as i0 from "@angular/core";
/**
 * Represents the Kendo UI TextArea component for Angular.
 *
 * Use this component to let users enter and edit multi-line text.
 *
 * @example
 * ```html
 * <kendo-textarea [(ngModel)]="value" [rows]="5" [cols]="30"></kendo-textarea>
 * ```
 *
 * @remarks
 * Supported children components are: {@link TextAreaPrefixComponent}, {@link TextAreaSuffixComponent}.
 */
export declare class TextAreaComponent extends TextFieldsBase implements ControlValueAccessor {
    protected localizationService: LocalizationService;
    protected ngZone: NgZone;
    protected changeDetector: ChangeDetectorRef;
    protected renderer: Renderer2;
    protected injector: Injector;
    hostElement: ElementRef;
    /**
     * @hidden
     */
    focusableId: string;
    hostClasses: boolean;
    get flowCol(): boolean;
    get flowRow(): boolean;
    private _flow;
    /**
     * Specifies the flow direction of the TextArea sections. Use this property to set the position of adornments relative to the text area.
     */
    set flow(flow: TextAreaFlow);
    get flow(): TextAreaFlow;
    /**
     * Sets the HTML attributes of the inner focusable input element. Some attributes are required for component functionality and cannot be changed.
     */
    set inputAttributes(attributes: {
        [key: string]: string;
    });
    get inputAttributes(): {
        [key: string]: string;
    };
    /**
     * Specifies the orientation of the TextArea adornments. Use this property to set the position of adornments relative to each other.
     *
     */
    set adornmentsOrientation(orientation: TextAreaAdornmentsOrientation);
    get adornmentsOrientation(): TextAreaAdornmentsOrientation;
    /**
     * Sets the visible height of the text area in lines.
     */
    rows: number;
    /**
     * Sets the visible width of the text area in average character width.
     */
    cols: number;
    /**
     * Sets the maximum number of characters allowed in the text area.
     */
    maxlength: number;
    /**
     * Sets the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
     * @default 0
     */
    tabindex: number;
    /**
     * @hidden
     */
    set tabIndex(tabIndex: number);
    get tabIndex(): number;
    /**
     * Sets the resize behavior of the TextArea.
     *
     *
     * @default 'vertical'
     */
    resizable: TextAreaResize;
    /**
     * Sets the size of the TextArea. Controls the padding of the text area element ([see example]({% slug appearance_textarea %}#toc-size)).
     * @default 'medium'
     */
    set size(size: InputSize);
    get size(): InputSize;
    /**
     * Sets the border radius of the TextArea ([see example](slug:appearance_textarea#toc-roundness)).
     * @default 'medium'
     */
    set rounded(rounded: InputRounded);
    get rounded(): InputRounded;
    /**
     * Sets the background and border styles of the TextArea ([see example](slug:appearance_textarea#toc-fill-mode)).
     * @default 'solid'
     */
    set fillMode(fillMode: InputFillMode);
    get fillMode(): InputFillMode;
    /**
     * Shows the prefix separator in the TextArea.
     * The separator is rendered only if a prefix template is declared.
     *
     * @default false
     */
    showPrefixSeparator: boolean;
    /**
     * Shows the suffix separator in the TextArea.
     * The separator is rendered only if a suffix template is declared.
     *
     * @default false
     */
    showSuffixSeparator: boolean;
    /**
     * Fires when the TextArea is focused.
     *
     * Use the `onFocus` property to subscribe to this event.
     */
    onFocus: EventEmitter<any>;
    /**
     * Fires when the TextArea gets blurred.
     *
     * Use the `onBlur` property to subscribe to this event.
     */
    onBlur: EventEmitter<any>;
    /**
     * Fires when the value changes or the TextArea is blurred ([see example](slug:events_textarea)).
     *
     * The event does not fire when the value changes programmatically or through form control binding.
     */
    valueChange: EventEmitter<any>;
    private initialHeight;
    private resizeSubscription;
    private _size;
    private _rounded;
    private _fillMode;
    private _adornmentsOrientation;
    private _inputAttributes;
    private parsedAttributes;
    private get defaultAttributes();
    private get mutableAttributes();
    constructor(localizationService: LocalizationService, ngZone: NgZone, changeDetector: ChangeDetectorRef, renderer: Renderer2, injector: Injector, hostElement: ElementRef);
    ngAfterViewInit(): void;
    ngOnInit(): void;
    ngOnChanges(changes: any): void;
    /**
     * @hidden
     */
    prefix: TextAreaPrefixComponent;
    /**
     * @hidden
     */
    suffix: TextAreaSuffixComponent;
    /**
     * @hidden
     */
    writeValue(value: string): void;
    /**
     * @hidden
     */
    registerOnChange(fn: () => any): void;
    /**
     * @hidden
     */
    registerOnTouched(fn: () => any): void;
    updateValue(value: string): void;
    ngOnDestroy(): void;
    /**
     * @hidden
     */
    get resizableClass(): string;
    /**
     * @hidden
     */
    get isControlInvalid(): boolean;
    /**
     * @hidden
     */
    get isControlRequired(): boolean;
    /**
     * @hidden
     */
    get separatorOrientation(): SeparatorOrientation;
    /**
     * @hidden
     */
    get isFocused(): boolean;
    /**
     * @hidden
     */
    set isFocused(value: boolean);
    /**
     * @hidden
     */
    handleInput: (ev: any) => void;
    /**
     * @hidden
     */
    handleInputFocus: () => void;
    /**
     * Focuses the TextArea.
     */
    focus(): void;
    /**
     * Blurs the TextArea.
     */
    blur(): void;
    private resize;
    /**
     * @hidden
     */
    handleFocus(): void;
    /**
     * @hidden
     */
    handleBlur(): void;
    private setSelection;
    private selectAll;
    private handleClasses;
    private handleFlow;
    private setInputAttributes;
    static ɵfac: i0.ɵɵFactoryDeclaration<TextAreaComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<TextAreaComponent, "kendo-textarea", ["kendoTextArea"], { "focusableId": { "alias": "focusableId"; "required": false; }; "flow": { "alias": "flow"; "required": false; }; "inputAttributes": { "alias": "inputAttributes"; "required": false; }; "adornmentsOrientation": { "alias": "adornmentsOrientation"; "required": false; }; "rows": { "alias": "rows"; "required": false; }; "cols": { "alias": "cols"; "required": false; }; "maxlength": { "alias": "maxlength"; "required": false; }; "tabindex": { "alias": "tabindex"; "required": false; }; "tabIndex": { "alias": "tabIndex"; "required": false; }; "resizable": { "alias": "resizable"; "required": false; }; "size": { "alias": "size"; "required": false; }; "rounded": { "alias": "rounded"; "required": false; }; "fillMode": { "alias": "fillMode"; "required": false; }; "showPrefixSeparator": { "alias": "showPrefixSeparator"; "required": false; }; "showSuffixSeparator": { "alias": "showSuffixSeparator"; "required": false; }; }, { "onFocus": "focus"; "onBlur": "blur"; "valueChange": "valueChange"; }, ["prefix", "suffix"], ["kendo-textarea-prefix", "kendo-textarea-suffix"], true, never>;
}
